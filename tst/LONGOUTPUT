Hi!  I am GETFOL - a Fantastically Overrated Logician.
This is version 2.001, September 1994

GETFOL:: fetch LONGTEST;
fetch LONGTEST;
I am starting to fetch LONGTEST

GETFOL:: 
GETFOL:: probe all;

GETFOL:: 
GETFOL::     fetch TEST;
I am starting to fetch TEST

GETFOL:: 
GETFOL:: probe all;

GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 	fetch decide/decide.tst;
I am starting to fetch decide/decide.tst

GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: reset;
Resetting the whole GETFOL-system

GETFOL:: 
TESTS about using ptaut decider 

GETFOL:: DECLARE SENTCONST A B C;
A has been declared to be a Sentconst
B has been declared to be a Sentconst
C has been declared to be a Sentconst

GETFOL:: DECLARE SENTCONST P Q;
P has been declared to be a Sentconst
Q has been declared to be a Sentconst

GETFOL:: 
first propositional axiom 

GETFOL:: decide A imp ( B imp A ) using ptaut;

1   A imp (B imp A)     

GETFOL:: 
second propositional axiom 

GETFOL:: decide ( A imp ( B imp C ) ) imp ( ( A imp B ) imp ( A imp C ) ) using ptaut;

2   (A imp (B imp C)) imp ((A imp B) imp (A imp C))     

GETFOL:: 
third propositional axiom 

GETFOL:: decide ( (not B) imp (not A) ) imp ( ( (not B) imp A ) imp B ) using ptaut;

3   ((not B) imp (not A)) imp (((not B) imp A) imp B)     

GETFOL:: decide (wffif A then B else C) iff ((A and B) or (not A and C)) using ptaut;

4   (wffif A then B else C) iff ((A and B) or ((not A) and C))     

GETFOL:: reset;
Resetting the whole GETFOL-system

GETFOL:: DECLARE SENTCONST A B C;
A has been declared to be a Sentconst
B has been declared to be a Sentconst
C has been declared to be a Sentconst

GETFOL:: DECLARE PREDCONST P1 Q1 R1 1;
P1 has been declared to be a Predconst
Q1 has been declared to be a Predconst
R1 has been declared to be a Predconst

GETFOL:: DECLARE PREDCONST P2 Q2 R2 2;
P2 has been declared to be a Predconst
Q2 has been declared to be a Predconst
R2 has been declared to be a Predconst

GETFOL:: DECLARE INDVAR x y z w;
UNIVERSAL is a sort
x has been declared to be an Indvar
y has been declared to be an Indvar
z has been declared to be an Indvar
w has been declared to be an Indvar

GETFOL:: DECLARE INDCONST a b c;
UNIVERSAL is a sort
a has been declared to be an Indconst
b has been declared to be an Indconst
c has been declared to be an Indconst

GETFOL:: DECLARE FUNCONST f g h 1;
f has been declared to be a Funconst
g has been declared to be a Funconst
h has been declared to be a Funconst

GETFOL:: 
TESTS about using tautren and ptaut 

GETFOL:: 
a wff that need a complex renaming 

GETFOL:: decide forall x.(P1(x) and exists y.(Q2(x,y) imp Q2(a,b))) imp
     forall x.(P1(x) and exists z.(Q2(x,z) imp Q2(a,b))) using tautren,ptaut;

1   forall x. (P1(x) and exists y. (Q2(x, y) imp Q2(a, b))) imp forall x. (P1(x) and exists z. (Q2(x, z) imp Q2(a, b)))     

GETFOL:: decide ( (not (forall x.(P1(x) and Q2(x,a)))) imp (not R1(f(z))) ) imp
     ( (not (forall y.(P1(y) and Q2(y,a))) imp R1(f(z)) ) imp
       (forall z.(P1(z) and Q2(z,a))) ) using tautren,ptaut;

2   ((not forall x. (P1(x) and Q2(x, a))) imp (not R1(f(z)))) imp (((not forall y. (P1(y) and Q2(y, a))) imp R1(f(z))) imp forall z. (P1(z) and Q2(z, a)))     

GETFOL:: 
TESTS about using tautren and ptauteq 

GETFOL:: assume x=a a=f(a) g(b)=y y=z z=w f(y)=g(f(x)) g(f(x))=g(c);

3   x = a     (3)

4   a = f(a)     (4)

5   g(b) = y     (5)

6   y = z     (6)

7   z = w     (7)

8   f(y) = g(f(x))     (8)

9   g(f(x)) = g(c)     (9)

GETFOL:: decide (P1(x) iff P1(f(a))) and (P2(a,y) iff P2(f(a),w)) and
       (P2(f(y),g(c)) iff P2(g(c),g(f(x)))) and
       g(b)=z and f(a)=a and f(y)=g(c) by ^7:^1 using tautren,ptauteq;

10   (((((P1(x) iff P1(f(a))) and (P2(a, y) iff P2(f(a), w))) and (P2(f(y), g(c)) iff P2(g(c), g(f(x))))) and (g(b) = z)) and (f(a) = a)) and (f(y) = g(c))     (3 4 5 6 7 8 9)

GETFOL:: decide ( x=y and z=w and y=a and a=f(b) and w=f(z) ) imp
       (f(z)=z and f(b)=y and a=y) using tautren,ptauteq;

11   (((((x = y) and (z = w)) and (y = a)) and (a = f(b))) and (w = f(z))) imp (((f(z) = z) and (f(b) = y)) and (a = y))     

GETFOL:: decide f(g(x)) = f(g(x)) using ptaut;
decide couldn't prove that f(g(x)) = f(g(x))
is a tautology using ptaut.

GETFOL:: decide f(g(x)) = f(g(x)) using ptauteq;
decide couldn't prove that f(g(x)) = f(g(x))
is a tautology using ptauteq.

GETFOL:: decide f(g(x)) = f(g(x)) using tautren,ptauteq;

12   f(g(x)) = f(g(x))     

GETFOL:: 
TESTING nnf + reduce + skolemize + phexp + ptaut 

GETFOL:: reset;
Resetting the whole GETFOL-system

GETFOL:: declare indvar x z y;
UNIVERSAL is a sort
x has been declared to be an Indvar
z has been declared to be an Indvar
y has been declared to be an Indvar

GETFOL:: declare indconst a b c;
UNIVERSAL is a sort
a has been declared to be an Indconst
b has been declared to be an Indconst
c has been declared to be an Indconst

GETFOL:: declare funconst g h 2;
g has been declared to be a Funconst
h has been declared to be a Funconst

GETFOL:: declare funconst f 3;
f has been declared to be a Funconst

GETFOL:: declare predconst P R Q 1;
P has been declared to be a Predconst
R has been declared to be a Predconst
Q has been declared to be a Predconst

GETFOL:: declare predconst S T V 2;
S has been declared to be a Predconst
T has been declared to be a Predconst
V has been declared to be a Predconst

GETFOL:: decide forall x. exists y.
 wffif P(trmif P(y) then x else y)
  then P(trmif P(y) then trmif P(y) then x else trmif P(y) then x else y else y) or TRUE
   else P(y) or TRUE using nnf,reduce,skolemize,phexp,ptaut;

1   forall x. exists y. (wffif P(trmif P(y) then x else y) then (P(trmif P(y) then (trmif P(y) then x else (trmif P(y) then x else y)) else y) or TRUE) else (P(y) or TRUE))     

GETFOL:: decide  forall x. exists y.  wffif  P(x) then P(y) else not P(y) using
nnf,reduce,skolemize,phexp,ptaut;

2   forall x. exists y. (wffif P(x) then P(y) else (not P(y)))     

GETFOL:: 
TESTING nnf + reduce + skolemize + phexp + ptauteq 

GETFOL:: reset;
Resetting the whole GETFOL-system

GETFOL:: DECLARE PREDCONST P Q R 1;
P has been declared to be a Predconst
Q has been declared to be a Predconst
R has been declared to be a Predconst

GETFOL:: DECLARE INDVAR x y z w;
UNIVERSAL is a sort
x has been declared to be an Indvar
y has been declared to be an Indvar
z has been declared to be an Indvar
w has been declared to be an Indvar

GETFOL:: DECLARE INDCONST a b c;
UNIVERSAL is a sort
a has been declared to be an Indconst
b has been declared to be an Indconst
c has been declared to be an Indconst

GETFOL:: decide forall y. forall x. (x=y imp (P(y) or not P(x))) using nnf,reduce,skolemize,phexp,ptauteq;

1   forall y x. ((x = y) imp (P(y) or (not P(x))))     

GETFOL:: I am finished fetching decide/decide.tst

GETFOL:: 	reset;
Resetting the whole GETFOL-system

GETFOL:: 	fetch decide/monad.tst;
I am starting to fetch decide/monad.tst

GETFOL:: RESET;
Resetting the whole GETFOL-system

GETFOL:: NAMECONTEXT MONAD;
You have named the current context: MONAD

GETFOL:: declare indvar x z y;
UNIVERSAL is a sort
x has been declared to be an Indvar
z has been declared to be an Indvar
y has been declared to be an Indvar

GETFOL:: declare indconst a b c;
UNIVERSAL is a sort
a has been declared to be an Indconst
b has been declared to be an Indconst
c has been declared to be an Indconst

GETFOL:: declare funconst g h 2;
g has been declared to be a Funconst
h has been declared to be a Funconst

GETFOL:: declare funconst f 3;
f has been declared to be a Funconst

GETFOL:: declare predconst P R Q 1;
P has been declared to be a Predconst
R has been declared to be a Predconst
Q has been declared to be a Predconst

GETFOL:: declare predconst S T V 2;
S has been declared to be a Predconst
T has been declared to be a Predconst
V has been declared to be a Predconst

GETFOL:: 
GETFOL:: monad forall y. exists x. (P(y) or not P(x));

1   forall y. exists x. (P(y) or (not P(x)))     

GETFOL:: monad forall y. P(y) imp exists x. P(x);

2   forall y. P(y) imp exists x. P(x)     

GETFOL:: 
GETFOL:: monad forall x. exists y.
 wffif P(trmif P(y) then x else y)
  then P(trmif P(y) then trmif P(y) then x else trmif P(y) then x else y else y) or TRUE
   else P(y) or TRUE;

3   forall x. exists y. (wffif P(trmif P(y) then x else y) then (P(trmif P(y) then (trmif P(y) then x else (trmif P(y) then x else y)) else y) or TRUE) else (P(y) or TRUE))     

GETFOL:: monad forall x. exists y. wffif P(x) then P(y) else not P(y);

4   forall x. exists y. (wffif P(x) then P(y) else (not P(y)))     

GETFOL:: 
GETFOL:: monad forall y. exists x. (P(f(a,b,x)) or not P(f(a,b,y)));

5   forall y. exists x. (P(f(a, b, x)) or (not P(f(a, b, y))))     

GETFOL:: monad exists z. forall y. exists x. (P(f(z,b,x)) or not P(f(x,b,z)));

6   exists z. forall y. exists x. (P(f(z, b, x)) or (not P(f(x, b, z))))     

GETFOL:: monad exists z. forall y. exists x. (P(f(z,b,x)) or not P(f(x,b,y)));

7   exists z. forall y. exists x. (P(f(z, b, x)) or (not P(f(x, b, y))))     

GETFOL:: 
GETFOL:: 
GETFOL:: I am finished fetching decide/monad.tst

GETFOL:: 	reset;
Resetting the whole GETFOL-system

GETFOL:: 	fetch decide/monadeq.tst;
I am starting to fetch decide/monadeq.tst

GETFOL:: RESET;
Resetting the whole GETFOL-system

GETFOL:: NAMECONTEXT MONADEQ;
You have named the current context: MONADEQ

GETFOL:: DECLARE PREDCONST P Q R 1;
P has been declared to be a Predconst
Q has been declared to be a Predconst
R has been declared to be a Predconst

GETFOL:: DECLARE INDVAR x y z w;
UNIVERSAL is a sort
x has been declared to be an Indvar
y has been declared to be an Indvar
z has been declared to be an Indvar
w has been declared to be an Indvar

GETFOL:: DECLARE INDCONST a b c;
UNIVERSAL is a sort
a has been declared to be an Indconst
b has been declared to be an Indconst
c has been declared to be an Indconst

GETFOL:: monadeq exists x. x=a;

1   exists x. (x = a)     

GETFOL:: monadeq forall y. exists x. x=y;

2   forall y. exists x. (x = y)     

GETFOL:: monadeq forall y. forall x. (x=y imp (P(y) or not P(x)));

3   forall y x. ((x = y) imp (P(y) or (not P(x))))     

GETFOL:: I am finished fetching decide/monadeq.tst

GETFOL:: 	reset;
Resetting the whole GETFOL-system

GETFOL:: 	fetch decide/pltier.tst;
I am starting to fetch decide/pltier.tst

GETFOL:: reset;
Resetting the whole GETFOL-system

GETFOL:: declare indvar x,y,z,w;
UNIVERSAL is a sort
x has been declared to be an Indvar
y has been declared to be an Indvar
z has been declared to be an Indvar
w has been declared to be an Indvar

GETFOL:: declare indconst a,b,c,d;
UNIVERSAL is a sort
a has been declared to be an Indconst
b has been declared to be an Indconst
c has been declared to be an Indconst
d has been declared to be an Indconst

GETFOL:: declare predconst P,Q,R,S,T,U 1;
P has been declared to be a Predconst
Q has been declared to be a Predconst
R has been declared to be a Predconst
S has been declared to be a Predconst
T has been declared to be a Predconst
U has been declared to be a Predconst

GETFOL:: declare predconst F,G,H,I,J,K 2;
F has been declared to be a Predconst
G has been declared to be a Predconst
H has been declared to be a Predconst
I has been declared to be a Predconst
J has been declared to be a Predconst
K has been declared to be a Predconst

GETFOL:: declare sentconst S1,S2,S3,S4;
S1 has been declared to be a Sentconst
S2 has been declared to be a Sentconst
S3 has been declared to be a Sentconst
S4 has been declared to be a Sentconst

GETFOL:: 
This is Pelletier ' s problem n . 1 - 2 points 

GETFOL:: decide (S1 imp S2) iff (not S2 imp not S1) using ptaut;

1   (S1 imp S2) iff ((not S2) imp (not S1))     

GETFOL:: 
This is Pelletier ' s problem n . 2 - 2 points 

GETFOL:: decide not not S1 iff S1
using ptaut;

2   (not (not S1)) iff S1     

GETFOL:: 
This is Pelletier ' s problem n . 3 - 1 point 

GETFOL:: decide not (S1 imp S2) imp (S2 imp S1)
using ptaut;

3   (not (S1 imp S2)) imp (S2 imp S1)     

GETFOL:: 
This is Pelletier ' s problem n . 4 - 2 points 

GETFOL::  
decide (not S1 imp S2) iff (not S2 imp S1)
using nnf, ptaut;

4   ((not S1) imp S2) iff ((not S2) imp S1)     

GETFOL:: 
This is Pelletier ' s problem n . 5 - 4 points 

GETFOL::  
decide ((S1 or S2) imp (S1 or S3)) imp (S1 or (S2 imp S3))
using  ptaut;

5   ((S1 or S2) imp (S1 or S3)) imp (S1 or (S2 imp S3))     

GETFOL:: 
This is Pelletier ' s problem n . 6 - 2 points 

GETFOL::  
decide  (S1 or not S1) using  ptaut;

6   S1 or (not S1)     

GETFOL:: 
This is Pelletier ' s problem n . 7 - 3 points 

GETFOL:: decide (S1 or not not not S1) using ptaut;

7   S1 or (not (not (not S1)))     

GETFOL:: 
This is Pelletier ' s problem n . 8 - 5 points 

GETFOL:: decide ((S1 imp S2) imp S1) imp S1 using ptaut;

8   ((S1 imp S2) imp S1) imp S1     

GETFOL:: 
This is Pelletier ' s problem n . 9 - 6 points 

GETFOL:: decide ((S1 or S2) and (not S1 or S2) and (S1 or not S2)) imp 
not (not S1 or not S2) using ptaut;

9   (((S1 or S2) and ((not S1) or S2)) and (S1 or (not S2))) imp (not ((not S1) or (not S2)))     

GETFOL:: 
This is Pelletier ' s problem n . 10 - 4 points 

GETFOL:: assume S1 imp S3;

10   S1 imp S3     (10)

GETFOL:: assume S3 imp (S1 and S2);

11   S3 imp (S1 and S2)     (11)

GETFOL:: assume S1 imp (S2 or S3);

12   S1 imp (S2 or S3)     (12)

GETFOL:: decide S1 iff S3 by ^3:^1 using ptaut;

13   S1 iff S3     (10 11 12)

GETFOL:: 
This is Pelletier ' s problem n . 11 - 1 point 

GETFOL:: decide (S1 iff S1) using ptaut;

14   S1 iff S1     

GETFOL:: 
This is Pelletier ' s problem n . 12 - 7 points 

GETFOL:: decide ((S1 iff S2) iff S3) iff (S1 iff (S2 iff S3))
using ptaut;

15   ((S1 iff S2) iff S3) iff (S1 iff (S2 iff S3))     

GETFOL:: 
. . . and now , Pelletier ' problem n . 13 - 5 points 

GETFOL:: decide (S1 or (S2 and S3)) iff ((S1 or S2) and (S1 or S3))
using ptaut;

16   (S1 or (S2 and S3)) iff ((S1 or S2) and (S1 or S3))     

GETFOL:: 
here ' s Pelletier ' s n . 14 !! - 6 points 

GETFOL:: decide (S1 iff S2) iff ((S2 or not S1) and (not S2 or S1))
using ptaut;

17   (S1 iff S2) iff ((S2 or (not S1)) and ((not S2) or S1))     

GETFOL:: 
here ' s Pelletier ' s problem n . 15 - 5 points 

GETFOL::  
decide (S1 imp S2) iff (not S1 or S2) using ptaut;

18   (S1 imp S2) iff ((not S1) or S2)     

GETFOL:: 
This is Pelletier ' s problem n . 16 - 4 points 

GETFOL:: decide (S1 imp  S2) or (S2 imp S1) using ptaut;

19   (S1 imp S2) or (S2 imp S1)     

GETFOL:: 
This is Pelletier ' s problem n . 17 - 6 points 

GETFOL:: decide ((S1 and (S2 imp S3)) imp S4) iff ((not S1 or S2 or S4) and 
 (not S1 or not S3 or S4)) using ptaut;

20   ((S1 and (S2 imp S3)) imp S4) iff ((((not S1) or S2) or S4) and (((not S1) or (not S3)) or S4))     

GETFOL:: 
Problem ' s from Pelletier ' s collection : 

GETFOL:: 
section two : Monadic Predicate Logic 

GETFOL:: 
Pelletier 18 1 pt 

GETFOL:: decide exists x.(forall y.(forall z.((P(y) imp Q(z)) imp (P(x) imp Q(x)))))
 using nnf, reduce, skolemize, phexp, ptaut;

21   exists x. forall y z. ((P(y) imp Q(z)) imp (P(x) imp Q(x)))     

GETFOL:: 
Pelletier ' s problem n . 19 - 3 points 

GETFOL:: 
Note that this formula is not in the UE class 

GETFOL:: 
but it can be reduced using "reduce" . . . 

GETFOL:: decide exists x.forall y.forall z.((P(y) imp Q(z) imp (P(x) imp Q(x))))
using nnf, reduce, skolemize, phexp, ptaut;

22   exists x. forall y z. ((P(y) imp Q(z)) imp (P(x) imp Q(x)))     

GETFOL:: 
Pelletier ' s problem n . 20 - 4 points 

GETFOL:: decide (forall x,y.exists z.forall w.((P(x) and Q(y)) imp (R(x) and S(w)))
imp (exists x,y.(P(x) and Q(y)) imp exists z.R(z)))
using nnf, reduce, skolemize, phexp,  ptaut;

23   forall x y. exists z. forall w. ((P(x) and Q(y)) imp (R(x) and S(w))) imp (exists x y. (P(x) and Q(y)) imp exists z. R(z))     

GETFOL:: 
Pelletier ' s problem n . 21 - 5 points 

GETFOL:: assume exists x.(S1 imp P(x));

24   exists x. (S1 imp P(x))     (24)

GETFOL::  
assume exists x.(P(x) imp S1);

25   exists x. (P(x) imp S1)     (25)

GETFOL:: decide exists x.(S1 iff P(x)) by ^2:^1 
using nnf, reduce, skolemize, phexp,  ptaut;

26   exists x. (S1 iff P(x))     (24 25)

GETFOL:: 
Pelletier ' s problem 22 - 3 points 

GETFOL:: decide forall x.(S1 iff P(x)) imp (S1 iff forall x.P(x))
 using nnf, reduce, skolemize, phexp, tautren, ptaut;

27   forall x. (S1 iff P(x)) imp (S1 iff forall x. P(x))     

GETFOL:: 
This is Pelletier ' s problem n . 23 - 4 points 

GETFOL:: decide forall x.(S1 or P(x)) iff (S1 or forall x.P(x))
using nnf, reduce, skolemize, phexp,ptaut;

28   forall x. (S1 or P(x)) iff (S1 or forall x. P(x))     

GETFOL:: 
This is Pelletier ' s problem n . 24 - 6 points 

GETFOL:: assume not exists x.(S(x) and Q(x));

29   not exists x. (S(x) and Q(x))     (29)

GETFOL:: assume forall x.(P(x) imp (Q(x) or R(x)));

30   forall x. (P(x) imp (Q(x) or R(x)))     (30)

GETFOL:: assume (not exists x.P(x)) imp exists x.Q(x);

31   (not exists x. P(x)) imp exists x. Q(x)     (31)

GETFOL:: assume forall x.(Q(x) or R(x) imp S(x));

32   forall x. ((Q(x) or R(x)) imp S(x))     (32)

GETFOL:: decide exists x.(P(x) and R(x)) by ^4:^1 using nnf, reduce, skolemize,
phexp, tautren,  ptaut;

33   exists x. (P(x) and R(x))     (29 30 31 32)

GETFOL:: 
This is Pelletier ' s problem n . 25 - 7 points 

GETFOL:: assume exists x.P(x);

34   exists x. P(x)     (34)

GETFOL:: assume forall x.(S(x) imp (not Q(x) and R(x)));

35   forall x. (S(x) imp ((not Q(x)) and R(x)))     (35)

GETFOL:: assume forall x.(P(x) imp (Q(x) and S(x)));

36   forall x. (P(x) imp (Q(x) and S(x)))     (36)

GETFOL:: assume forall x.(P(x) imp T(x)) or exists x.(P(x) and R(x));

37   forall x. (P(x) imp T(x)) or exists x. (P(x) and R(x))     (37)

GETFOL:: decide  exists  x.(T(x)  and   P(x))  by  ^4:^1  using  nnf,   reduce,
skolemize, phexp, ptaut;

38   exists x. (T(x) and P(x))     (34 35 36 37)

GETFOL:: 
This is Pelletier ' s problem n . 26 - 7 points 

GETFOL:: assume exists x.P(x) iff exists x.Q(x);

39   exists x. P(x) iff exists x. Q(x)     (39)

GETFOL:: assume forall x,y.((P(x) and Q(y)) imp (R(x) iff S(y)));

40   forall x y. ((P(x) and Q(y)) imp (R(x) iff S(y)))     (40)

GETFOL:: decide forall x.(P(x) imp R(x)) iff forall x.(Q(x) imp S(x)) by ^2:^1 using nnf, reduce, skolemize, phexp, ptaut;

41   forall x. (P(x) imp R(x)) iff forall x. (Q(x) imp S(x))     (39 40)

GETFOL:: 
This is Pelletier ' s problem n . 27 - 6 points 

GETFOL:: assume exists x.(P(x) and not Q(x));

42   exists x. (P(x) and (not Q(x)))     (42)

GETFOL:: assume forall x.(P(x) imp R(x));

43   forall x. (P(x) imp R(x))     (43)

GETFOL:: assume forall x.((S(x) and T(x)) imp P(x));

44   forall x. ((S(x) and T(x)) imp P(x))     (44)

GETFOL:: assume exists x.(R(x) and not Q(x)) imp forall x.(T(x) imp not R(x));

45   exists x. (R(x) and (not Q(x))) imp forall x. (T(x) imp (not R(x)))     (45)

GETFOL:: decide   forall    x.(S(x)    imp   not    T(x))    by   ^4:^1   using
nnf,reduce,skolemize,phexp,ptaut;

46   forall x. (S(x) imp (not T(x)))     (42 43 44 45)

GETFOL:: 
Pelletier ' s problem n . 28 - 8 points 

GETFOL:: assume forall x.(P(x) imp forall x.Q(x));

47   forall x. (P(x) imp forall x. Q(x))     (47)

GETFOL:: assume forall x.(Q(x) or R(x)) imp exists x.(Q(x) and S(x));

48   forall x. (Q(x) or R(x)) imp exists x. (Q(x) and S(x))     (48)

GETFOL:: assume exists x.S(x) imp forall x.(T(x) imp U(x));

49   exists x. S(x) imp forall x. (T(x) imp U(x))     (49)

GETFOL:: decide forall x.((P(x) and T(x)) imp U(x)) by ^3:^1 using nnf, reduce,
skolemize, phexp, ptaut;

50   forall x. ((P(x) and T(x)) imp U(x))     (47 48 49)

GETFOL:: 
Pelletier ' s problem n . 29 - 7 points 

GETFOL:: assume exists x.P(x) and exists x.S(x);

51   exists x. P(x) and exists x. S(x)     (51)

GETFOL:: decide (forall x.(P(x) imp R(x)) and forall x.(S(x) imp T(x))) iff forall x,y.((P(x) and S(y)) imp (R(x) and T(y))) by ^1 using nnf, reduce, skolemize, phexp, tautren, ptaut;

52   (forall x. (P(x) imp R(x)) and forall x. (S(x) imp T(x))) iff forall x y. ((P(x) and S(y)) imp (R(x) and T(y)))     (51)

GETFOL:: 
Pelletier ' s problem n . 30 - 6 points 

GETFOL:: assume forall x.((P(x) or Q(x)) imp (not T(x)));

53   forall x. ((P(x) or Q(x)) imp (not T(x)))     (53)

GETFOL:: assume forall x.((Q(x) imp (not S(x))) imp (P(x)  and T(x)));

54   forall x. ((Q(x) imp (not S(x))) imp (P(x) and T(x)))     (54)

GETFOL:: decide exists x.S(x) by ^2:^1 using nnf, reduce, skolemize, phexp, tautren, ptaut;

55   exists x. S(x)     (53 54)

GETFOL:: 
Pelletier ' s problem n . 31 - 5 points 

GETFOL:: assume not (exists x.(P(x) and (R(x) or Q(x))));

56   not exists x. (P(x) and (R(x) or Q(x)))     (56)

GETFOL:: assume exists x.(S(x) and P(x));

57   exists x. (S(x) and P(x))     (57)

GETFOL:: assume forall x.(not Q(x) imp T(x));

58   forall x. ((not Q(x)) imp T(x))     (58)

GETFOL:: decide exists x.(S(x) and T(x)) by ^3:^1 
using nnf, reduce, skolemize, phexp, ptaut;

59   exists x. (S(x) and T(x))     (56 57 58)

GETFOL:: 
Pelletier ' s problem n . 32 - 6 points 

GETFOL:: assume forall x.((P(x) and (R(x) or Q(x))) imp S(x));

60   forall x. ((P(x) and (R(x) or Q(x))) imp S(x))     (60)

GETFOL:: assume forall x.((S(x) and Q(x)) imp T(x));

61   forall x. ((S(x) and Q(x)) imp T(x))     (61)

GETFOL:: assume forall x.(U(x) imp Q(x));

62   forall x. (U(x) imp Q(x))     (62)

GETFOL:: decide forall x.((P(x) and U(x)) imp T(x)) by ^3:^1
 using nnf, reduce, skolemize, phexp, ptaut;

63   forall x. ((P(x) and U(x)) imp T(x))     (60 61 62)

GETFOL:: 
Pelletier ' s problem n . 33 - 4 points 

GETFOL:: decide forall x.(P(a) and (P(x) imp P(b)) imp P(c)) iff
forall x.((not P(a) or (P(x) or P(c))) and (not P(a) or (not P(b) or P(c))))
using nnf, reduce, skolemize, phexp, ptaut;

64   forall x. ((P(a) and (P(x) imp P(b))) imp P(c)) iff forall x. (((not P(a)) or (P(x) or P(c))) and ((not P(a)) or ((not P(b)) or P(c))))     

GETFOL:: 
Pelletier ' s problem n . 35 - 2 points 

GETFOL:: decide exists x.exists y.(F(x,y) imp forall x.forall y.F(x,y)) using
nnf,reduce,skolemize,phexp,ptaut;

65   exists x y. (F(x, y) imp forall x y. F(x, y))     

GETFOL:: 
Pelletier ' s problem n . 39 

GETFOL:: 
Russell ' s paradox - 3 points 

GETFOL:: decide   not   exists  x.forall  y.(F(x,y)   iff  not   F(y,y))  using
nnf,reduce,skolemize,phexp,ptaut;

66   not exists x. forall y. (F(x, y) iff (not F(y, y)))     

GETFOL:: 
This is Pelletier ' s problem n . 48 - 3 points 

GETFOL:: assume a = b or c = d;

67   (a = b) or (c = d)     (67)

GETFOL:: assume a = c or b = d;

68   (a = c) or (b = d)     (68)

GETFOL:: decide a = d or b = c by ^2:^1 using ptauteq;

69   (a = d) or (b = c)     (67 68)

GETFOL:: 
This is Pelletier ' s problem n . 49 - 5 points 

GETFOL:: assume exists x.exists y.forall z.(z = x or z = y);

70   exists x y. forall z. ((z = x) or (z = y))     (70)

GETFOL:: assume P(a) and P(b);

71   P(a) and P(b)     (71)

GETFOL:: assume not (a = b);

72   not (a = b)     (72)

GETFOL:: decide forall x.P(x) by ^3:^1 using nnf,reduce,skolemize,phexp,ptauteq;

73   forall x. P(x)     (70 71 72)

GETFOL:: I am finished fetching decide/pltier.tst

GETFOL:: 	reset;
Resetting the whole GETFOL-system

GETFOL:: 	fetch decide/ptaut.tst;
I am starting to fetch decide/ptaut.tst

GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: RESET;
Resetting the whole GETFOL-system

GETFOL:: NAMECONTEXT INITIAL;
You have named the current context: INITIAL

GETFOL:: MAKECONTEXT PTAUT1;
You have created the empty context: PTAUT1

GETFOL:: SWITCHCONTEXT PTAUT1;
You are now using context: PTAUT1
You are switching to a proof with no name.

GETFOL:: DECLARE SENTCONST P Q;
P has been declared to be a Sentconst
Q has been declared to be a Sentconst

GETFOL:: ASSUME P imp Q;

1   P imp Q     (1)

GETFOL:: ASSUME P;

2   P     (2)

GETFOL:: PTAUT Q BY 1,2;

3   Q     (1 2)

GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: MAKECONTEXT PTAUT11;
You have created the empty context: PTAUT11

GETFOL:: SWITCHCONTEXT PTAUT11;
You are now using context: PTAUT11
You are switching to a proof with no name.

GETFOL:: DECLARE SENTCONST P Q;
P has been declared to be a Sentconst
Q has been declared to be a Sentconst

GETFOL:: ASSUME P;

1   P     (1)

GETFOL:: ASSUME Q;

2   Q     (2)

GETFOL:: PTAUT P imp Q BY 1,2;

3   P imp Q     (1 2)

GETFOL:: PTAUT P BY 1,2;

4   P     (1 2)

GETFOL:: 
GETFOL:: MAKECONTEXT PTAUT2;
You have created the empty context: PTAUT2

GETFOL:: SWITCHCONTEXT PTAUT2;
You are now using context: PTAUT2
You are switching to a proof with no name.

GETFOL:: DECLARE SENTCONST A B C;
A has been declared to be a Sentconst
B has been declared to be a Sentconst
C has been declared to be a Sentconst

GETFOL:: DECLARE SENTCONST P Q;
P has been declared to be a Sentconst
Q has been declared to be a Sentconst

GETFOL:: PTAUT A imp A;

1   A imp A     

GETFOL:: PTAUT A or not A;

2   A or (not A)     

GETFOL:: PTAUT wffif A then TRUE else TRUE;

3   wffif A then TRUE else TRUE     

GETFOL:: PTAUT wffif (wffif A then TRUE else TRUE) then TRUE else A;

4   wffif (wffif A then TRUE else TRUE) then TRUE else A     

GETFOL:: 
GETFOL:: PTAUT A imp ( B imp A );

5   A imp (B imp A)     

GETFOL:: 
GETFOL:: PTAUT ( A imp ( B imp C ) ) imp ( ( A imp B ) imp ( A imp C ) );

6   (A imp (B imp C)) imp ((A imp B) imp (A imp C))     

GETFOL:: 
GETFOL:: PTAUT ( (not B) imp (not A) ) imp ( ( (not B) imp A ) imp B );

7   ((not B) imp (not A)) imp (((not B) imp A) imp B)     

GETFOL:: PTAUT (wffif A then B else C) iff ((A and B) or (not A and C));

8   (wffif A then B else C) iff ((A and B) or ((not A) and C))     

GETFOL:: ASSUME A B C;

9   A     (9)

10   B     (10)

11   C     (11)

GETFOL:: AXIOM AX1 : P;

AX1 : P

GETFOL:: AXIOM AX2 : Q;

AX2 : Q

GETFOL:: PTAUT A and B and ( P or Q ) by 1:^1 AX1 AX2;

12   (A and B) and (P or Q)     (9 10 11)

GETFOL:: PTAUT P or Q by ^1;

13   P or Q     (9 10 11)

GETFOL:: I am finished fetching decide/ptaut.tst

GETFOL:: 	reset;
Resetting the whole GETFOL-system

GETFOL:: 
GETFOL:: 	fetch decide/taut.tst;
I am starting to fetch decide/taut.tst

GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: RESET;
Resetting the whole GETFOL-system

GETFOL:: NAMECONTEXT INITIAL;
You have named the current context: INITIAL

GETFOL:: MAKECONTEXT TAUT1;
You have created the empty context: TAUT1

GETFOL:: SWITCHCONTEXT TAUT1;
You are now using context: TAUT1
You are switching to a proof with no name.

GETFOL:: DECLARE INDVAR X;
UNIVERSAL is a sort
X has been declared to be an Indvar

GETFOL:: DECLARE FUNCONST F G 1;
F has been declared to be a Funconst
G has been declared to be a Funconst

GETFOL:: DECLARE PREDCONST P Q 1;
P has been declared to be a Predconst
Q has been declared to be a Predconst

GETFOL:: ASSUME P(F(X)) imp Q(G(X));

1   P(F(X)) imp Q(G(X))     (1)

GETFOL:: ASSUME P(F(X));

2   P(F(X))     (2)

GETFOL:: TAUT Q(G(X)) BY 1,2;

3   Q(G(X))     (1 2)

GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: MAKECONTEXT TAUT11;
You have created the empty context: TAUT11

GETFOL:: SWITCHCONTEXT TAUT11;
You are now using context: TAUT11
You are switching to a proof with no name.

GETFOL:: DECLARE INDVAR X;
UNIVERSAL is a sort
X has been declared to be an Indvar

GETFOL:: DECLARE FUNCONST F G 1;
F has been declared to be a Funconst
G has been declared to be a Funconst

GETFOL:: DECLARE PREDCONST P Q 1;
P has been declared to be a Predconst
Q has been declared to be a Predconst

GETFOL:: ASSUME P(F(X));

1   P(F(X))     (1)

GETFOL:: ASSUME Q(G(X));

2   Q(G(X))     (2)

GETFOL:: TAUT P(F(X)) imp Q(G(X)) BY 1,2;

3   P(F(X)) imp Q(G(X))     (1 2)

GETFOL:: TAUT P(F(X)) BY 1,2;

4   P(F(X))     (1 2)

GETFOL:: 
GETFOL:: MAKECONTEXT TAUT2;
You have created the empty context: TAUT2

GETFOL:: SWITCHCONTEXT TAUT2;
You are now using context: TAUT2
You are switching to a proof with no name.

GETFOL:: DECLARE SENTCONST A B C;
A has been declared to be a Sentconst
B has been declared to be a Sentconst
C has been declared to be a Sentconst

GETFOL:: DECLARE PREDCONST P1 Q1 R1 1;
P1 has been declared to be a Predconst
Q1 has been declared to be a Predconst
R1 has been declared to be a Predconst

GETFOL:: DECLARE PREDCONST P2 Q2 R2 2;
P2 has been declared to be a Predconst
Q2 has been declared to be a Predconst
R2 has been declared to be a Predconst

GETFOL:: DECLARE INDVAR x y z w;
UNIVERSAL is a sort
x has been declared to be an Indvar
y has been declared to be an Indvar
z has been declared to be an Indvar
w has been declared to be an Indvar

GETFOL:: DECLARE INDCONST a b c;
UNIVERSAL is a sort
a has been declared to be an Indconst
b has been declared to be an Indconst
c has been declared to be an Indconst

GETFOL:: DECLARE FUNCONST f g h 1;
f has been declared to be a Funconst
g has been declared to be a Funconst
h has been declared to be a Funconst

GETFOL:: TAUT A imp A;

1   A imp A     

GETFOL:: TAUT A or not A;

2   A or (not A)     

GETFOL:: TAUT wffif A then TRUE else TRUE;

3   wffif A then TRUE else TRUE     

GETFOL:: TAUT wffif (wffif A then TRUE else TRUE) then TRUE else A;

4   wffif (wffif A then TRUE else TRUE) then TRUE else A     

GETFOL:: 
GETFOL:: TAUT A imp ( B imp A );

5   A imp (B imp A)     

GETFOL:: 
GETFOL:: TAUT ( A imp ( B imp C ) ) imp ( ( A imp B ) imp ( A imp C ) );

6   (A imp (B imp C)) imp ((A imp B) imp (A imp C))     

GETFOL:: 
GETFOL:: TAUT ( (not B) imp (not A) ) imp ( ( (not B) imp A ) imp B );

7   ((not B) imp (not A)) imp (((not B) imp A) imp B)     

GETFOL:: 
GETFOL:: 
GETFOL:: TAUT ( (not (forall x.(P1(x) and Q2(x,a)))) imp (not R1(f(z))) ) imp
     ( (not (forall y.(P1(y) and Q2(y,a))) imp R1(f(z)) ) imp
       (forall z.(P1(z) and Q2(z,a))) );

8   ((not forall x. (P1(x) and Q2(x, a))) imp (not R1(f(z)))) imp (((not forall y. (P1(y) and Q2(y, a))) imp R1(f(z))) imp forall z. (P1(z) and Q2(z, a)))     

GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: TAUT forall x.(P1(x) and exists y.(Q2(x,y) imp Q2(a,b))) imp
     forall x.(P1(x) and exists z.(Q2(x,z) imp Q2(a,b)));

9   forall x. (P1(x) and exists y. (Q2(x, y) imp Q2(a, b))) imp forall x. (P1(x) and exists z. (Q2(x, z) imp Q2(a, b)))     

GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: TAUT (wffif A then B else C) iff ((A and B) or (not A and C));

10   (wffif A then B else C) iff ((A and B) or ((not A) and C))     

GETFOL:: ASSUME A B C;

11   A     (11)

12   B     (12)

13   C     (13)

GETFOL:: AXIOM AX1 : P1(a);

AX1 : P1(a)

GETFOL:: AXIOM AX2 : P1(b);

AX2 : P1(b)

GETFOL:: taut A and B and ( P1(a) or P1(b) ) by 1:^1 AX1 AX2;

14   (A and B) and (P1(a) or P1(b))     (11 12 13)

GETFOL:: taut P1(a) or P1(b) by ^1;

15   P1(a) or P1(b)     (11 12 13)

GETFOL:: I am finished fetching decide/taut.tst

GETFOL:: 	reset;
Resetting the whole GETFOL-system

GETFOL:: 	fetch decide/tauteq.tst;
I am starting to fetch decide/tauteq.tst

GETFOL:: RESET;
Resetting the whole GETFOL-system

GETFOL:: NAMECONTEXT INITIAL;
You have named the current context: INITIAL

GETFOL:: MAKECONTEXT TAUTEQ;
You have created the empty context: TAUTEQ

GETFOL:: SWITCHCONTEXT TAUTEQ;
You are now using context: TAUTEQ
You are switching to a proof with no name.

GETFOL:: DECLARE SENTCONST A B C;
A has been declared to be a Sentconst
B has been declared to be a Sentconst
C has been declared to be a Sentconst

GETFOL:: DECLARE PREDCONST P1 Q1 R1 1;
P1 has been declared to be a Predconst
Q1 has been declared to be a Predconst
R1 has been declared to be a Predconst

GETFOL:: DECLARE PREDCONST P2 Q2 R2 2;
P2 has been declared to be a Predconst
Q2 has been declared to be a Predconst
R2 has been declared to be a Predconst

GETFOL:: DECLARE INDVAR x y z w;
UNIVERSAL is a sort
x has been declared to be an Indvar
y has been declared to be an Indvar
z has been declared to be an Indvar
w has been declared to be an Indvar

GETFOL:: DECLARE INDCONST a b c;
UNIVERSAL is a sort
a has been declared to be an Indconst
b has been declared to be an Indconst
c has been declared to be an Indconst

GETFOL:: DECLARE FUNCONST f g h 1;
f has been declared to be a Funconst
g has been declared to be a Funconst
h has been declared to be a Funconst

GETFOL:: ASSUME x=a a=f(a) g(b)=y y=z z=w f(y)=g(f(x)) g(f(x))=g(c);

1   x = a     (1)

2   a = f(a)     (2)

3   g(b) = y     (3)

4   y = z     (4)

5   z = w     (5)

6   f(y) = g(f(x))     (6)

7   g(f(x)) = g(c)     (7)

GETFOL:: TAUTEQ (P1(x) iff P1(f(a))) and (P2(a,y) iff P2(f(a),w)) and
       (P2(f(y),g(c)) iff P2(g(c),g(f(x)))) and
       g(b)=z and f(a)=a and f(y)=g(c) by ^7:^1;

8   (((((P1(x) iff P1(f(a))) and (P2(a, y) iff P2(f(a), w))) and (P2(f(y), g(c)) iff P2(g(c), g(f(x))))) and (g(b) = z)) and (f(a) = a)) and (f(y) = g(c))     (1 2 3 4 5 6 7)

GETFOL:: TAUTEQ (P1(x) imp P1(f(a))) and (P2(a,y) imp P2(f(a),w)) and
       (P2(f(y),g(c)) imp P2(g(c),g(f(x)))) and
       g(b)=z and f(a)=a and f(y)=g(c) by ^8:^2;

9   (((((P1(x) imp P1(f(a))) and (P2(a, y) imp P2(f(a), w))) and (P2(f(y), g(c)) imp P2(g(c), g(f(x))))) and (g(b) = z)) and (f(a) = a)) and (f(y) = g(c))     (1 2 3 4 5 6 7)

GETFOL:: TAUTEQ ( x=a and a=f(a) and g(b)=y and y=z and z=w and f(y)=g(f(x)) and g(f(x))=g(c)) imp
       ( (P1(x) iff P1(f(a))) and (P2(a,y) iff P2(f(a),w)) and
         (P2(f(y),g(c)) iff P2(g(c),g(f(x)))) and g(b)=z and f(a)=a and f(y)=g(c) );

10   (((((((x = a) and (a = f(a))) and (g(b) = y)) and (y = z)) and (z = w)) and (f(y) = g(f(x)))) and (g(f(x)) = g(c))) imp ((((((P1(x) iff P1(f(a))) and (P2(a, y) iff P2(f(a), w))) and (P2(f(y), g(c)) iff P2(g(c), g(f(x))))) and (g(b) = z)) and (f(a) = a)) and (f(y) = g(c)))     

GETFOL:: TAUTEQ ( x=a and a=f(a) and g(b)=y and y=z and z=w and f(y)=g(f(x)) and g(f(x))=g(c)) imp
       ( (P1(x) iff P1(f(a))) and (P2(a,y) iff P2(f(a),w)) and
         (P2(f(y),g(c)) iff P2(g(c),g(f(x)))) and g(b)=z and f(a)=a and f(y)=g(c) );

11   (((((((x = a) and (a = f(a))) and (g(b) = y)) and (y = z)) and (z = w)) and (f(y) = g(f(x)))) and (g(f(x)) = g(c))) imp ((((((P1(x) iff P1(f(a))) and (P2(a, y) iff P2(f(a), w))) and (P2(f(y), g(c)) iff P2(g(c), g(f(x))))) and (g(b) = z)) and (f(a) = a)) and (f(y) = g(c)))     

GETFOL:: TAUTEQ ( x=y and z=w and y=a and a=f(b) and w=f(z) ) imp
       (f(z)=z and f(b)=y and a=y);

12   (((((x = y) and (z = w)) and (y = a)) and (a = f(b))) and (w = f(z))) imp (((f(z) = z) and (f(b) = y)) and (a = y))     

GETFOL:: TAUTEQ f(g(x)) = f(g(x));

13   f(g(x)) = f(g(x))     

GETFOL:: TAUTEQ x=y imp y=x;

14   (x = y) imp (y = x)     

GETFOL:: TAUTEQ (x=y and y=z) imp z=x;

15   ((x = y) and (y = z)) imp (z = x)     

GETFOL:: TAUTEQ ( x=y and z=w and y=a and a=f(b) and w=f(z) ) imp
       ( P2(x,w) iff P2(f(b),f(z)) );

16   (((((x = y) and (z = w)) and (y = a)) and (a = f(b))) and (w = f(z))) imp (P2(x, w) iff P2(f(b), f(z)))     

GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: TAUTEQ ( x=y and z=w and y=a and a=f(b) and w=f(z) ) imp
       (( P2(x,w) iff P2(f(b),f(z)) ) and (P1(y) iff P1(x)));

17   (((((x = y) and (z = w)) and (y = a)) and (a = f(b))) and (w = f(z))) imp ((P2(x, w) iff P2(f(b), f(z))) and (P1(y) iff P1(x)))     

GETFOL:: TAUTEQ x=y imp (P1(x) iff P1(y));

18   (x = y) imp (P1(x) iff P1(y))     

GETFOL:: 
GETFOL:: 
GETFOL:: MAKECONTEXT PECK\-BUG;
You have created the empty context: PECK-BUG

GETFOL:: SWITCHCONTEXT PECK\-BUG;
You are now using context: PECK-BUG
You are switching to a proof with no name.

GETFOL:: declare predconst All 1;
All has been declared to be a Predconst

GETFOL:: declare funconst colorof 2;
colorof has been declared to be a Funconst

GETFOL:: declare indconst c g s1 s red green;
UNIVERSAL is a sort
c has been declared to be an Indconst
g has been declared to be an Indconst
s1 has been declared to be an Indconst
s has been declared to be an Indconst
red has been declared to be an Indconst
green has been declared to be an Indconst

GETFOL:: assume All(g) and colorof(g,s1)=red;

1   All(g) and (colorof(g, s1) = red)     (1)

GETFOL:: assume colorof(g,s)=c;

2   colorof(g, s) = c     (2)

GETFOL:: assume colorof(g,s1)=c;

3   colorof(g, s1) = c     (3)

GETFOL:: axiom EXTCOLOR2: not red=green;

EXTCOLOR2 : not (red = green)

GETFOL:: tauteq not colorof(g,s)=green by ^3:^1 EXTCOLOR2;

4   not (colorof(g, s) = green)     (1 2 3)

GETFOL:: MAKECONTEXT PB\-EXTENSION;
You have created the empty context: PB-EXTENSION

GETFOL:: SWITCHCONTEXT PB\-EXTENSION;
You are now using context: PB-EXTENSION
You are switching to a proof with no name.

GETFOL:: declare indconst a b;
UNIVERSAL is a sort
a has been declared to be an Indconst
b has been declared to be an Indconst

GETFOL:: declare predconst A B 1;
A has been declared to be a Predconst
B has been declared to be a Predconst

GETFOL:: tauteq  (A(a) and (A(a) imp a=b)) imp A(b);

1   (A(a) and (A(a) imp (a = b))) imp A(b)     

GETFOL:: tauteq  (A(a) and (not A(a) or a=b)) imp A(b);

2   (A(a) and ((not A(a)) or (a = b))) imp A(b)     

GETFOL:: tauteq  ((A(a) and not A(a)) or (A(a) and a=b)) imp A(b);

3   ((A(a) and (not A(a))) or (A(a) and (a = b))) imp A(b)     

GETFOL:: tauteq  (FALSE or (A(a) and a=b)) imp A(b);

4   (FALSE or (A(a) and (a = b))) imp A(b)     

GETFOL:: tauteq  (TRUE and (A(a) and a=b)) imp A(b);

5   (TRUE and (A(a) and (a = b))) imp A(b)     

GETFOL:: tauteq  (A(a) and a=b) imp A(b);

6   (A(a) and (a = b)) imp A(b)     

GETFOL:: tauteq  A(a) imp (a=b imp A(b));

7   A(a) imp ((a = b) imp A(b))     

GETFOL:: tauteq  A(a) imp ((a=b and TRUE) imp (A(b) or FALSE));

8   A(a) imp (((a = b) and TRUE) imp (A(b) or FALSE))     

GETFOL:: I am finished fetching decide/tauteq.tst

GETFOL:: 	reset;
Resetting the whole GETFOL-system

GETFOL:: 
GETFOL:: 	fetch eval/attach.tst;
I am starting to fetch eval/attach.tst

GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: PROBE ALL;

GETFOL:: DECLARE SORT PIPPO;
PIPPO has been declared to be a sort

GETFOL:: DECLARE INDCONST A B C D [PIPPO];
PIPPO is a sort
A has been declared to be an Indconst
B has been declared to be an Indconst
C has been declared to be an Indconst
D has been declared to be an Indconst

GETFOL:: DECLARE FUNCONST AA BB (PIPPO) = PIPPO;
PIPPO is a sort
PIPPO is a sort
AA has been declared to be a Funconst
BB has been declared to be a Funconst

GETFOL:: DECREP PIPPOREP;

GETFOL:: ATTACH A DAR [PIPPOREP] a;
A attached to 'a
A is the preferred name of a

GETFOL:: ATTACH C DAR [PIPPOREP] c;
C attached to 'c
C is the preferred name of c

GETFOL:: DEFLAM ID (ARG) ARG;

GETFOL:: DEFLAM B  (ARG) ARG;

GETFOL:: ATTACH AA TO [PIPPOREP = PIPPOREP] ID;
AA attached to ID

GETFOL:: ATTACH BB TO [PIPPOREP = PIPPOREP] B;
BB attached to B

GETFOL:: I am finished fetching eval/attach.tst

GETFOL:: 	reset;
Resetting the whole GETFOL-system

GETFOL:: 	fetch eval/eval.tst;
I am starting to fetch eval/eval.tst

GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: namecontext one;
You have named the current context: one

GETFOL:: declare sentconst S T R;
S has been declared to be a Sentconst
T has been declared to be a Sentconst
R has been declared to be a Sentconst

GETFOL:: attach S to NIL;
S attached to 'NIL

GETFOL:: attach T to T;
T attached to 'T

GETFOL:: attach R to UNDEF&;
R attached to 'UNDEF&

GETFOL:: eval S and T;
S and T: syntactic simplification fails.
Evaluating S gives FALSE
FALSE: syntactic simplification fails.

1   not (S and T)     

GETFOL:: eval not S;
not S: syntactic simplification fails.
Evaluating S gives FALSE
TRUE: syntactic simplification fails.

2   not S     

GETFOL:: eval S imp T;
S imp T: syntactic simplification fails.
Evaluating S gives FALSE
TRUE: syntactic simplification fails.

3   S imp T     

GETFOL:: eval S iff T;
S iff T: syntactic simplification fails.
Evaluating S gives FALSE
Evaluating T gives TRUE
FALSE: syntactic simplification fails.

4   not (S iff T)     

GETFOL:: eval wffif S then T else R;
wffif S then T else R: syntactic simplification fails.
Evaluating S gives FALSE
Evaluating R doesn' t work
R: syntactic simplification fails.
R: syntactic simplification fails.

5   (wffif S then T else R) iff R     

GETFOL::  
eval S or T;
S or T: syntactic simplification fails.
Evaluating S gives FALSE
Evaluating T gives TRUE
TRUE: syntactic simplification fails.

6   S or T     

GETFOL:: makecontext two;
You have created the empty context: two

GETFOL:: switchcontext two;
You are now using context: two
You are switching to a proof with no name.

GETFOL:: declare sentconst S T R;
S has been declared to be a Sentconst
T has been declared to be a Sentconst
R has been declared to be a Sentconst

GETFOL:: attach S to T;
S attached to 'T

GETFOL:: attach T to T;
T attached to 'T

GETFOL:: attach R to UNDEF&;
R attached to 'UNDEF&

GETFOL:: eval S and T;
S and T: syntactic simplification fails.
Evaluating S gives TRUE
Evaluating T gives TRUE
TRUE: syntactic simplification fails.

1   S and T     

GETFOL:: eval not S;
not S: syntactic simplification fails.
Evaluating S gives TRUE
FALSE: syntactic simplification fails.

2   not (not S)     

GETFOL:: eval S imp T;
S imp T: syntactic simplification fails.
Evaluating S gives TRUE
Evaluating T gives TRUE
TRUE: syntactic simplification fails.

3   S imp T     

GETFOL:: eval S iff T;
S iff T: syntactic simplification fails.
Evaluating S gives TRUE
Evaluating T gives TRUE
TRUE: syntactic simplification fails.

4   S iff T     

GETFOL:: eval wffif S then T else R;
wffif S then T else R: syntactic simplification fails.
Evaluating S gives TRUE
Evaluating T gives TRUE
TRUE: syntactic simplification fails.

5   wffif S then T else R     

GETFOL::  
eval S or T;
S or T: syntactic simplification fails.
Evaluating S gives TRUE
TRUE: syntactic simplification fails.

6   S or T     

GETFOL:: makecontext three;
You have created the empty context: three

GETFOL:: switchcontext three;
You are now using context: three
You are switching to a proof with no name.

GETFOL:: declare sentconst S T R;
S has been declared to be a Sentconst
T has been declared to be a Sentconst
R has been declared to be a Sentconst

GETFOL:: attach S to T;
S attached to 'T

GETFOL:: attach T to NIL;
T attached to 'NIL

GETFOL:: attach R to UNDEF&;
R attached to 'UNDEF&

GETFOL:: eval S and T;
S and T: syntactic simplification fails.
Evaluating S gives TRUE
Evaluating T gives FALSE
FALSE: syntactic simplification fails.

1   not (S and T)     

GETFOL:: eval not S;
not S: syntactic simplification fails.
Evaluating S gives TRUE
FALSE: syntactic simplification fails.

2   not (not S)     

GETFOL:: eval S imp T;
S imp T: syntactic simplification fails.
Evaluating S gives TRUE
Evaluating T gives FALSE
FALSE: syntactic simplification fails.

3   not (S imp T)     

GETFOL:: eval S iff T;
S iff T: syntactic simplification fails.
Evaluating S gives TRUE
Evaluating T gives FALSE
FALSE: syntactic simplification fails.

4   not (S iff T)     

GETFOL:: eval wffif S then T else R;
wffif S then T else R: syntactic simplification fails.
Evaluating S gives TRUE
Evaluating T gives FALSE
FALSE: syntactic simplification fails.

5   not (wffif S then T else R)     

GETFOL::  
eval S or T;
S or T: syntactic simplification fails.
Evaluating S gives TRUE
TRUE: syntactic simplification fails.

6   S or T     

GETFOL:: makecontext four;
You have created the empty context: four

GETFOL:: switchcontext four;
You are now using context: four
You are switching to a proof with no name.

GETFOL:: declare sentconst S T R;
S has been declared to be a Sentconst
T has been declared to be a Sentconst
R has been declared to be a Sentconst

GETFOL:: attach S to NIL;
S attached to 'NIL

GETFOL:: attach T to NIL;
T attached to 'NIL

GETFOL:: attach R to UNDEF&;
R attached to 'UNDEF&

GETFOL:: eval S and T;
S and T: syntactic simplification fails.
Evaluating S gives FALSE
FALSE: syntactic simplification fails.

1   not (S and T)     

GETFOL:: eval not S;
not S: syntactic simplification fails.
Evaluating S gives FALSE
TRUE: syntactic simplification fails.

2   not S     

GETFOL:: eval S imp T;
S imp T: syntactic simplification fails.
Evaluating S gives FALSE
TRUE: syntactic simplification fails.

3   S imp T     

GETFOL:: eval S iff T;
S iff T: syntactic simplification fails.
Evaluating S gives FALSE
Evaluating T gives FALSE
TRUE: syntactic simplification fails.

4   S iff T     

GETFOL:: eval wffif S then T else R;
wffif S then T else R: syntactic simplification fails.
Evaluating S gives FALSE
Evaluating R doesn' t work
R: syntactic simplification fails.
R: syntactic simplification fails.

5   (wffif S then T else R) iff R     

GETFOL::  
eval S or T;
S or T: syntactic simplification fails.
Evaluating S gives FALSE
Evaluating T gives FALSE
FALSE: syntactic simplification fails.

6   not (S or T)     

GETFOL:: makecontext five;
You have created the empty context: five

GETFOL:: switchcontext five;
You are now using context: five
You are switching to a proof with no name.

GETFOL:: declare indconst a b c;
UNIVERSAL is a sort
a has been declared to be an Indconst
b has been declared to be an Indconst
c has been declared to be an Indconst

GETFOL:: declare predconst p q 3;
p has been declared to be a Predconst
q has been declared to be a Predconst

GETFOL:: declare indvar x y;
UNIVERSAL is a sort
x has been declared to be an Indvar
y has been declared to be an Indvar

GETFOL:: declare indpar par;
UNIVERSAL is a sort
par has been declared to be an Indpar

GETFOL:: declare predpar P 1;
P has been declared to be a Predpar

GETFOL:: declare sentpar ST;
ST has been declared to be a Sentpar

GETFOL:: declare funconst f 2;
f has been declared to be a Funconst

GETFOL:: declare funpar F 1;
F has been declared to be a Funpar

GETFOL:: DECREP rep1, rep2, rep3;

GETFOL:: attach a to [rep1]a;
a attached to 'a

GETFOL:: attach b to [rep2]b;
b attached to 'b

GETFOL:: attach c to [rep3]c;
c attached to 'c

GETFOL:: attach p to [rep1,rep2,rep3]p;
p attached to p

GETFOL:: deflam p(x y z)T;

GETFOL:: attach q to [rep1,rep2,rep3]q;
q attached to q

GETFOL:: deflam q(x y z)NIL;

GETFOL:: eval p(a b c);
Evaluating a gives a
Evaluating b gives b
Evaluating c gives c
Evaluating p(a, b, c) gives TRUE

1   p(a, b, c)     

GETFOL:: eval q(a b c);
Evaluating a gives a
Evaluating b gives b
Evaluating c gives c
Evaluating q(a, b, c) gives FALSE

2   not q(a, b, c)     

GETFOL:: eval forall x y.((P(f(x y)) imp ST) and (p(F(par),b, c) and q(a b c)));
forall x y. ((P(f(x, y)) imp ST) and (p(F(par), b, c) and q(a, b, c))): syntactic simplification fails.
forall y. ((P(f(x, y)) imp ST) and (p(F(par), b, c) and q(a, b, c))): syntactic simplification fails.
(P(f(x, y)) imp ST) and (p(F(par), b, c) and q(a, b, c)): syntactic simplification fails.
P(f(x, y)) imp ST: syntactic simplification fails.
P(f(x, y)): syntactic simplification fails.
f has no interpretation.
f(x, y): syntactic simplification fails.
Evaluating x doesn' t work
x: syntactic simplification fails.
Evaluating y doesn' t work
y: syntactic simplification fails.
Evaluating f(x, y) doesn' t work
f(x, y): syntactic simplification fails.
Evaluating P(f(x, y)) doesn' t work
P(f(x, y)): syntactic simplification fails.
Evaluating ST doesn' t work
ST: syntactic simplification fails.
p(F(par), b, c) and q(a, b, c): syntactic simplification fails.
F has no interpretation.
F(par): syntactic simplification fails.
Evaluating par doesn' t work
par: syntactic simplification fails.
Evaluating F(par) doesn' t work
F(par): syntactic simplification fails.
Evaluating b gives b
Evaluating c gives c
Evaluating p(F(par), b, c) doesn' t work
p(F(par), b, c): syntactic simplification fails.
Evaluating a gives a
Evaluating b gives b
Evaluating c gives c
Evaluating q(a, b, c) gives FALSE
FALSE: syntactic simplification fails.
FALSE: syntactic simplification fails.
FALSE: syntactic simplification fails.
FALSE: syntactic simplification fails.

3   not forall x y. ((P(f(x, y)) imp ST) and (p(F(par), b, c) and q(a, b, c)))     

GETFOL:: eval exists x y.((P(f(x y)) imp ST) and (p(F(par),b, c) and q(a b c)));
exists x y. ((P(f(x, y)) imp ST) and (p(F(par), b, c) and q(a, b, c))): syntactic simplification fails.
exists y. ((P(f(x, y)) imp ST) and (p(F(par), b, c) and q(a, b, c))): syntactic simplification fails.
(P(f(x, y)) imp ST) and (p(F(par), b, c) and q(a, b, c)): syntactic simplification fails.
P(f(x, y)) imp ST: syntactic simplification fails.
P(f(x, y)): syntactic simplification fails.
f has no interpretation.
f(x, y): syntactic simplification fails.
Evaluating x doesn' t work
x: syntactic simplification fails.
Evaluating y doesn' t work
y: syntactic simplification fails.
Evaluating f(x, y) doesn' t work
f(x, y): syntactic simplification fails.
Evaluating P(f(x, y)) doesn' t work
P(f(x, y)): syntactic simplification fails.
Evaluating ST doesn' t work
ST: syntactic simplification fails.
p(F(par), b, c) and q(a, b, c): syntactic simplification fails.
F has no interpretation.
F(par): syntactic simplification fails.
Evaluating par doesn' t work
par: syntactic simplification fails.
Evaluating F(par) doesn' t work
F(par): syntactic simplification fails.
Evaluating b gives b
Evaluating c gives c
Evaluating p(F(par), b, c) doesn' t work
p(F(par), b, c): syntactic simplification fails.
Evaluating a gives a
Evaluating b gives b
Evaluating c gives c
Evaluating q(a, b, c) gives FALSE
FALSE: syntactic simplification fails.
FALSE: syntactic simplification fails.
FALSE: syntactic simplification fails.
FALSE: syntactic simplification fails.

4   not exists x y. ((P(f(x, y)) imp ST) and (p(F(par), b, c) and q(a, b, c)))     

GETFOL:: I am finished fetching eval/eval.tst

GETFOL:: 	reset;
Resetting the whole GETFOL-system

GETFOL:: 	fetch eval/exteval.tst;
I am starting to fetch eval/exteval.tst

GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: declare sort s;
s has been declared to be a sort

GETFOL:: declare indconst a b c d e;
UNIVERSAL is a sort
a has been declared to be an Indconst
b has been declared to be an Indconst
c has been declared to be an Indconst
d has been declared to be an Indconst
e has been declared to be an Indconst

GETFOL:: attach a to a;
a attached to 'a

GETFOL:: attach b to b;
b attached to 'b

GETFOL:: attach c to c;
c attached to 'c

GETFOL:: attach d to d;
d attached to 'd

GETFOL:: attach e to e;
e attached to 'e

GETFOL:: extension s by {a b c d e};

Now the extension of s is fixed to be : a b c d e 
GETFOL:: declare indvar sort x [s];
s is a sort
sort has been declared to be an Indvar
x has been declared to be an Indvar

GETFOL:: declare predconst p 1;
p has been declared to be a Predconst

GETFOL:: DEFLAM p(x) (IF (EQ x (QUOTE a)) TRUE FALSE);

GETFOL:: attach p to p;
p attached to p

GETFOL:: eval exists x.p(x);
exists x. p(x): syntactic simplification fails.
Evaluating a gives a
Evaluating p(a) gives TRUE
TRUE: syntactic simplification fails.

1   exists x. p(x)     

GETFOL:: eval forall x.p(x);
forall x. p(x): syntactic simplification fails.
Evaluating a gives a
Evaluating p(a) gives TRUE
Evaluating b gives b
Evaluating p(b) gives FALSE
FALSE: syntactic simplification fails.

2   not forall x. p(x)     

GETFOL:: declare predconst q 1;
q has been declared to be a Predconst

GETFOL:: DEFLAM q(x) 
(IF (MEMBER x (LIST (QUOTE a)(QUOTE b)(QUOTE c) (QUOTE d)(QUOTE e))) TRUE 
 FALSE);

GETFOL:: attach q to q;
q attached to q

GETFOL:: eval exists x.q(x);
exists x. q(x): syntactic simplification fails.
Evaluating a gives a
Evaluating q(a) gives TRUE
TRUE: syntactic simplification fails.

3   exists x. q(x)     

GETFOL:: eval forall x.q(x);
forall x. q(x): syntactic simplification fails.
Evaluating a gives a
Evaluating q(a) gives TRUE
Evaluating b gives b
Evaluating q(b) gives TRUE
Evaluating c gives c
Evaluating q(c) gives TRUE
Evaluating d gives d
Evaluating q(d) gives TRUE
Evaluating e gives e
Evaluating q(e) gives TRUE
TRUE: syntactic simplification fails.

4   forall x. q(x)     

GETFOL:: 								
declare predconst r 1;
r has been declared to be a Predconst

GETFOL:: DEFLAM r(x) 
(IF (MEMBER x (LIST (QUOTE a)(QUOTE b))) TRUE
 (IF (MEMBER x (LIST (QUOTE c) (QUOTE d)(QUOTE e))) FALSE 
  %VALUE\-UNDEF%));

GETFOL:: attach r to r;
r attached to r

GETFOL:: eval exists x.r(x);
exists x. r(x): syntactic simplification fails.
Evaluating a gives a
Evaluating r(a) gives TRUE
TRUE: syntactic simplification fails.

5   exists x. r(x)     

GETFOL:: eval forall x.r(x);
forall x. r(x): syntactic simplification fails.
Evaluating a gives a
Evaluating r(a) gives TRUE
Evaluating b gives b
Evaluating r(b) gives TRUE
Evaluating c gives c
Evaluating r(c) gives FALSE
FALSE: syntactic simplification fails.

6   not forall x. r(x)     

GETFOL:: declare predconst t 1;
t has been declared to be a Predconst

GETFOL:: DEFLAM t(x) 
(IF (MEMBER x (LIST (QUOTE a)(QUOTE b))) %VALUE\-UNDEF%
 (IF (MEMBER x (LIST (QUOTE c) (QUOTE d)(QUOTE e))) FALSE 
  %VALUE\-UNDEF%));

GETFOL:: attach t to t;
t attached to t

GETFOL:: eval exists x.t(x);
exists x. t(x): syntactic simplification fails.
Evaluating a gives a
Evaluating t(a) doesn' t work
t(a): syntactic simplification fails.
Evaluating b gives b
Evaluating t(b) doesn' t work
t(b): syntactic simplification fails.
Evaluating c gives c
Evaluating t(c) gives FALSE
Evaluating d gives d
Evaluating t(d) gives FALSE
Evaluating e gives e
Evaluating t(e) gives FALSE
Evaluating x doesn' t work
x: syntactic simplification fails.
Evaluating t(x) doesn' t work
t(x): syntactic simplification fails.
exists x. t(x): No simplification is possible

GETFOL:: eval forall x.t(x);
forall x. t(x): syntactic simplification fails.
Evaluating a gives a
Evaluating t(a) doesn' t work
t(a): syntactic simplification fails.
Evaluating b gives b
Evaluating t(b) doesn' t work
t(b): syntactic simplification fails.
Evaluating c gives c
Evaluating t(c) gives FALSE
FALSE: syntactic simplification fails.

7   not forall x. t(x)     

GETFOL:: declare predconst u 1;
u has been declared to be a Predconst

GETFOL:: DEFLAM u(x) 
(IF (MEMBER x (LIST (QUOTE a)(QUOTE b))) FALSE
  %VALUE\-UNDEF%);

GETFOL:: attach u to u;
u attached to u

GETFOL:: eval exists x.u(x);
exists x. u(x): syntactic simplification fails.
Evaluating a gives a
Evaluating u(a) gives FALSE
Evaluating b gives b
Evaluating u(b) gives FALSE
Evaluating c gives c
Evaluating u(c) doesn' t work
u(c): syntactic simplification fails.
Evaluating d gives d
Evaluating u(d) doesn' t work
u(d): syntactic simplification fails.
Evaluating e gives e
Evaluating u(e) doesn' t work
u(e): syntactic simplification fails.
Evaluating x doesn' t work
x: syntactic simplification fails.
Evaluating u(x) doesn' t work
u(x): syntactic simplification fails.
exists x. u(x): No simplification is possible

GETFOL:: eval forall x.u(x);
forall x. u(x): syntactic simplification fails.
Evaluating a gives a
Evaluating u(a) gives FALSE
FALSE: syntactic simplification fails.

8   not forall x. u(x)     

GETFOL:: declare predconst l 1;
l has been declared to be a Predconst

GETFOL:: DEFLAM l(x) 
(IF (MEMBER x (LIST (QUOTE a)(QUOTE b)(QUOTE c) (QUOTE d)(QUOTE e))) FALSE
 FALSE);

GETFOL:: attach l to l;
l attached to l

GETFOL:: eval exists x.l(x);
exists x. l(x): syntactic simplification fails.
Evaluating a gives a
Evaluating l(a) gives FALSE
Evaluating b gives b
Evaluating l(b) gives FALSE
Evaluating c gives c
Evaluating l(c) gives FALSE
Evaluating d gives d
Evaluating l(d) gives FALSE
Evaluating e gives e
Evaluating l(e) gives FALSE
FALSE: syntactic simplification fails.

9   not exists x. l(x)     

GETFOL:: eval forall x.l(x);
forall x. l(x): syntactic simplification fails.
Evaluating a gives a
Evaluating l(a) gives FALSE
FALSE: syntactic simplification fails.

10   not forall x. l(x)     

GETFOL:: I am finished fetching eval/exteval.tst

GETFOL:: 	reset;
Resetting the whole GETFOL-system

GETFOL:: 	fetch eval/extsimpl.tst;
I am starting to fetch eval/extsimpl.tst

GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: declare sort s;
s has been declared to be a sort

GETFOL:: declare indconst a b c d e;
UNIVERSAL is a sort
a has been declared to be an Indconst
b has been declared to be an Indconst
c has been declared to be an Indconst
d has been declared to be an Indconst
e has been declared to be an Indconst

GETFOL:: attach a to a;
a attached to 'a

GETFOL:: attach b to b;
b attached to 'b

GETFOL:: attach c to c;
c attached to 'c

GETFOL:: attach d to d;
d attached to 'd

GETFOL:: attach e to e;
e attached to 'e

GETFOL:: extension s by {a b c d e};

Now the extension of s is fixed to be : a b c d e 
GETFOL:: declare predconst p 1;
p has been declared to be a Predconst

GETFOL:: DEFLAM p(x) (IF (EQ x (QUOTE a)) TRUE FALSE);

GETFOL:: attach p to p;
p attached to p

GETFOL:: declare indvar sort x [s];
s is a sort
sort has been declared to be an Indvar
x has been declared to be an Indvar

GETFOL:: simplify exists x.p(x);

1   exists x. p(x)     

GETFOL:: simplify forall x.p(x);

2   not forall x. p(x)     

GETFOL:: declare predconst q 1;
q has been declared to be a Predconst

GETFOL:: DEFLAM q(x) 
(IF (MEMBER x (LIST (QUOTE a)(QUOTE b)(QUOTE c) (QUOTE d)(QUOTE e))) TRUE 
 FALSE);

GETFOL:: attach q to q;
q attached to q

GETFOL:: simplify exists x.q(x);

3   exists x. q(x)     

GETFOL:: simplify forall x.q(x);

4   forall x. q(x)     

GETFOL:: 								
declare predconst r 1;
r has been declared to be a Predconst

GETFOL:: DEFLAM r(x) 
(IF (MEMBER x (LIST (QUOTE a)(QUOTE b))) TRUE
 (IF (MEMBER x (LIST (QUOTE c) (QUOTE d)(QUOTE e))) FALSE 
  %VALUE\-UNDEF%));

GETFOL:: attach r to r;
r attached to r

GETFOL:: simplify exists x.r(x);

5   exists x. r(x)     

GETFOL:: simplify forall x.r(x);

6   not forall x. r(x)     

GETFOL:: declare predconst t 1;
t has been declared to be a Predconst

GETFOL:: DEFLAM t(x) 
(IF (MEMBER x (LIST (QUOTE a)(QUOTE b))) %VALUE\-UNDEF%
 (IF (MEMBER x (LIST (QUOTE c) (QUOTE d)(QUOTE e))) FALSE 
  %VALUE\-UNDEF%));

GETFOL:: attach t to t;
t attached to t

GETFOL:: simplify exists x.t(x);
exists x. t(x) : No simplification is possible.

GETFOL:: simplify forall x.t(x);

7   not forall x. t(x)     

GETFOL:: declare predconst u 1;
u has been declared to be a Predconst

GETFOL:: DEFLAM u(x) 
(IF (MEMBER x (LIST (QUOTE a)(QUOTE b))) FALSE
  %VALUE\-UNDEF%);

GETFOL:: attach u to u;
u attached to u

GETFOL:: simplify exists x.u(x);
exists x. u(x) : No simplification is possible.

GETFOL:: simplify forall x.u(x);

8   not forall x. u(x)     

GETFOL:: declare predconst l 1;
l has been declared to be a Predconst

GETFOL:: DEFLAM l(x) 
(IF (MEMBER x (LIST (QUOTE a)(QUOTE b)(QUOTE c) (QUOTE d)(QUOTE e))) FALSE
 FALSE);

GETFOL:: attach l to l;
l attached to l

GETFOL:: simplify exists x.l(x);

9   not exists x. l(x)     

GETFOL:: simplify forall x.l(x);

10   not forall x. l(x)     

GETFOL:: I am finished fetching eval/extsimpl.tst

GETFOL:: 	reset;
Resetting the whole GETFOL-system

GETFOL:: 	fetch eval/grid.tst;
I am starting to fetch eval/grid.tst

GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: DECLARE SORT GRID;
GRID has been declared to be a sort

GETFOL:: DECLARE SORT COLOR, SQUARE;
COLOR has been declared to be a sort
SQUARE has been declared to be a sort

GETFOL:: DECLARE PREDCONST alldiffcol 1;
alldiffcol has been declared to be a Predconst

GETFOL:: DECLARE PREDCONST allsuccdiffcol 1;
allsuccdiffcol has been declared to be a Predconst

GETFOL:: DECLARE FUNCONST square11(GRID)=SQUARE;
SQUARE is a sort
GRID is a sort
square11 has been declared to be a Funconst

GETFOL:: DECLARE FUNCONST square12(GRID)=SQUARE;
SQUARE is a sort
GRID is a sort
square12 has been declared to be a Funconst

GETFOL:: DECLARE FUNCONST square21(GRID)=SQUARE;
SQUARE is a sort
GRID is a sort
square21 has been declared to be a Funconst

GETFOL:: DECLARE FUNCONST square22(GRID)=SQUARE;
SQUARE is a sort
GRID is a sort
square22 has been declared to be a Funconst

GETFOL:: DECLARE FUNCONST succ(SQUARE)=SQUARE;
SQUARE is a sort
SQUARE is a sort
succ has been declared to be a Funconst

GETFOL:: DECLARE FUNCONST colof(SQUARE)=COLOR;
COLOR is a sort
SQUARE is a sort
colof has been declared to be a Funconst

GETFOL:: DECLARE INDCONST red, green, yellow, blue [COLOR];
COLOR is a sort
red has been declared to be an Indconst
green has been declared to be an Indconst
yellow has been declared to be an Indconst
blue has been declared to be an Indconst

GETFOL:: DECLARE INDCONST mygrid [GRID];
GRID is a sort
mygrid has been declared to be an Indconst

GETFOL:: DECLARE INDVAR grid[GRID];
GRID is a sort
grid has been declared to be an Indvar

GETFOL:: AXIOM SQ_SUCC1:forall grid.succ(square11(grid))=square12(grid);

SQ_SUCC1 : forall grid. (succ(square11(grid)) = square12(grid))

GETFOL:: AXIOM SQ_SUCC2:forall grid.succ(square12(grid))=square22(grid);

SQ_SUCC2 : forall grid. (succ(square12(grid)) = square22(grid))

GETFOL:: AXIOM SQ_SUCC3:forall grid.succ(square22(grid))=square21(grid);

SQ_SUCC3 : forall grid. (succ(square22(grid)) = square21(grid))

GETFOL:: AXIOM SQ_SUCC4:forall grid.succ(square21(grid))=square11(grid);

SQ_SUCC4 : forall grid. (succ(square21(grid)) = square11(grid))

GETFOL:: AXIOM ALLDIFFCOL:
forall grid.(
alldiffcol(grid) iff (
not(colof(square11(grid))=colof(square12(grid))) and
not(colof(square11(grid))=colof(square21(grid))) and
not(colof(square11(grid))=colof(square22(grid))) and
not(colof(square12(grid))=colof(square21(grid))) and
not(colof(square12(grid))=colof(square22(grid))) and
not(colof(square21(grid))=colof(square22(grid)))));

ALLDIFFCOL : forall grid. (alldiffcol(grid) iff ((((((not (colof(square11(grid)) = colof(square12(grid)))) and (not (colof(square11(grid)) = colof(square21(grid))))) and (not (colof(square11(grid)) = colof(square22(grid))))) and (not (colof(square12(grid)) = colof(square21(grid))))) and (not (colof(square12(grid)) = colof(square22(grid))))) and (not (colof(square21(grid)) = colof(square22(grid))))))

GETFOL::  
AXIOM ALLSUCCDIFF:
forall grid.(
allsuccdiffcol(grid) iff
(not(colof(square11(grid))=colof(succ(square11(grid)))) and
not(colof(square12(grid))=colof(succ(square12(grid)))) and
not(colof(square21(grid))=colof(succ(square21(grid)))) and
not(colof(square22(grid))=colof(succ(square22(grid))))) );

ALLSUCCDIFF : forall grid. (allsuccdiffcol(grid) iff ((((not (colof(square11(grid)) = colof(succ(square11(grid))))) and (not (colof(square12(grid)) = colof(succ(square12(grid)))))) and (not (colof(square21(grid)) = colof(succ(square21(grid)))))) and (not (colof(square22(grid)) = colof(succ(square22(grid)))))))

GETFOL:: AXIOM COL_MYGRID1:colof(square11(mygrid))=red;

COL_MYGRID1 : colof(square11(mygrid)) = red

GETFOL:: AXIOM COL_MYGRID2:colof(square12(mygrid))=blue;

COL_MYGRID2 : colof(square12(mygrid)) = blue

GETFOL:: AXIOM COL_MYGRID3:colof(square21(mygrid))=green;

COL_MYGRID3 : colof(square21(mygrid)) = green

GETFOL:: AXIOM COL_MYGRID4:colof(square22(mygrid))=red;

COL_MYGRID4 : colof(square22(mygrid)) = red

GETFOL:: DECREP COLORREP;

GETFOL:: ATTACH red   DAR [COLORREP]red;
red attached to 'red
red is the preferred name of red

GETFOL:: ATTACH green DAR [COLORREP]green;
green attached to 'green
green is the preferred name of green

GETFOL:: ATTACH yellow DAR [COLORREP]yellow;
yellow attached to 'yellow
yellow is the preferred name of yellow

GETFOL:: ATTACH blue   DAR [COLORREP]blue;
blue attached to 'blue
blue is the preferred name of blue

GETFOL:: SETBASICSIMP mysimpset at FACTS 
{COL_MYGRID1,COL_MYGRID2,COL_MYGRID3,COL_MYGRID4,
ALLDIFFCOL,ALLSUCCDIFF,SQ_SUCC1,SQ_SUCC2,
SQ_SUCC3,SQ_SUCC4};

GETFOL:: SETCOMPSIMP mysimpset1 at mysimpset uni LPROPTREE;

GETFOL::  
eval allsuccdiffcol(mygrid) by mysimpset1;
allsuccdiffcol has no interpretation.
Syntactic simplification of allsuccdiffcol(mygrid) gives (((not (colof(square11(mygrid)) = colof(succ(square11(mygrid))))) and (not (colof(square12(mygrid)) = colof(succ(square12(mygrid)))))) and (not (colof(square21(mygrid)) = colof(succ(square21(mygrid)))))) and (not (colof(square22(mygrid)) = colof(succ(square22(mygrid)))))
(((not (colof(square11(mygrid)) = colof(succ(square11(mygrid))))) and (not (colof(square12(mygrid)) = colof(succ(square12(mygrid)))))) and (not (colof(square21(mygrid)) = colof(succ(square21(mygrid)))))) and (not (colof(square22(mygrid)) = colof(succ(square22(mygrid))))): syntactic simplification fails.
((not (colof(square11(mygrid)) = colof(succ(square11(mygrid))))) and (not (colof(square12(mygrid)) = colof(succ(square12(mygrid)))))) and (not (colof(square21(mygrid)) = colof(succ(square21(mygrid))))): syntactic simplification fails.
(not (colof(square11(mygrid)) = colof(succ(square11(mygrid))))) and (not (colof(square12(mygrid)) = colof(succ(square12(mygrid))))): syntactic simplification fails.
not (colof(square11(mygrid)) = colof(succ(square11(mygrid)))): syntactic simplification fails.
colof has no interpretation.
Syntactic simplification of colof(square11(mygrid)) gives red
Evaluating red gives red
Evaluating colof(square11(mygrid)) gives red
colof has no interpretation.
colof(succ(square11(mygrid))): syntactic simplification fails.
succ has no interpretation.
Syntactic simplification of succ(square11(mygrid)) gives square12(mygrid)
square12 has no interpretation.
square12(mygrid): syntactic simplification fails.
Evaluating mygrid doesn' t work
mygrid: syntactic simplification fails.
Evaluating square12(mygrid) doesn' t work
square12(mygrid): syntactic simplification fails.
Evaluating succ(square11(mygrid)) doesn' t work
square12(mygrid): syntactic simplification fails.
Evaluating colof(succ(square11(mygrid))) doesn' t work
Syntactic simplification of colof(square12(mygrid)) gives blue
Evaluating blue gives blue
Evaluating colof(square11(mygrid)) = colof(succ(square11(mygrid))) gives FALSE
TRUE: syntactic simplification fails.
not (colof(square12(mygrid)) = colof(succ(square12(mygrid)))): syntactic simplification fails.
colof has no interpretation.
Syntactic simplification of colof(square12(mygrid)) gives blue
Evaluating blue gives blue
Evaluating colof(square12(mygrid)) gives blue
colof has no interpretation.
colof(succ(square12(mygrid))): syntactic simplification fails.
succ has no interpretation.
Syntactic simplification of succ(square12(mygrid)) gives square22(mygrid)
square22 has no interpretation.
square22(mygrid): syntactic simplification fails.
Evaluating mygrid doesn' t work
mygrid: syntactic simplification fails.
Evaluating square22(mygrid) doesn' t work
square22(mygrid): syntactic simplification fails.
Evaluating succ(square12(mygrid)) doesn' t work
square22(mygrid): syntactic simplification fails.
Evaluating colof(succ(square12(mygrid))) doesn' t work
Syntactic simplification of colof(square22(mygrid)) gives red
Evaluating red gives red
Evaluating colof(square12(mygrid)) = colof(succ(square12(mygrid))) gives FALSE
TRUE: syntactic simplification fails.
TRUE: syntactic simplification fails.
not (colof(square21(mygrid)) = colof(succ(square21(mygrid)))): syntactic simplification fails.
colof has no interpretation.
Syntactic simplification of colof(square21(mygrid)) gives green
Evaluating green gives green
Evaluating colof(square21(mygrid)) gives green
colof has no interpretation.
colof(succ(square21(mygrid))): syntactic simplification fails.
succ has no interpretation.
Syntactic simplification of succ(square21(mygrid)) gives square11(mygrid)
square11 has no interpretation.
square11(mygrid): syntactic simplification fails.
Evaluating mygrid doesn' t work
mygrid: syntactic simplification fails.
Evaluating square11(mygrid) doesn' t work
square11(mygrid): syntactic simplification fails.
Evaluating succ(square21(mygrid)) doesn' t work
square11(mygrid): syntactic simplification fails.
Evaluating colof(succ(square21(mygrid))) doesn' t work
Syntactic simplification of colof(square11(mygrid)) gives red
Evaluating red gives red
Evaluating colof(square21(mygrid)) = colof(succ(square21(mygrid))) gives FALSE
TRUE: syntactic simplification fails.
TRUE: syntactic simplification fails.
not (colof(square22(mygrid)) = colof(succ(square22(mygrid)))): syntactic simplification fails.
colof has no interpretation.
Syntactic simplification of colof(square22(mygrid)) gives red
Evaluating red gives red
Evaluating colof(square22(mygrid)) gives red
colof has no interpretation.
colof(succ(square22(mygrid))): syntactic simplification fails.
succ has no interpretation.
Syntactic simplification of succ(square22(mygrid)) gives square21(mygrid)
square21 has no interpretation.
square21(mygrid): syntactic simplification fails.
Evaluating mygrid doesn' t work
mygrid: syntactic simplification fails.
Evaluating square21(mygrid) doesn' t work
square21(mygrid): syntactic simplification fails.
Evaluating succ(square22(mygrid)) doesn' t work
square21(mygrid): syntactic simplification fails.
Evaluating colof(succ(square22(mygrid))) doesn' t work
Syntactic simplification of colof(square21(mygrid)) gives green
Evaluating green gives green
Evaluating colof(square22(mygrid)) = colof(succ(square22(mygrid))) gives FALSE
TRUE: syntactic simplification fails.
TRUE: syntactic simplification fails.
Evaluating allsuccdiffcol(mygrid) gives TRUE

1   allsuccdiffcol(mygrid)     

GETFOL:: eval alldiffcol(mygrid) by mysimpset1;
alldiffcol has no interpretation.
Syntactic simplification of alldiffcol(mygrid) gives (((((not (colof(square11(mygrid)) = colof(square12(mygrid)))) and (not (colof(square11(mygrid)) = colof(square21(mygrid))))) and (not (colof(square11(mygrid)) = colof(square22(mygrid))))) and (not (colof(square12(mygrid)) = colof(square21(mygrid))))) and (not (colof(square12(mygrid)) = colof(square22(mygrid))))) and (not (colof(square21(mygrid)) = colof(square22(mygrid))))
(((((not (colof(square11(mygrid)) = colof(square12(mygrid)))) and (not (colof(square11(mygrid)) = colof(square21(mygrid))))) and (not (colof(square11(mygrid)) = colof(square22(mygrid))))) and (not (colof(square12(mygrid)) = colof(square21(mygrid))))) and (not (colof(square12(mygrid)) = colof(square22(mygrid))))) and (not (colof(square21(mygrid)) = colof(square22(mygrid)))): syntactic simplification fails.
((((not (colof(square11(mygrid)) = colof(square12(mygrid)))) and (not (colof(square11(mygrid)) = colof(square21(mygrid))))) and (not (colof(square11(mygrid)) = colof(square22(mygrid))))) and (not (colof(square12(mygrid)) = colof(square21(mygrid))))) and (not (colof(square12(mygrid)) = colof(square22(mygrid)))): syntactic simplification fails.
(((not (colof(square11(mygrid)) = colof(square12(mygrid)))) and (not (colof(square11(mygrid)) = colof(square21(mygrid))))) and (not (colof(square11(mygrid)) = colof(square22(mygrid))))) and (not (colof(square12(mygrid)) = colof(square21(mygrid)))): syntactic simplification fails.
((not (colof(square11(mygrid)) = colof(square12(mygrid)))) and (not (colof(square11(mygrid)) = colof(square21(mygrid))))) and (not (colof(square11(mygrid)) = colof(square22(mygrid)))): syntactic simplification fails.
(not (colof(square11(mygrid)) = colof(square12(mygrid)))) and (not (colof(square11(mygrid)) = colof(square21(mygrid)))): syntactic simplification fails.
not (colof(square11(mygrid)) = colof(square12(mygrid))): syntactic simplification fails.
colof has no interpretation.
Syntactic simplification of colof(square11(mygrid)) gives red
Evaluating red gives red
Evaluating colof(square11(mygrid)) gives red
colof has no interpretation.
Syntactic simplification of colof(square12(mygrid)) gives blue
Evaluating blue gives blue
Evaluating colof(square12(mygrid)) gives blue
Evaluating colof(square11(mygrid)) = colof(square12(mygrid)) gives FALSE
TRUE: syntactic simplification fails.
not (colof(square11(mygrid)) = colof(square21(mygrid))): syntactic simplification fails.
colof has no interpretation.
Syntactic simplification of colof(square11(mygrid)) gives red
Evaluating red gives red
Evaluating colof(square11(mygrid)) gives red
colof has no interpretation.
Syntactic simplification of colof(square21(mygrid)) gives green
Evaluating green gives green
Evaluating colof(square21(mygrid)) gives green
Evaluating colof(square11(mygrid)) = colof(square21(mygrid)) gives FALSE
TRUE: syntactic simplification fails.
TRUE: syntactic simplification fails.
not (colof(square11(mygrid)) = colof(square22(mygrid))): syntactic simplification fails.
colof has no interpretation.
Syntactic simplification of colof(square11(mygrid)) gives red
Evaluating red gives red
Evaluating colof(square11(mygrid)) gives red
colof has no interpretation.
Syntactic simplification of colof(square22(mygrid)) gives red
Evaluating red gives red
Evaluating colof(square22(mygrid)) gives red
Evaluating colof(square11(mygrid)) = colof(square22(mygrid)) gives TRUE
FALSE: syntactic simplification fails.
FALSE: syntactic simplification fails.
FALSE: syntactic simplification fails.
FALSE: syntactic simplification fails.
FALSE: syntactic simplification fails.
Evaluating alldiffcol(mygrid) gives FALSE

2   not alldiffcol(mygrid)     

GETFOL:: assume forall grid.(allsuccdiffcol(grid)imp alldiffcol(grid));

3   forall grid. (allsuccdiffcol(grid) imp alldiffcol(grid))     (3)

GETFOL:: alle 3 mygrid;

4   allsuccdiffcol(mygrid) imp alldiffcol(mygrid)     (3)

GETFOL:: impe 1 4;

5   alldiffcol(mygrid)     (3)

GETFOL:: falsei 2 5;

6   FALSE     (3)

GETFOL:: noti 6 3;

7   not forall grid. (allsuccdiffcol(grid) imp alldiffcol(grid))     

GETFOL:: I am finished fetching eval/grid.tst

GETFOL:: 	reset;
Resetting the whole GETFOL-system

GETFOL:: 	fetch eval/gridrev.tst;
I am starting to fetch eval/gridrev.tst

GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: DECLARE SORT GRID;
GRID has been declared to be a sort

GETFOL:: DECREP GRIDREP;

GETFOL:: DECLARE SORT COLOR;
COLOR has been declared to be a sort

GETFOL:: DECREP COLORREP;

GETFOL:: DECLARE FUNCONST mkgrid(COLOR,COLOR,COLOR,COLOR)=GRID;
GRID is a sort
COLOR is a sort
COLOR is a sort
COLOR is a sort
COLOR is a sort
mkgrid has been declared to be a Funconst

GETFOL:: DEFLAM mkgrid(col1 col2 col3 col4)(LIST col1 col2 col3 col4);

GETFOL:: ATTACH mkgrid to [COLORREP COLORREP COLORREP COLORREP=GRIDREP]  mkgrid;
mkgrid attached to mkgrid

GETFOL:: DECLARE FUNCONST color11(GRID)=COLOR;
COLOR is a sort
GRID is a sort
color11 has been declared to be a Funconst

GETFOL:: DEFLAM color11(grid)(FIRST GRID);

GETFOL::  
ATTACH color11 to [GRIDREP=COLORREP]color11;
color11 attached to color11

GETFOL:: DECLARE FUNCONST color12(GRID)=COLOR;
COLOR is a sort
GRID is a sort
color12 has been declared to be a Funconst

GETFOL:: DEFLAM color12(grid)(SECOND GRID);

GETFOL::  
ATTACH color12 to [GRIDREP=COLORREP]color12;
color12 attached to color12

GETFOL:: DECLARE FUNCONST color21(GRID)=COLOR;
COLOR is a sort
GRID is a sort
color21 has been declared to be a Funconst

GETFOL:: DEFLAM color21(grid)(THIRD GRID);

GETFOL::  
ATTACH color21 to [GRIDREP=COLORREP]color21;
color21 attached to color21

GETFOL:: DECLARE FUNCONST color22(GRID)=COLOR;
COLOR is a sort
GRID is a sort
color22 has been declared to be a Funconst

GETFOL:: DEFLAM color22(grid)(HGKM\-NTH 4 GRID);

GETFOL::  
ATTACH color22 to [GRIDREP=COLORREP]color22;
color22 attached to color22

GETFOL:: DECLARE INDCONST red, green, yellow, blue [COLOR];
COLOR is a sort
red has been declared to be an Indconst
green has been declared to be an Indconst
yellow has been declared to be an Indconst
blue has been declared to be an Indconst

GETFOL:: ATTACH red   DAR [COLORREP]red;
red attached to 'red
red is the preferred name of red

GETFOL:: ATTACH green DAR [COLORREP]green;
green attached to 'green
green is the preferred name of green

GETFOL:: ATTACH yellow DAR [COLORREP]yellow;
yellow attached to 'yellow
yellow is the preferred name of yellow

GETFOL:: ATTACH blue   DAR [COLORREP]blue;
blue attached to 'blue
blue is the preferred name of blue

GETFOL:: EXTENSION COLOR BY {red, green, yellow, blue};

Now the extension of COLOR is fixed to be : red green yellow blue 
GETFOL:: DECLARE indvar col1,col2,col3,col4 [COLOR];
COLOR is a sort
col1 has been declared to be an Indvar
col2 has been declared to be an Indvar
col3 has been declared to be an Indvar
col4 has been declared to be an Indvar

GETFOL:: DECLARE PREDCONST alldiffcol 1;
alldiffcol has been declared to be a Predconst

GETFOL:: DEFLAM alldiffcol(grid)
(IF (AND (NOT (EQ (FIRST grid)(SECOND grid)))
         (NOT (EQ (FIRST grid)(THIRD grid)))
         (NOT (EQ (FIRST grid)(HGKM\-NTH 4 grid)))
         (NOT (EQ (SECOND grid)(THIRD grid)))
         (NOT (EQ (SECOND grid)(HGKM\-NTH 4 grid)))
         (NOT (EQ (THIRD grid)(HGKM\-NTH 4 grid))))
 TRUE
 FALSE);

GETFOL:: ATTACH alldiffcol to [GRIDREP] alldiffcol;
alldiffcol attached to alldiffcol

GETFOL:: DECLARE PREDCONST allsuccdiffcol 1;
allsuccdiffcol has been declared to be a Predconst

GETFOL:: DEFLAM allsuccdiffcol(grid)
(IF (AND (NOT (EQ (FIRST grid)(SECOND grid)))
         (NOT (EQ (SECOND grid)(HGKM\-NTH 4 grid)))
         (NOT (EQ (HGKM\-NTH 4 grid)(THIRD grid)))
         (NOT (EQ (THIRD grid)(FIRST grid))))
 TRUE
 FALSE);

GETFOL:: ATTACH allsuccdiffcol to [GRIDREP] allsuccdiffcol;
allsuccdiffcol attached to allsuccdiffcol

GETFOL:: simplify forall col1 col2 col3 col4.
      (allsuccdiffcol(mkgrid(col1 col2 col3 col4)) imp
       alldiffcol(mkgrid(col1 col2 col3 col4)));

1   not forall col1 col2 col3 col4. (allsuccdiffcol(mkgrid(col1, col2, col3, col4)) imp alldiffcol(mkgrid(col1, col2, col3, col4)))     

GETFOL:: I am finished fetching eval/gridrev.tst

GETFOL:: 	reset;
Resetting the whole GETFOL-system

GETFOL:: 	fetch eval/rewrite1.tst;
I am starting to fetch eval/rewrite1.tst

GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: declare sentconst A B;
A has been declared to be a Sentconst
B has been declared to be a Sentconst

GETFOL:: declare sort S T;
S has been declared to be a sort
T has been declared to be a sort

GETFOL:: declare indvar s[S];
S is a sort
s has been declared to be an Indvar

GETFOL:: declare indconst d[S];
S is a sort
d has been declared to be an Indconst

GETFOL:: declare indvar t[T];
T is a sort
t has been declared to be an Indvar

GETFOL:: declare indvar x y z;
UNIVERSAL is a sort
x has been declared to be an Indvar
y has been declared to be an Indvar
z has been declared to be an Indvar

GETFOL:: declare indconst a b c;
UNIVERSAL is a sort
a has been declared to be an Indconst
b has been declared to be an Indconst
c has been declared to be an Indconst

GETFOL:: declare predconst p q 2;
p has been declared to be a Predconst
q has been declared to be a Predconst

GETFOL:: assume forall x.p(x,x);

1   forall x. p(x, x)     (1)

GETFOL:: assume forall x y.(p(x y) iff q(x y));

2   forall x y. (p(x, y) iff q(x, y))     (2)

GETFOL:: assume forall s.S(s);

3   forall s. S(s)     (3)

GETFOL:: assume forall x y.p(x y) iff forall x y.q(x y);

4   forall x y. p(x, y) iff forall x y. q(x, y)     (4)

GETFOL:: assume forall x.(p(a a ) iff p(x  x));

5   forall x. (p(a, a) iff p(x, x))     (5)

GETFOL:: setbasicsimp s1 at FACTS {1};

GETFOL:: setbasicsimp s2 at FACTS {2};

GETFOL:: setbasicsimp s3 at FACTS {3};

GETFOL:: setbasicsimp s4 at FACTS {4};

GETFOL:: rewrite p(a a) by s1;

6   p(a, a)     (1)

GETFOL:: rewrite p(a b) by s2;

7   p(a, b) iff q(a, b)     (2)

GETFOL:: rewrite p(x,x) by s2;

8   p(x, x) iff q(x, x)     (2)

GETFOL:: rewrite forall x.TRUE;

9   forall x. TRUE     

GETFOL:: rewrite A and not A;

10   not (A and (not A))     

GETFOL:: rewrite (A and A) iff (B and A);

11   ((A and A) iff (B and A)) iff (A iff (B and A))     

GETFOL:: rewrite S(d) by s3;

12   S(d)     (3)

GETFOL:: rewrite forall x.S(x) and forall x.S(x);

13   (forall x. S(x) and forall x. S(x)) iff forall x. S(x)     

GETFOL:: rewrite forall x.(forall x.TRUE);

14   forall x x. TRUE     

GETFOL:: rewrite p(y y) by s1;

15   p(y, y)     (1)

GETFOL:: rewrite p(t t) by s1;

16   p(t, t)     (1)

GETFOL:: rewrite p(a b) by s2;

17   p(a, b) iff q(a, b)     (2)

GETFOL:: rewrite forall y x.p(y x) by s4;

18   forall y x. p(y, x) iff forall x13 y14. q(x13, y14)     (4)

GETFOL:: I am finished fetching eval/rewrite1.tst

GETFOL:: 	reset;
Resetting the whole GETFOL-system

GETFOL:: 	fetch eval/rewrite2.tst;
I am starting to fetch eval/rewrite2.tst

GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: declare indconst A,B;
UNIVERSAL is a sort
A has been declared to be an Indconst
B has been declared to be an Indconst

GETFOL:: declare indvar X,Y;
UNIVERSAL is a sort
X has been declared to be an Indvar
Y has been declared to be an Indvar

GETFOL:: declare funconst F 2;
F has been declared to be a Funconst

GETFOL:: declare funconst G 1;
G has been declared to be a Funconst

GETFOL:: declare sentconst P;
P has been declared to be a Sentconst

GETFOL:: assume forall X . F(X,A) = A;

1   forall X. (F(X, A) = A)     (1)

GETFOL:: assume forall X . F(X,X) = G(X);

2   forall X. (F(X, X) = G(X))     (2)

GETFOL:: assume forall X Y . F(X,Y) =Y;

3   forall X Y. (F(X, Y) = Y)     (3)

GETFOL:: axiom F1:forall X . F(X,A) = A;

F1 : forall X. (F(X, A) = A)

GETFOL:: axiom F2:forall X . F(X,X) = G(X);

F2 : forall X. (F(X, X) = G(X))

GETFOL:: axiom F3:forall X Y. F(X,Y) = Y;

F3 : forall X Y. (F(X, Y) = Y)

GETFOL:: setbasicsimp S1 at facts {1};

GETFOL:: setbasicsimp S2 at facts {2};

GETFOL:: setbasicsimp S3 at facts {3};

GETFOL:: setbasicsimp S4 at facts {F1};

GETFOL:: setbasicsimp S5 at facts {F2};

GETFOL:: setbasicsimp S6 at facts {F3};

GETFOL:: setbasicsimp SIMPEQ at wffs {forall X.(X=X iff TRUE)};

GETFOL:: setcompsimp S7 at S1 uni S2 uni S3;

GETFOL:: rewrite F(A,A) by S6;

4   F(A, A) = A     

GETFOL:: rewrite F(A,A) by S5;

5   F(A, A) = G(A)     

GETFOL:: rewrite F(A,A) by S4;

6   F(A, A) = A     

GETFOL:: rewrite F(A,A) by S1;

7   F(A, A) = A     (1)

GETFOL:: rewrite F(A,A) by S2;

8   F(A, A) = G(A)     (2)

GETFOL:: rewrite F(A,A) by S3;

9   F(A, A) = A     (3)

GETFOL:: rewrite F(A,A) by S7;

10   F(A, A) = A     (1)

GETFOL:: rewrite F(B,B) by S1 uni S3;

11   F(B, B) = B     (3)

GETFOL:: rewrite F(B,B) by S1;
F(B, B): No simplification is possible

GETFOL:: rewrite not TRUE by S1;
not TRUE: No simplification is possible

GETFOL:: rewrite not TRUE;

12   not (not TRUE)     

GETFOL:: rewrite TRUE imp (P imp X=X);

13   (TRUE imp (P imp (X = X))) iff (P imp (X = X))     

GETFOL:: rewrite TRUE imp (P imp X=X) by SIMPEQ uni LOGICTREE;

14   TRUE imp (P imp (X = X))     

GETFOL:: rewrite F(A,A) by S7;

15   F(A, A) = A     (1)

GETFOL:: rewrite F(A,A)=A by S7;

16   (F(A, A) = A) iff (A = A)     (1)

GETFOL:: rewrite F(A,A)=A by S7 uni SIMPEQ;

17   F(A, A) = A     (1)

GETFOL:: rewrite F(A,A)=G(A) by S7;

18   (F(A, A) = G(A)) iff (A = G(A))     (1)

GETFOL:: rewrite F(B,B) by S7;

19   F(B, B) = G(B)     (2)

GETFOL:: rewrite F(B,B)=G(B) by S7 uni SIMPEQ;

20   F(B, B) = G(B)     (2)

GETFOL:: rewrite F(B,B)=G(B) and F(A,A)=A by S7 uni SIMPEQ uni LOGICTREE;

21   (F(B, B) = G(B)) and (F(A, A) = A)     (1 2)

GETFOL:: rewrite F(A,A) by S7 dif S1 ;

22   F(A, A) = G(A)     (2)

GETFOL:: rewrite F(A,A) by S7 dif (S1 uni S2);

23   F(A, A) = A     (3)

GETFOL:: rewrite F(A,A)=A by (S3 dif (S1 uni S2));

24   (F(A, A) = A) iff (A = A)     (3)

GETFOL:: rewrite F(A,A)=A by S3 dif (S1 uni S2) uni SIMPEQ;

25   F(A, A) = A     (3)

GETFOL:: I am finished fetching eval/rewrite2.tst

GETFOL:: 	reset;
Resetting the whole GETFOL-system

GETFOL:: 	fetch eval/rewrite3.tst;
I am starting to fetch eval/rewrite3.tst

GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: declare indvar x1 x2 x3;
UNIVERSAL is a sort
x1 has been declared to be an Indvar
x2 has been declared to be an Indvar
x3 has been declared to be an Indvar

GETFOL:: declare indconst a1 a2 a3;
UNIVERSAL is a sort
a1 has been declared to be an Indconst
a2 has been declared to be an Indconst
a3 has been declared to be an Indconst

GETFOL:: declare funconst f1 1;
f1 has been declared to be a Funconst

GETFOL:: declare funconst f2 2;
f2 has been declared to be a Funconst

GETFOL:: declare funconst f3 3;
f3 has been declared to be a Funconst

GETFOL:: declare funpar F1 1;
F1 has been declared to be a Funpar

GETFOL:: declare funpar F2 2;
F2 has been declared to be a Funpar

GETFOL:: declare funpar F3 3;
F3 has been declared to be a Funpar

GETFOL:: declare predconst p1 1;
p1 has been declared to be a Predconst

GETFOL:: declare predconst p2 2;
p2 has been declared to be a Predconst

GETFOL:: declare predconst p3 3;
p3 has been declared to be a Predconst

GETFOL:: declare predpar P1 1;
P1 has been declared to be a Predpar

GETFOL:: declare predpar P2 2;
P2 has been declared to be a Predpar

GETFOL:: declare predpar P3 3;
P3 has been declared to be a Predpar

GETFOL:: setbasicsimp simp1 at wffs 
{forall x1.F1(x1)=x1,
 forall x1 x2.F2(x1 x2)=x1,
 forall x1 x2 x3.F3(x1 x2 x3)=x1};

GETFOL:: show simpset simp1;
Wffs :  
forall x1. (F1(x1) = x1)
forall x1 x2. (F2(x1, x2) = x1)
forall x1 x2 x3. (F3(x1, x2, x3) = x1)
This basic simpset does not contain any fact.

GETFOL:: rewrite f3(f2(f1(a1) a2) a2 a3) by simp1;

1   f3(f2(f1(a1), a2), a2, a3) = a1     

GETFOL:: setbasicsimp simp2 at wffs 
{forall x1.P1(x1),forall x1 x2.P2(x1 x2),forall x1 x2 x3.P3(x1 x2 x3)};

GETFOL:: show simpset simp2;
Wffs :  
forall x1. P1(x1)
forall x1 x2. P2(x1, x2)
forall x1 x2 x3. P3(x1, x2, x3)
This basic simpset does not contain any fact.

GETFOL:: rewrite p1(a1) by simp2;

2   p1(a1)     

GETFOL:: rewrite p2(a1 a2) by simp2;

3   p2(a1, a2)     

GETFOL:: rewrite p3(a1 a2 a3) by simp2;

4   p3(a1, a2, a3)     

GETFOL:: setbasicsimp simp3 at wffs 
{forall x1.F1(F2(x1,x2))=F2(F1(x1),x2),
 P2(a1,a2) iff P2(a2,a1),
 P3(F1(a1),a2,a3) iff P3(a1,F1(a2),a3)};

GETFOL:: rewrite f1(f2(a1,a2)) by simp3;

5   f1(f2(a1, a2)) = f2(f1(a1), a2)     

GETFOL:: rewrite p2(a1,a2) by simp3;

6   p2(a1, a2) iff p2(a2, a1)     

GETFOL:: rewrite p3(f1(a1),a2,a3) by simp3;

7   p3(f1(a1), a2, a3) iff p3(a1, f1(a2), a3)     

GETFOL:: I am finished fetching eval/rewrite3.tst

GETFOL:: 	reset;
Resetting the whole GETFOL-system

GETFOL:: 	fetch eval/simpl1.tst;
I am starting to fetch eval/simpl1.tst

GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: DECLARE FUNCONST + *(NATNUM NATNUM)=NATNUM [INF];
NATNUM has been declared to be a sort
+ has been declared to be a Funconst
* has been declared to be a Funconst

GETFOL:: declare indconst o oo ooo [NATNUM];
NATNUM is a sort
o has been declared to be an Indconst
oo has been declared to be an Indconst
ooo has been declared to be an Indconst

GETFOL:: declare indconst u uu;
UNIVERSAL is a sort
u has been declared to be an Indconst
uu has been declared to be an Indconst

GETFOL:: declare predconst ugu 2;
ugu has been declared to be a Predconst

GETFOL:: DECREP natnum nat;

GETFOL:: attach o dar [natnum] 5;
o attached to '5
o is the preferred name of 5

GETFOL:: attach oo dar [natnum] 10;
oo attached to '10
oo is the preferred name of 10

GETFOL:: attach u dar [natnum] 1;
u attached to '1
u is the preferred name of 1

GETFOL:: attach uu dar [nat] 1;
uu attached to '1
uu is the preferred name of 1

GETFOL:: attach + to [natnum,natnum=natnum] PLUS;
+ attached to PLUS

GETFOL:: attach = to [natnum,natnum] EQ;
= attached to EQ

GETFOL:: attach ugu to [natnum,natnum] EQ;
ugu attached to EQ

GETFOL:: attach * to [nat,natnum=nat] TIMES;
* attached to TIMES

GETFOL::  
attach * to [natnum,nat=natnum] TIMES;
* attached to TIMES

GETFOL:: simplify u*uu;

1   (u * uu) = u     

GETFOL:: simplify uu*u;

2   (uu * u) = uu     

GETFOL:: simplify ugu(uu*u,u*uu);
ugu(uu * u, u * uu) : No simplification is possible.

GETFOL:: simplify trmif ugu(o,o) then oo else o;

3   (trmif ugu(o, o) then oo else o) = oo     

GETFOL:: simplify trmif ugu(o,oo) then oo else o;

4   (trmif ugu(o, oo) then oo else o) = o     

GETFOL:: simplify trmif ugu(o,ooo) then oo else o+o;

5   (trmif ugu(o, ooo) then oo else (o + o)) = oo     

GETFOL:: simplify uu*u = u*uu;
(uu * u) = (u * uu) : No simplification is possible.

GETFOL:: simplify trmif o = o then oo else o;

6   (trmif (o = o) then oo else o) = oo     

GETFOL:: simplify trmif o=oo then oo else o;

7   (trmif (o = oo) then oo else o) = o     

GETFOL:: simplify trmif o=ooo then oo else o+o;

8   (trmif (o = ooo) then oo else (o + o)) = oo     

GETFOL:: simplify trmif ugu(o,o) then trmif ugu(o,oo) then oo else o else o;

9   (trmif ugu(o, o) then (trmif ugu(o, oo) then oo else o) else o) = o     

GETFOL:: simplify trmif ugu(o,o) then trmif ugu(o,ooo) then oo else o else o;
trmif ugu(o, o) then (trmif ugu(o, ooo) then oo else o) else o : No simplification is possible.

GETFOL:: simplify ugu(o,o) iff ugu(o,o);

10   ugu(o, o) iff ugu(o, o)     

GETFOL:: simplify ugu(o,o) and ugu(o,o);

11   ugu(o, o) and ugu(o, o)     

GETFOL:: simplify ugu(o,o) or ugu(o,o);

12   ugu(o, o) or ugu(o, o)     

GETFOL:: simplify ugu(o,o) imp ugu(o,o);

13   ugu(o, o) imp ugu(o, o)     

GETFOL:: simplify not ugu(o,o);

14   not (not ugu(o, o))     

GETFOL:: simplify not (ugu(o,o) and (ugu(u,uu*u) or ugu(o*u,o)));
not (ugu(o, o) and (ugu(u, uu * u) or ugu(o * u, o))) : No simplification is possible.

GETFOL:: I am finished fetching eval/simpl1.tst

GETFOL:: 	reset;
Resetting the whole GETFOL-system

GETFOL:: 	fetch eval/simpl2.tst;
I am starting to fetch eval/simpl2.tst

GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: declare indconst a b c;
UNIVERSAL is a sort
a has been declared to be an Indconst
b has been declared to be an Indconst
c has been declared to be an Indconst

GETFOL:: DECREP rep1 rep2;

GETFOL:: attach a to a;
a attached to 'a

GETFOL:: attach b to[*] b;
b attached to 'b

GETFOL:: attach c to [rep1]c;
c attached to 'c

GETFOL:: hardware c dar c;
c attached to c
c is the preferred name of c

GETFOL:: declare funconst f 2;
f has been declared to be a Funconst

GETFOL:: declare predconst p 2;
p has been declared to be a Predconst

GETFOL:: declare predconst pp 1;
pp has been declared to be a Predconst

GETFOL:: attach pp to pp;
pp attached to pp

GETFOL:: attach f to f;
f attached to f

GETFOL:: attach f to [rep1 rep2 = *] l;
f attached to l

GETFOL:: attach p to p;
p attached to p

GETFOL:: attach p to [rep1 *] p;
p attached to p

GETFOL:: declare sentconst S1,S2,S3;
S1 has been declared to be a Sentconst
S2 has been declared to be a Sentconst
S3 has been declared to be a Sentconst

GETFOL:: attach S1 to T;
S1 attached to 'T

GETFOL:: simplify S1;

1   S1     

GETFOL:: simplify S1 and S1;

2   S1 and S1     

GETFOL:: simplify S1 imp S1;

3   S1 imp S1     

GETFOL:: attach S2 to NIL;
S2 attached to 'NIL

GETFOL:: simplify S2;

4   not S2     

GETFOL:: attach S3 to UNDEF&;
S3 attached to 'UNDEF&

GETFOL:: simplify S3;
S3 : No simplification is possible.

GETFOL:: declare predconst P 2;
P has been declared to be a Predconst

GETFOL:: attach P to P;
P attached to P

GETFOL:: DEFLAM P(x y) T;

GETFOL:: attach a to a;
a attached to 'a

GETFOL:: attach b to b;
b attached to 'b

GETFOL:: simplify P(a b);

5   P(a, b)     

GETFOL:: DEFLAM fact(n) (IF (EQ n 0) 1 (* n (fact (- n 1))));

GETFOL:: know natnums;

GETFOL:: declare funconst fact 1;
fact has been declared to be a Funconst

GETFOL:: attach fact to [NATNUMREP=NATNUMREP]fact;
fact attached to fact

GETFOL:: simplify fact(3);

6   fact(3) = 6     

GETFOL:: attach a to c;
a attached to 'c

GETFOL:: DEFLAM P(a b) (IF (EQ a (QUOTE c))T NIL);

GETFOL:: simplify P(a b);

7   P(a, b)     

GETFOL:: simplify P(b a);

8   not P(b, a)     

GETFOL:: declare sort s;
s has been declared to be a sort

GETFOL:: DEFLAM s(x) T;

GETFOL:: attach s to s;
s attached to s

GETFOL:: simplify s(a);

9   s(a)     

GETFOL:: declare sort t;
t has been declared to be a sort

GETFOL:: moregeneral t <s>;

GETFOL:: simplify t(a);

10   t(a)     

GETFOL:: I am finished fetching eval/simpl2.tst

GETFOL:: 	reset;
Resetting the whole GETFOL-system

GETFOL:: 	fetch eval/sorts.tst;
I am starting to fetch eval/sorts.tst

GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: namecontext eval\-initial;
You have named the current context: eval-initial

GETFOL:: makecontext eval1;
You have created the empty context: eval1

GETFOL:: switchcontext eval1;
You are now using context: eval1
You are switching to a proof with no name.

GETFOL:: declare sort s1 s2 s3 s4 s5 s6;
s1 has been declared to be a sort
s2 has been declared to be a sort
s3 has been declared to be a sort
s4 has been declared to be a sort
s5 has been declared to be a sort
s6 has been declared to be a sort

GETFOL:: moregeneral s2 <s1>;

GETFOL:: moregeneral s4 <s3>;

GETFOL:: declare indconst c1 [s1];
s1 is a sort
c1 has been declared to be an Indconst

GETFOL:: declare indconst c2 [s2];
s2 is a sort
c2 has been declared to be an Indconst

GETFOL:: declare indconst c3 [s3];
s3 is a sort
c3 has been declared to be an Indconst

GETFOL:: declare indconst c4 [s4];
s4 is a sort
c4 has been declared to be an Indconst

GETFOL:: declare funconst f 2;
f has been declared to be a Funconst

GETFOL:: s5 is a sort
s1 is a sort
s4 is a sort

GETFOL:: s6 is a sort
s2 is a sort
s3 is a sort

GETFOL:: eval s5(f(c1 c3));
Evaluating s5(f(c1, c3)) gives TRUE

1   s5(f(c1, c3))     

GETFOL:: eval s6(f(c1 c3));
Evaluating s6(f(c1, c3)) gives TRUE

2   s6(f(c1, c3))     

GETFOL:: 
GETFOL:: makecontext eval2;
You have created the empty context: eval2

GETFOL:: switchcontext eval2;
You are now using context: eval2
You are switching to a proof with no name.

GETFOL:: declare sort s1 s2 s3 s4;
s1 has been declared to be a sort
s2 has been declared to be a sort
s3 has been declared to be a sort
s4 has been declared to be a sort

GETFOL:: moregeneral s1 <s2 s3 s4>;

GETFOL:: moregeneral s2 <s3 s4>;

GETFOL:: moregeneral s3 <s4>;

GETFOL:: declare indvar x;
UNIVERSAL is a sort
x has been declared to be an Indvar

GETFOL:: declare indvar x1 [s1];
s1 is a sort
x1 has been declared to be an Indvar

GETFOL:: declare indvar x2 [s2];
s2 is a sort
x2 has been declared to be an Indvar

GETFOL:: declare indvar x3 [s3];
s3 is a sort
x3 has been declared to be an Indvar

GETFOL:: declare indvar x4 [s4];
s4 is a sort
x4 has been declared to be an Indvar

GETFOL:: eval s1(x4);
Evaluating s1(x4) gives TRUE

1   s1(x4)     

GETFOL:: eval s1(x1);
Evaluating s1(x1) gives TRUE

2   s1(x1)     

GETFOL:: eval s1(x2);
Evaluating s1(x2) gives TRUE

3   s1(x2)     

GETFOL:: eval s1(x3);
Evaluating s1(x3) gives TRUE

4   s1(x3)     

GETFOL:: eval s2(x2);
Evaluating s2(x2) gives TRUE

5   s2(x2)     

GETFOL:: eval s2(x3);
Evaluating s2(x3) gives TRUE

6   s2(x3)     

GETFOL:: eval s2(x4);
Evaluating s2(x4) gives TRUE

7   s2(x4)     

GETFOL:: eval s3(x3);
Evaluating s3(x3) gives TRUE

8   s3(x3)     

GETFOL:: eval s3(x4);
Evaluating s3(x4) gives TRUE

9   s3(x4)     

GETFOL:: eval s4(x4);
Evaluating s4(x4) gives TRUE

10   s4(x4)     

GETFOL:: I am finished fetching eval/sorts.tst

GETFOL:: 	reset;
Resetting the whole GETFOL-system

GETFOL:: 	fetch eval/tarith.tst;
I am starting to fetch eval/tarith.tst

GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: know natnums;

GETFOL:: 
GETFOL:: 
GETFOL:: DECLARE INDVAR x y z [NATNUMSORT];
NATNUMSORT is a sort
x has been declared to be an Indvar
y has been declared to be an Indvar
z has been declared to be an Indvar

GETFOL:: DECLARE FUNCONST s p (NATNUMSORT)=NATNUMSORT;
NATNUMSORT is a sort
NATNUMSORT is a sort
s has been declared to be a Funconst
p has been declared to be a Funconst

GETFOL:: DECLARE FUNCONST + * (NATNUMSORT NATNUMSORT)=NATNUMSORT [INF];
NATNUMSORT is a sort
NATNUMSORT is a sort
NATNUMSORT is a sort
+ has been declared to be a Funconst
* has been declared to be a Funconst

GETFOL:: DECLARE PREDCONST < 2 [INF];
< has been declared to be a Predconst

GETFOL:: DECLARE PREDPAR PHI 1;
PHI has been declared to be a Predpar

GETFOL:: 
GETFOL:: AXIOM oneone:forall x y. s(x) = s(y) imp x = y;

oneone : forall x y. (s(x) = s(y)) imp (x = y)

GETFOL:: AXIOM succ1:forall x. (not 0=s(x));

succ1 : forall x. (not (0 = s(x)))

GETFOL:: AXIOM succ2:forall x. not x = 0 imp (exists y. s(y) = x);

succ2 : forall x. (not (x = 0)) imp exists y. (s(y) = x)

GETFOL:: AXIOM succ3:forall x. not s(x) = x;

succ3 : forall x. (not (s(x) = x))

GETFOL:: AXIOM plus1:forall x. x + 0 = x;

plus1 : forall x. ((x + 0) = x)

GETFOL:: AXIOm plus2: forall x y. x + s(y) = s(x + y);

plus2 : forall x y. ((x + s(y)) = s(x + y))

GETFOL:: AXIOM times1: forall x. x * 0 = 0;

times1 : forall x. ((x * 0) = 0)

GETFOL:: AXIOM times2: forall x y. x * s(y) = (x * y) + x;

times2 : forall x y. ((x * s(y)) = ((x * y) + x))

GETFOL:: AXIOM induct:
PHI(0) and (forall x. (PHI(x) imp PHI(s(x)))) imp (forall x. PHI(x));

induct : (PHI(0) and forall x. (PHI(x) imp PHI(s(x)))) imp forall x. PHI(x)

GETFOL:: DEFLAM s (x) (+ x 1);

GETFOL:: ATTACH s TO [NATNUMREP=NATNUMREP]s;
s attached to s

GETFOL:: DEFLAM p (x)
 (IF (> x 0) 
  (- x 1)
  0);

GETFOL:: ATTACH p TO [NATNUMREP=NATNUMREP]p;
p attached to p

GETFOL::                                 
DEFLAM plus (x y) (+ x y);

GETFOL:: ATTACH + TO [NATNUMREP,NATNUMREP=NATNUMREP]plus;
+ attached to plus

GETFOL:: DEFLAM times (x y) (* x y);

GETFOL:: ATTACH * TO [NATNUMREP,NATNUMREP=NATNUMREP]times;
* attached to times

GETFOL:: DEFLAM less (x y) (< x y);

GETFOL:: ATTACH < TO [NATNUMREP,NATNUMREP]less;
< attached to less

GETFOL:: DECLARE FUNCONST fact(NATNUMSORT)=NATNUMSORT;
NATNUMSORT is a sort
NATNUMSORT is a sort
fact has been declared to be a Funconst

GETFOL:: AXIOM FACT:forall x. fact(x)= trmif x = 0 then 1 else x *fact(p(x));

FACT : forall x. (fact(x) = (trmif (x = 0) then 1 else (x * fact(p(x)))))

GETFOL:: setbasicsimp S at facts {FACT};

GETFOL:: eval fact(5) by S uni LARGIFTREE;
fact has no interpretation.
Syntactic simplification of fact(5) gives trmif (5 = 0) then 1 else (5 * fact(p(5)))
Evaluating 5 gives 5
Evaluating 0 gives 0
Evaluating 5 = 0 gives FALSE
Evaluating 5 gives 5
fact has no interpretation.
Syntactic simplification of fact(p(5)) gives trmif (p(5) = 0) then 1 else (p(5) * fact(p(p(5))))
Evaluating 5 gives 5
Evaluating p(5) gives 4
Evaluating 0 gives 0
Evaluating p(5) = 0 gives FALSE
Evaluating 5 gives 5
Evaluating p(5) gives 4
fact has no interpretation.
Syntactic simplification of fact(p(p(5))) gives trmif (p(p(5)) = 0) then 1 else (p(p(5)) * fact(p(p(p(5)))))
Evaluating 5 gives 5
Evaluating p(5) gives 4
Evaluating p(p(5)) gives 3
Evaluating 0 gives 0
Evaluating p(p(5)) = 0 gives FALSE
Evaluating 5 gives 5
Evaluating p(5) gives 4
Evaluating p(p(5)) gives 3
fact has no interpretation.
Syntactic simplification of fact(p(p(p(5)))) gives trmif (p(p(p(5))) = 0) then 1 else (p(p(p(5))) * fact(p(p(p(p(5))))))
Evaluating 5 gives 5
Evaluating p(5) gives 4
Evaluating p(p(5)) gives 3
Evaluating p(p(p(5))) gives 2
Evaluating 0 gives 0
Evaluating p(p(p(5))) = 0 gives FALSE
Evaluating 5 gives 5
Evaluating p(5) gives 4
Evaluating p(p(5)) gives 3
Evaluating p(p(p(5))) gives 2
fact has no interpretation.
Syntactic simplification of fact(p(p(p(p(5))))) gives trmif (p(p(p(p(5)))) = 0) then 1 else (p(p(p(p(5)))) * fact(p(p(p(p(p(5)))))))
Evaluating 5 gives 5
Evaluating p(5) gives 4
Evaluating p(p(5)) gives 3
Evaluating p(p(p(5))) gives 2
Evaluating p(p(p(p(5)))) gives 1
Evaluating 0 gives 0
Evaluating p(p(p(p(5)))) = 0 gives FALSE
Evaluating 5 gives 5
Evaluating p(5) gives 4
Evaluating p(p(5)) gives 3
Evaluating p(p(p(5))) gives 2
Evaluating p(p(p(p(5)))) gives 1
fact has no interpretation.
Syntactic simplification of fact(p(p(p(p(p(5)))))) gives trmif (p(p(p(p(p(5))))) = 0) then 1 else (p(p(p(p(p(5))))) * fact(p(p(p(p(p(p(5))))))))
Evaluating 5 gives 5
Evaluating p(5) gives 4
Evaluating p(p(5)) gives 3
Evaluating p(p(p(5))) gives 2
Evaluating p(p(p(p(5)))) gives 1
Evaluating p(p(p(p(p(5))))) gives 0
Evaluating 0 gives 0
Evaluating p(p(p(p(p(5))))) = 0 gives TRUE
Evaluating 1 gives 1
Evaluating trmif (p(p(p(p(p(5))))) = 0) then 1 else (p(p(p(p(p(5))))) * fact(p(p(p(p(p(p(5)))))))) gives 1
Evaluating fact(p(p(p(p(p(5)))))) gives 1
Evaluating p(p(p(p(5)))) * fact(p(p(p(p(p(5)))))) gives 1
Evaluating trmif (p(p(p(p(5)))) = 0) then 1 else (p(p(p(p(5)))) * fact(p(p(p(p(p(5))))))) gives 1
Evaluating fact(p(p(p(p(5))))) gives 1
Evaluating p(p(p(5))) * fact(p(p(p(p(5))))) gives 2
Evaluating trmif (p(p(p(5))) = 0) then 1 else (p(p(p(5))) * fact(p(p(p(p(5)))))) gives 2
Evaluating fact(p(p(p(5)))) gives 2
Evaluating p(p(5)) * fact(p(p(p(5)))) gives 6
Evaluating trmif (p(p(5)) = 0) then 1 else (p(p(5)) * fact(p(p(p(5))))) gives 6
Evaluating fact(p(p(5))) gives 6
Evaluating p(5) * fact(p(p(5))) gives 24
Evaluating trmif (p(5) = 0) then 1 else (p(5) * fact(p(p(5)))) gives 24
Evaluating fact(p(5)) gives 24
Evaluating 5 * fact(p(5)) gives 120
Evaluating trmif (5 = 0) then 1 else (5 * fact(p(5))) gives 120
Evaluating fact(5) gives 120

1   fact(5) = 120     

GETFOL:: eval (3 * 8);
Evaluating 3 gives 3
Evaluating 8 gives 8
Evaluating 3 * 8 gives 24

2   (3 * 8) = 24     

GETFOL:: eval (4 + 5);
Evaluating 4 gives 4
Evaluating 5 gives 5
Evaluating 4 + 5 gives 9

3   (4 + 5) = 9     

GETFOL:: I am finished fetching eval/tarith.tst

GETFOL:: 	reset;
Resetting the whole GETFOL-system

GETFOL:: 
GETFOL:: 	fetch io/scan.tst;
I am starting to fetch io/scan.tst

GETFOL:: declare sentconst \=\=\+\=\> A\+\-\1;
==+=> has been declared to be a Sentconst
A+-1 has been declared to be a Sentconst

GETFOL:: taut \=\=\+\=\> and A\+\-\1;
TAUT couldn't prove that ==+=> and A+-1
is a tautology.

GETFOL:: declare sentconst \1AB;
1AB has been declared to be a Sentconst

GETFOL:: assume \1AB;

1   1AB     (1)

GETFOL:: I am finished fetching io/scan.tst

GETFOL:: 	reset;
Resetting the whole GETFOL-system

GETFOL:: 
GETFOL:: 	fetch lang/copylex.tst;
I am starting to fetch lang/copylex.tst

GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: reset;
Resetting the whole GETFOL-system

GETFOL:: declare sort S1 S2 S3;
S1 has been declared to be a sort
S2 has been declared to be a sort
S3 has been declared to be a sort

GETFOL:: moregeneral S1 <S2>;

GETFOL:: declare indconst a d [S1];
S1 is a sort
a has been declared to be an Indconst
d has been declared to be an Indconst

GETFOL:: declare indconst b [S2];
S2 is a sort
b has been declared to be an Indconst

GETFOL:: declare indconst c [S3];
S3 is a sort
c has been declared to be an Indconst

GETFOL:: declare indvar x y z[S1];
S1 is a sort
x has been declared to be an Indvar
y has been declared to be an Indvar
z has been declared to be an Indvar

GETFOL:: extension S1 by {a b};

Now the extension of S1 is fixed to be : a b 
GETFOL:: declare sentconst A B C;
A has been declared to be a Sentconst
B has been declared to be a Sentconst
C has been declared to be a Sentconst

GETFOL:: declare indpar p1 p2 p3;
UNIVERSAL is a sort
p1 has been declared to be an Indpar
p2 has been declared to be an Indpar
p3 has been declared to be an Indpar

GETFOL:: declare funconst f 2;
f has been declared to be a Funconst

GETFOL:: S3 is a sort
S1 is a sort
S2 is a sort

GETFOL:: S1 is a sort
S2 is a sort
S3 is a sort

GETFOL:: S3 is a sort
S2 is a sort
S3 is a sort

GETFOL:: declare predconst p 2;
p has been declared to be a Predconst

GETFOL:: mostgeneral S3;
S3 is a sort
S3 is now equivalent to UNIVERSAL

GETFOL:: namecontext C1;
You have named the current context: C1

GETFOL:: makecontext C2;
You have created the empty context: C2

GETFOL:: switchcontext C2;
You are now using context: C2
You are switching to a proof with no name.

GETFOL:: p has been declared to be a Predconst
S3 has been declared to be a sort
S2 has been declared to be a sort
S1 has been declared to be a sort
C has been declared to be a Sentconst
B has been declared to be a Sentconst
A has been declared to be a Sentconst
c has been declared to be an Indconst
b has been declared to be an Indconst
d has been declared to be an Indconst
a has been declared to be an Indconst
z has been declared to be an Indvar
y has been declared to be an Indvar
x has been declared to be an Indvar
p3 has been declared to be an Indpar
p2 has been declared to be an Indpar
p1 has been declared to be an Indpar
f has been declared to be a Funconst
You realise that this makes equivalent S3 and UNIVERSAL

Now the extension of S1 is fixed to be : a b 

GETFOL:: assume A B;

1   A     (1)

2   B     (2)

GETFOL:: andi 1 2;

3   A and B     (1 2)

GETFOL:: attach a dar a;
a attached to 'a
a is the preferred name of a

GETFOL:: attach b dar b;
b attached to 'b
b is the preferred name of b

GETFOL:: attach c dar c;
c attached to 'c
c is the preferred name of c

GETFOL:: attach f to f;
f attached to f

GETFOL:: deflam f(x y) (IF (AND (EQ x (QUOTE a)) (EQ y (QUOTE b)))
		  (QUOTE c) (QUOTE b));

GETFOL:: eval c = f(a,b);
Evaluating c gives c
Evaluating a gives a
Evaluating b gives b
Evaluating f(a, b) gives c
Evaluating c = f(a, b) gives TRUE

4   c = f(a, b)     

GETFOL:: eval f(c,b);
Evaluating c gives c
Evaluating b gives b
Evaluating f(c, b) gives b

5   f(c, b) = b     

GETFOL:: eval exists x y. f(x,y) = b;
exists x y. (f(x, y) = b): syntactic simplification fails.
exists y. (f(a, y) = b): syntactic simplification fails.
Evaluating a gives a
Evaluating a gives a
Evaluating f(a, a) gives b
Evaluating b gives b
Evaluating f(a, a) = b gives TRUE
TRUE: syntactic simplification fails.
TRUE: syntactic simplification fails.

6   exists x y. (f(x, y) = b)     

GETFOL:: wff A;
A is a <wff>.

GETFOL:: wff p(b,c);
p(b, c) is a <wff>.

GETFOL:: I am finished fetching lang/copylex.tst

GETFOL:: 	reset;
Resetting the whole GETFOL-system

GETFOL:: 	fetch lang/declare.tst;
I am starting to fetch lang/declare.tst

GETFOL:: namecontext INITDEC;
You have named the current context: INITDEC

GETFOL:: makecontext DECL1;
You have created the empty context: DECL1

GETFOL:: switchcontext DECL1;
You are now using context: DECL1
You are switching to a proof with no name.

GETFOL:: mostgeneral MG;
MG has been declared to be a sort
MG is now equivalent to UNIVERSAL

GETFOL:: declare sentconst sc1 sc2 sc3;
sc1 has been declared to be a Sentconst
sc2 has been declared to be a Sentconst
sc3 has been declared to be a Sentconst

GETFOL:: declare sentpar sp1 sp2 sp3;
sp1 has been declared to be a Sentpar
sp2 has been declared to be a Sentpar
sp3 has been declared to be a Sentpar

GETFOL:: wff sc1 and sc2 or sc3 imp sp1 and not sp2 iff sp3;
(((sc1 and sc2) or sc3) imp (sp1 and (not sp2))) iff sp3 is a <wff>.

GETFOL:: declare indconst ic1;
UNIVERSAL is a sort
ic1 has been declared to be an Indconst

GETFOL:: declare indpar ip1;
UNIVERSAL is a sort
ip1 has been declared to be an Indpar

GETFOL:: declare indvar iv1;
UNIVERSAL is a sort
iv1 has been declared to be an Indvar

GETFOL:: declare indconst ic2 ic3 ic4 [sic];
sic has been declared to be a sort
ic2 has been declared to be an Indconst
ic3 has been declared to be an Indconst
ic4 has been declared to be an Indconst

GETFOL:: declare indpar ip2 ip3 ip4 [sip];
sip has been declared to be a sort
ip2 has been declared to be an Indpar
ip3 has been declared to be an Indpar
ip4 has been declared to be an Indpar

GETFOL:: declare indvar iv2 iv3 iv4 [siv];
siv has been declared to be a sort
iv2 has been declared to be an Indvar
iv3 has been declared to be an Indvar
iv4 has been declared to be an Indvar

GETFOL:: declare funconst fc4 4;
fc4 has been declared to be a Funconst

GETFOL:: declare funconst fc1 (s1)=s2;
s2 has been declared to be a sort
s1 has been declared to be a sort
fc1 has been declared to be a Funconst

GETFOL:: declare funconst fc2 fc3 (s1 *)=s2;
s2 is a sort
s1 is a sort
* has been declared to be a sort
fc2 has been declared to be a Funconst
fc3 has been declared to be a Funconst

GETFOL:: declare funconst fp0 2 [ INF =34 234];
fp0 has been declared to be a Funconst

GETFOL:: declare funconst fp2 2 [inf];
fp2 has been declared to be a Funconst

GETFOL:: declare funpar fpar f 2;
fpar has been declared to be a Funpar
f has been declared to be a Funpar

GETFOL:: declare funpar f1  (ss2 s3)= s4;
s4 has been declared to be a sort
ss2 has been declared to be a sort
s3 has been declared to be a sort
f1 has been declared to be a Funpar

GETFOL:: declare predpar p1 3;
p1 has been declared to be a Predpar

GETFOL:: declare sort a s d gf hg;
a has been declared to be a sort
s has been declared to be a sort
d has been declared to be a sort
gf has been declared to be a sort
hg has been declared to be a sort

GETFOL:: declare sort a bb cc;
a is a sort
bb has been declared to be a sort
cc has been declared to be a sort

GETFOL:: wff p1(ic1 ip1 iv1) and a(ic2) and s(ic3) and d(ic4);
((p1(ic1, ip1, iv1) and a(ic2)) and s(ic3)) and d(ic4) is a <wff>.

GETFOL:: mostgeneral MG1;
MG1 has been declared to be a sort
MG1 is now equivalent to UNIVERSAL

GETFOL:: s3 is a sort
s1 is a sort
s2 is a sort

GETFOL:: declare sort s11 s12 s13 s14;
s11 has been declared to be a sort
s12 has been declared to be a sort
s13 has been declared to be a sort
s14 has been declared to be a sort

GETFOL:: moregeneral s1 < s11 s12 s13 s14 >;

GETFOL:: moregeneral s11 < s12 s13 s14 >;

GETFOL:: moregeneral s12 < s13 s14 >;

GETFOL:: moregeneral s13 < s14 >;

GETFOL:: moregeneral s14 < s1 >;
You realise that this makes equivalent s14 and s1

GETFOL:: declare funconst equ1 1;
equ1 has been declared to be a Funconst

GETFOL:: declare funconst equ2 2;
equ2 has been declared to be a Funconst

GETFOL:: declare funconst equ3 3;
equ3 has been declared to be a Funconst

GETFOL:: declare funconst qqq1 1 [pre];
qqq1 has been declared to be a Funconst

GETFOL:: declare funconst qqq3 2 [inf];
qqq3 has been declared to be a Funconst

GETFOL:: declare predconst Pequ1 1;
Pequ1 has been declared to be a Predconst

GETFOL:: declare predconst Pequ2 2;
Pequ2 has been declared to be a Predconst

GETFOL:: declare predconst Pequ3 3;
Pequ3 has been declared to be a Predconst

GETFOL:: declare predconst Pqqq1 1 [pre];
Pqqq1 has been declared to be a Predconst

GETFOL:: declare predconst Pqqq3 2 [inf];
Pqqq3 has been declared to be a Predconst

GETFOL:: show typ sentconst;

The symbols declared to be Sentconsts are

    sc3  sc2  sc1  FALSE  TRUE  

GETFOL:: show typ sentpar;

The symbols declared to be Sentpars are

    sp3  sp2  sp1  

GETFOL:: show typ indconst;

The symbols declared to be Indconsts are

    ic4  ic3  ic2  ic1  

GETFOL:: show typ indvar;

The symbols declared to be Indvars are

    iv4  iv3  iv2  iv1  

GETFOL:: show typ indpar;

The symbols declared to be Indpars are

    ip4  ip3  ip2  ip1  

GETFOL:: show typ funconst;

The symbols declared to be Funconsts are

    qqq3  qqq1  equ3  equ2  equ1  fp2  fp0  fc3  fc2  fc1  fc4  

GETFOL:: show typ funpar;

The symbols declared to be Funpars are

    f1  f  fpar  

GETFOL:: show typ predconst;

The symbols declared to be Predconsts are

    Pqqq3  Pqqq1  Pequ3  Pequ2  Pequ1  s14  s13  s12  s11  MG1  cc  bb  hg  gf  d  s  a  s3  ss2  s4  *  s1  s2  siv  sip  sic  MG  UNIVERSAL  =  

GETFOL:: show typ predpar;

The only symbol declared to be a Predpar is p1

GETFOL:: show sort;

The symbols declared to be sorts are

    s14  s13  s12  s11  MG1  cc  bb  hg  gf  d  s  a  s3  ss2  s4  *  s1  s2  siv  sip  sic  MG  UNIVERSAL  

GETFOL:: makecontext DECL2;
You have created the empty context: DECL2

GETFOL:: switchcontext DECL2;
You are now using context: DECL2
You are switching to a proof with no name.

GETFOL:: switchcontext DECL1;
You are now using context: DECL1
You are switching to a proof with no name.

GETFOL:: show typ sentconst;

The symbols declared to be Sentconsts are

    sc3  sc2  sc1  FALSE  TRUE  

GETFOL:: show typ sentpar;

The symbols declared to be Sentpars are

    sp3  sp2  sp1  

GETFOL:: show typ indconst;

The symbols declared to be Indconsts are

    ic4  ic3  ic2  ic1  

GETFOL:: show typ indvar;

The symbols declared to be Indvars are

    iv4  iv3  iv2  iv1  

GETFOL:: show typ indpar;

The symbols declared to be Indpars are

    ip4  ip3  ip2  ip1  

GETFOL:: show typ funconst;

The symbols declared to be Funconsts are

    qqq3  qqq1  equ3  equ2  equ1  fp2  fp0  fc3  fc2  fc1  fc4  

GETFOL:: show typ funpar;

The symbols declared to be Funpars are

    f1  f  fpar  

GETFOL:: show typ predconst;

The symbols declared to be Predconsts are

    Pqqq3  Pqqq1  Pequ3  Pequ2  Pequ1  s14  s13  s12  s11  MG1  cc  bb  hg  gf  d  s  a  s3  ss2  s4  *  s1  s2  siv  sip  sic  MG  UNIVERSAL  =  

GETFOL:: show typ predpar;

The only symbol declared to be a Predpar is p1

GETFOL:: show sort;

The symbols declared to be sorts are

    s14  s13  s12  s11  MG1  cc  bb  hg  gf  d  s  a  s3  ss2  s4  *  s1  s2  siv  sip  sic  MG  UNIVERSAL  

GETFOL:: I am finished fetching lang/declare.tst

GETFOL:: 	reset;
Resetting the whole GETFOL-system

GETFOL:: 	fetch lang/exp1.tst;
I am starting to fetch lang/exp1.tst

GETFOL:: DECLARE INDVAR x y z;
UNIVERSAL is a sort
x has been declared to be an Indvar
y has been declared to be an Indvar
z has been declared to be an Indvar

GETFOL:: DECLARE INDCONST a b c;
UNIVERSAL is a sort
a has been declared to be an Indconst
b has been declared to be an Indconst
c has been declared to be an Indconst

GETFOL:: DECLARE PREDCONST P 1;
P has been declared to be a Predconst

GETFOL:: DECLARE PREDCONST Q 1 [pre];
Q has been declared to be a Predconst

GETFOL:: DECLARE PREDCONST R 2 [inf];
R has been declared to be a Predconst

GETFOL:: DECLARE FUNCONST f 1;
f has been declared to be a Funconst

GETFOL:: DECLARE FUNCONST f1 1 [pre = 500];
f1 has been declared to be a Funconst

GETFOL:: DECLARE FUNCONST g 2;
g has been declared to be a Funconst

GETFOL:: DECLARE FUNCONST g1 2 [inf = 400 405];
g1 has been declared to be a Funconst

GETFOL:: DECLARE FUNCONST g2 2 [inf = 605 600];
g2 has been declared to be a Funconst

GETFOL:: SIMPLIFY a g1 b g1 c =  g1(g1(a,b),c);

1   ((a g1 b) g1 c) = ((a g1 b) g1 c)     

GETFOL:: SIMPLIFY a g2 b g2 c =  g2(a,g2(b,c));

2   (a g2 (b g2 c)) = (a g2 (b g2 c))     

GETFOL:: SIMPLIFY f1 a g1 b = g1(f1(a),b);

3   ((f1 a) g1 b) = ((f1 a) g1 b)     

GETFOL:: SIMPLIFY f1 a g2 b = f1(g2(a,b));

4   (f1 (a g2 b)) = (f1 (a g2 b))     

GETFOL:: SIMPLIFY a g1 b g2 c = g1(a,g2(b,c));

5   (a g1 (b g2 c)) = (a g1 (b g2 c))     

GETFOL:: SIMPLIFY (a g1 b) g2 c = g2(g1(a,b),c);

6   ((a g1 b) g2 c) = ((a g1 b) g2 c)     

GETFOL:: TAUT (forall x y. (exists z. (a g1 z R z g2 a and Q x g1 z g2 y) or
                   forall z. not Q z))
     iff
     (forall x. (forall y.
        (exists z. (R(g1(a,z),g2(z,a)) and Q(g1(x,g2(z,y))))
        or
        (forall z. (not (Q(z))) )) ));

7   forall x y. (exists z. (((a g1 z) R (z g2 a)) and (Q (x g1 (z g2 y)))) or forall z. (not (Q z))) iff forall x y. (exists z. (((a g1 z) R (z g2 a)) and (Q (x g1 (z g2 y)))) or forall z. (not (Q z)))     

GETFOL:: AXIOM A1: P(g(f(x),f(y))) and forall z. R(g(f(x),f(y)), g(z,y));

A1 : P(g(f(x), f(y))) and forall z. (g(f(x), f(y)) R g(z, y))

GETFOL:: ALLI A1 x;

8   forall x. (P(g(f(x), f(y))) and forall z. (g(f(x), f(y)) R g(z, y)))     

GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: EXISTI A1 f(x):x;

9   exists x. (P(g(x, f(y))) and forall z. (g(x, f(y)) R g(z, y)))     

GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: EXISTI A1 f(x):z OCC 1;

10   exists z. (P(g(z, f(y))) and forall z. (g(f(x), f(y)) R g(z, y)))     

GETFOL:: I am finished fetching lang/exp1.tst

GETFOL:: 	reset;
Resetting the whole GETFOL-system

GETFOL:: 	fetch lang/exp2.tst;
I am starting to fetch lang/exp2.tst

GETFOL:: DECLARE INDVAR x y;
UNIVERSAL is a sort
x has been declared to be an Indvar
y has been declared to be an Indvar

GETFOL:: DECLARE INDPAR a;
UNIVERSAL is a sort
a has been declared to be an Indpar

GETFOL:: DECLARE INDCONST alpha;
UNIVERSAL is a sort
alpha has been declared to be an Indconst

GETFOL:: DECLARE PREDCONST P 1 [pre];
P has been declared to be a Predconst

GETFOL:: DECLARE PREDCONST R 2;
R has been declared to be a Predconst

GETFOL:: DECLARE FUNCONST f 1;
f has been declared to be a Funconst

GETFOL:: DECLARE FUNCONST f1 1 [pre = 500];
f1 has been declared to be a Funconst

GETFOL:: DECLARE FUNCONST g 2;
g has been declared to be a Funconst

GETFOL:: DECLARE FUNCONST g1 2 [inf = 400 405];
g1 has been declared to be a Funconst

GETFOL:: DECLARE FUNCONST g2 2 [inf = 605 600];
g2 has been declared to be a Funconst

GETFOL:: TERM g(f(x),y);
g(f(x), y) is a <term>.

GETFOL:: TERM a g1 f1 x g2 f1 y g1 alpha;
(a g1 (f1 (x g2 (f1 y)))) g1 alpha is a <term>.

GETFOL:: AWFF x = y;
x = y is an <awff>.

GETFOL:: AWFF P g(f(x),y);
P g(f(x), y) is an <awff>.

GETFOL:: AWFF R(g(f(x),y), a g1 f1 x g2 f1 y g1 alpha);
R(g(f(x), y), (a g1 (f1 (x g2 (f1 y)))) g1 alpha) is an <awff>.

GETFOL:: WFF P g(f(x),y) and x = y;
(P g(f(x), y)) and (x = y) is a <wff>.

GETFOL:: WFF exists x y . (P g(f(x),y) and x = y);
exists x y. ((P g(f(x), y)) and (x = y)) is a <wff>.

GETFOL:: TERM trmif x = y then f(x) else f(y);
trmif (x = y) then f(x) else f(y) is a <term>.

GETFOL:: AWFF P trmif x = y then f(x) else f(y);
P (trmif (x = y) then f(x) else f(y)) is an <awff>.

GETFOL:: WFF forall x y. wffif P trmif x = y then f(x) else f(y)
                then R(x,y)
                else R(y,x);
forall x y. (wffif (P (trmif (x = y) then f(x) else f(y))) then R(x, y) else R(y, x)) is a <wff>.

GETFOL:: I am finished fetching lang/exp2.tst

GETFOL:: 	reset;
Resetting the whole GETFOL-system

GETFOL:: 
GETFOL:: 	fetch meta/mattach.tst;
I am starting to fetch meta/mattach.tst

GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: namecontext META;
You have named the current context: META

GETFOL:: nameproof P1;
You have named the current proof: P1

GETFOL:: declare indconst sc [SENTCONST];
SENTCONST has been declared to be a sort
sc has been declared to be an Indconst

GETFOL:: declare indconst ic [INDCONST];
INDCONST has been declared to be a sort
ic has been declared to be an Indconst

GETFOL:: declare indconst vl [FACT];
FACT has been declared to be a sort
vl has been declared to be an Indconst

GETFOL:: declare indconst f1 [FACT];
FACT is a sort
f1 has been declared to be an Indconst

GETFOL:: DECREP  SENTCONST INDCONST FACT;

GETFOL:: represent { SENTCONST } as SENTCONST;

GETFOL:: represent { INDCONST } as INDCONST;

GETFOL:: represent { FACT } as FACT;

GETFOL:: makecontext C;
You have created the empty context: C

GETFOL:: switchcontext C;
You are now using context: C
You are switching to a proof with no name.

GETFOL:: declare indconst c;
UNIVERSAL is a sort
c has been declared to be an Indconst

GETFOL:: declare sentconst A;
A has been declared to be a Sentconst

GETFOL:: nameproof P1;
You have named the current proof: P1

GETFOL:: assume c=c;

1   c = c     (1)

GETFOL:: makeproof P2;
You have created the empty proof: P2

GETFOL:: switchproof P2;
You are now using the proof: P2

GETFOL:: assume A imp A;

1   A imp A     (1)

GETFOL:: label fact ax = 1;

GETFOL:: switchcontext META;
You are now using context: META
You are now using proof: P1

GETFOL:: ctext-get: I changed context to: C
ctext-get: I changed context to: META
MATTACH sc TO  C::SENTCONST:A;
sc attached to 'A

GETFOL:: ctext-get: I changed context to: C
ctext-get: I changed context to: META
MATTACH ic DAR C:P2:INDCONST:c;
ic attached to 'c
ic is the preferred name of c

GETFOL:: ctext-get: I changed context to: C
proof-get: I changed proof to: P1
proof-get: I changed proof to: P2
ctext-get: I changed context to: META
MATTACH vl DAR [SENTCONST] C:P1:FACT:1;
vl attached to '(1 (= c c) (1) ASSUME (%WFF% = c c))
vl is the preferred name of (1 (= c c) (1) ASSUME (%WFF% = c c))

GETFOL:: ctext-get: I changed context to: C
ctext-get: I changed context to: META
MATTACH f1 TO  C:P2:FACT:1;
f1 attached to '(1 (imp A A) (1) ASSUME (%WFF% imp A A))

GETFOL:: ctext-get: I changed context to: C
ctext-get: I changed context to: META
MATTACH f1 DAR C:P2:FACT:ax;
f1 attached to '(1 (imp A A) (1) ASSUME (%WFF% imp A A))
f1 is the preferred name of (1 (imp A A) (1) ASSUME (%WFF% imp A A))

GETFOL:: I am finished fetching meta/mattach.tst

GETFOL:: 	reset;
Resetting the whole GETFOL-system

GETFOL:: 	fetch meta/min.tst;
I am starting to fetch meta/min.tst

GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: PROBE ALL;

GETFOL:: 
GETFOL:: DEFLAM mkapplw1 (PREDSYM TERM) (appl1\-mak PREDSYM TERM);

GETFOL:: DEFLAM mkapplt1 (FUNSYM  TERM) (appl1\-mak FUNSYM TERM );

GETFOL:: DEFLAM minimasort (TERM) (QUOTE EXEXP);

GETFOL:: 
GETFOL:: DEFLAM isubstfree (FUNSYM1 FUNSYM2 TERM) (SUBST FUNSYM1 FUNSYM2 TERM);

GETFOL:: 
GETFOL:: NAMECONTEXT MTC;
You have named the current context: MTC

GETFOL:: DECLARE SORT ESEXP SEXP ENATNUM NATNUM;
ESEXP has been declared to be a sort
SEXP has been declared to be a sort
ENATNUM has been declared to be a sort
NATNUM has been declared to be a sort

GETFOL:: MAKECONTEXT META;
You have created the empty context: META

GETFOL:: 
GETFOL:: SWITCHCONTEXT META;
You are now using context: META
You are switching to a proof with no name.

GETFOL:: 
GETFOL:: DECLARE SORT 
	FOLSYM
	QUANT
	INDSYM INDVAR
	FUNSYM FUNCONST
	PREDSYM PREDCONST
	EXPR TERM WFF
	FACT;
FOLSYM has been declared to be a sort
QUANT has been declared to be a sort
INDSYM has been declared to be a sort
INDVAR has been declared to be a sort
FUNSYM has been declared to be a sort
FUNCONST has been declared to be a sort
PREDSYM has been declared to be a sort
PREDCONST has been declared to be a sort
EXPR has been declared to be a sort
TERM has been declared to be a sort
WFF has been declared to be a sort
FACT has been declared to be a sort

GETFOL:: DECLARE PREDCONST THEOREM 1;
THEOREM has been declared to be a Predconst

GETFOL:: MOREGENERAL TERM <INDVAR>;

GETFOL:: 
GETFOL:: DECREP QUANT   WFF  PREDSYM TERM      EXPR   INDVAR;

GETFOL:: DECREP METAREP FACT FUNSYM  PREDCONST FOLSYM INDSYM;

GETFOL:: 
GETFOL:: REPRESENT { QUANT   } AS QUANT;

GETFOL:: REPRESENT { WFF     } AS WFF;

GETFOL:: REPRESENT { PREDSYM } AS PREDSYM;

GETFOL:: REPRESENT { TERM    } AS TERM;

GETFOL:: REPRESENT { EXPR    } AS EXPR;

GETFOL:: REPRESENT { INDVAR  } AS INDVAR;

GETFOL:: REPRESENT { FACT    } AS FACT;

GETFOL:: REPRESENT {FUNSYM   } AS FUNSYM;

GETFOL:: REPRESENT {PREDCONST} AS PREDCONST;

GETFOL:: REPRESENT {FOLSYM   } AS FOLSYM ;

GETFOL:: REPRESENT {INDSYM   } AS INDSYM;

GETFOL:: 
GETFOL:: DECLARE INDCONST Forall [QUANT];
QUANT is a sort
Forall has been declared to be an Indconst

GETFOL:: DECLARE INDCONST Equal  [PREDCONST];
PREDCONST is a sort
Equal has been declared to be an Indconst

GETFOL:: DECLARE INDCONST Universal Esexp Sexp Enatnum Natnum [PREDCONST];
PREDCONST is a sort
Universal has been declared to be an Indconst
Esexp has been declared to be an Indconst
Sexp has been declared to be an Indconst
Enatnum has been declared to be an Indconst
Natnum has been declared to be an Indconst

GETFOL:: DECLARE INDCONST Mf [FUNSYM];
FUNSYM is a sort
Mf has been declared to be an Indconst

GETFOL:: DECLARE INDCONST Mvl [FACT];
FACT is a sort
Mvl has been declared to be an Indconst

GETFOL:: DECLARE INDVAR f g  [FUNSYM];
FUNSYM is a sort
f has been declared to be an Indvar
g has been declared to be an Indvar

GETFOL:: 	
DECLARE INDVAR i    [INDSYM];
INDSYM is a sort
i has been declared to be an Indvar

GETFOL:: DECLARE INDVAR x    [TERM];
TERM is a sort
x has been declared to be an Indvar

GETFOL:: DECLARE INDVAR t    [TERM];
TERM is a sort
t has been declared to be an Indvar

GETFOL:: DECLARE INDVAR w    [WFF];
WFF is a sort
w has been declared to be an Indvar

GETFOL:: DECLARE INDVAR vl vl1 vl2 [FACT];
FACT is a sort
vl has been declared to be an Indvar
vl1 has been declared to be an Indvar
vl2 has been declared to be an Indvar

GETFOL:: DECLARE FUNCONST mkimp    (WFF,WFF)=WFF;
WFF is a sort
WFF is a sort
WFF is a sort
mkimp has been declared to be a Funconst

GETFOL:: DECLARE FUNCONST mkand    (WFF,WFF)=WFF;
WFF is a sort
WFF is a sort
WFF is a sort
mkand has been declared to be a Funconst

GETFOL:: DECLARE FUNCONST mkquant  (QUANT,TERM,WFF)=WFF;
WFF is a sort
QUANT is a sort
TERM is a sort
WFF is a sort
mkquant has been declared to be a Funconst

GETFOL:: DECLARE FUNCONST mkapplt1 (FUNSYM,TERM)=TERM;
TERM is a sort
FUNSYM is a sort
TERM is a sort
mkapplt1 has been declared to be a Funconst

GETFOL:: DECLARE FUNCONST mkapplw1 (PREDCONST,TERM)=WFF;
WFF is a sort
PREDCONST is a sort
TERM is a sort
mkapplw1 has been declared to be a Funconst

GETFOL:: DECLARE FUNCONST minsubst (FUNSYM,FUNSYM,TERM)=TERM;
TERM is a sort
FUNSYM is a sort
FUNSYM is a sort
TERM is a sort
minsubst has been declared to be a Funconst

GETFOL:: DECLARE FUNCONST wffof    (FACT)=WFF;
WFF is a sort
FACT is a sort
wffof has been declared to be a Funconst

GETFOL:: DECLARE FUNCONST mainsym  (EXPR)=FOLSYM;
FOLSYM is a sort
EXPR is a sort
mainsym has been declared to be a Funconst

GETFOL:: DECLARE FUNCONST matrix   (WFF)=WFF;
WFF is a sort
WFF is a sort
matrix has been declared to be a Funconst

GETFOL:: DECLARE FUNCONST bvarof   (WFF)=TERM;
TERM is a sort
WFF is a sort
bvarof has been declared to be a Funconst

GETFOL:: DECLARE FUNCONST lhs rhs  (WFF)=TERM;
TERM is a sort
WFF is a sort
lhs has been declared to be a Funconst
rhs has been declared to be a Funconst

GETFOL:: DECLARE FUNCONST schema1  (FUNSYM,FUNSYM,TERM,TERM)=WFF;
WFF is a sort
FUNSYM is a sort
FUNSYM is a sort
TERM is a sort
TERM is a sort
schema1 has been declared to be a Funconst

GETFOL:: DECLARE FUNCONST defsort1 (FUNSYM,TERM)=PREDCONST;
PREDCONST is a sort
FUNSYM is a sort
TERM is a sort
defsort1 has been declared to be a Funconst

GETFOL:: DECLARE FUNCONST sort     (TERM)=PREDCONST;
PREDCONST is a sort
TERM is a sort
sort has been declared to be a Funconst

GETFOL:: DECLARE PREDCONST ISFUNDEF1 2;
ISFUNDEF1 has been declared to be a Predconst

GETFOL:: DECLARE FUNCONST pred2apply (PREDCONST TERM TERM)=WFF;
WFF is a sort
PREDCONST is a sort
TERM is a sort
TERM is a sort
pred2apply has been declared to be a Funconst

GETFOL:: HARDWARE Forall   dar [QUANT] Uniquant;
Forall attached to Uniquant
Forall is the preferred name of Uniquant

GETFOL:: ctext-get: I changed context to: MTC
ctext-get: I changed context to: META
MATTACH Equal     dar [PREDCONST] MTC::PREDCONST:=;
Equal attached to '=
Equal is the preferred name of =

GETFOL:: ctext-get: I changed context to: MTC
ctext-get: I changed context to: META
MATTACH Universal dar [PREDCONST] MTC::PREDCONST:UNIVERSAL;
Universal attached to 'UNIVERSAL
Universal is the preferred name of UNIVERSAL

GETFOL:: ctext-get: I changed context to: MTC
ctext-get: I changed context to: META
MATTACH Esexp     dar [PREDCONST] MTC::PREDCONST:ESEXP;
Esexp attached to 'ESEXP
Esexp is the preferred name of ESEXP

GETFOL:: ctext-get: I changed context to: MTC
ctext-get: I changed context to: META
MATTACH Sexp      dar [PREDCONST] MTC::PREDCONST:SEXP;
Sexp attached to 'SEXP
Sexp is the preferred name of SEXP

GETFOL:: ctext-get: I changed context to: MTC
ctext-get: I changed context to: META
MATTACH Enatnum   dar [PREDCONST] MTC::PREDCONST:ENATNUM;
Enatnum attached to 'ENATNUM
Enatnum is the preferred name of ENATNUM

GETFOL:: ctext-get: I changed context to: MTC
ctext-get: I changed context to: META
MATTACH Natnum    dar [PREDCONST] MTC::PREDCONST:NATNUM;
Natnum attached to 'NATNUM
Natnum is the preferred name of NATNUM

GETFOL:: ATTACH mkimp    TO  [WFF,WFF=WFF] mkimp;
mkimp attached to mkimp

GETFOL:: ATTACH mkand    TO  [WFF,WFF=WFF] mkand;
mkand attached to mkand

GETFOL:: ATTACH mkquant  TO  [QUANT,TERM,WFF=WFF] mkquant;
mkquant attached to mkquant

GETFOL::  
ATTACH pred2apply  TO  [PREDCONST,TERM,TERM=WFF] predappl2\-mak;
pred2apply attached to predappl2-mak

GETFOL:: ATTACH mkapplw1 TO [PREDCONST,TERM=WFF] mkapplw1;
mkapplw1 attached to mkapplw1

GETFOL::  
ATTACH mkapplt1 TO [FUNSYM,TERM=TERM] mkapplt1;
mkapplt1 attached to mkapplt1

GETFOL:: ATTACH minsubst TO [FUNSYM,FUNSYM,TERM=TERM] isubstfree;
minsubst attached to isubstfree

GETFOL:: ATTACH wffof	TO [FACT=WFF] fact\-get\-wff;
wffof attached to fact-get-wff

GETFOL:: ATTACH mainsym	TO [EXPR=FOLSYM] mainsym;
mainsym attached to mainsym

GETFOL:: ATTACH matrix	TO [WFF=WFF] matrix;
matrix attached to matrix

GETFOL:: ATTACH bvarof	TO [WFF=TERM] bvarof;
bvarof attached to bvarof

GETFOL:: ATTACH lhs	TO [WFF=TERM] lhs;
lhs attached to lhs

GETFOL:: ATTACH rhs	TO [WFF=TERM] rhs;
rhs attached to rhs

GETFOL:: ATTACH sort	TO [TERM=PREDCONST] minimasort;
sort attached to minimasort

GETFOL:: AXIOM DEF1:
 forall f g x t. (schema1(f,g,x,t) =
   mkimp(
    mkquant(Forall,x,
     mkimp(
      mkapplw1(defsort1(f,x),minsubst(g,f,t)),
      pred2apply (Equal mkapplt1(g,x),minsubst(g,f,t)))),
    mkquant(Forall,x,
     mkimp(
      mkapplw1(defsort1(f,x),mkapplt1(f,x)),
      pred2apply (Equal mkapplt1(g,x),mkapplt1(f,x)) )) ) );

DEF1 : forall f g x t. (schema1(f, g, x, t) = mkimp(mkquant(Forall, x, mkimp(mkapplw1(defsort1(f, x), minsubst(g, f, t)), pred2apply(Equal, mkapplt1(g, x), minsubst(g, f, t)))), mkquant(Forall, x, mkimp(mkapplw1(defsort1(f, x), mkapplt1(f, x)), pred2apply(Equal, mkapplt1(g, x), mkapplt1(f, x))))))

GETFOL:: AXIOM DEF2:    
 forall f x . defsort1(f,x) =
          trmif sort(mkapplt1(f,x)) = Esexp 
            then Sexp 
            else trmif sort(mkapplt1(f,x)) = Enatnum 
                   then Natnum 
		   else Universal;

DEF2 : forall f x. (defsort1(f, x) = (trmif (sort(mkapplt1(f, x)) = Esexp) then Sexp else (trmif (sort(mkapplt1(f, x)) = Enatnum) then Natnum else Universal)))

GETFOL:: 		 

AXIOM JMCMIN:
forall vl f g.(ISFUNDEF1(f,vl)   imp  
         THEOREM(schema1(f,g,bvarof(wffof(vl)),rhs(matrix(wffof(vl))))));

JMCMIN : forall vl f g. (ISFUNDEF1(f, vl) imp THEOREM(schema1(f, g, bvarof(wffof(vl)), rhs(matrix(wffof(vl))))))

GETFOL:: AXIOM FUNDEF: forall vl f.ISFUNDEF1(f,vl);

FUNDEF : forall vl f. ISFUNDEF1(f, vl)

GETFOL:: 
GETFOL:: 
GETFOL:: SWITCHCONTEXT MTC;
You are now using context: MTC
You are switching to a proof with no name.

GETFOL:: DECLARE INDCONST BOT [ESEXP];
ESEXP is a sort
BOT has been declared to be an Indconst

GETFOL:: DECLARE INDVAR X;
UNIVERSAL is a sort
X has been declared to be an Indvar

GETFOL::  
DECLARE INDVAR x y z [SEXP];
SEXP is a sort
x has been declared to be an Indvar
y has been declared to be an Indvar
z has been declared to be an Indvar

GETFOL:: DECLARE FUNCONST f g (ESEXP)=ESEXP;
ESEXP is a sort
ESEXP is a sort
f has been declared to be a Funconst
g has been declared to be a Funconst

GETFOL:: 
GETFOL:: ASSUME forall x . f(x)=f(x);

1   forall x. (f(x) = f(x))     (1)

GETFOL:: ASSUME forall x . g(x)=BOT;

2   forall x. (g(x) = BOT)     (2)

GETFOL:: ASSUME not SEXP(BOT);

3   not SEXP(BOT)     (3)

GETFOL:: 
GETFOL:: SWITCHCONTEXT META;
You are now using context: META
You are switching to a proof with no name.

GETFOL:: SETBASICSIMP meta\-axioms at facts {DEF1, DEF2, FUNDEF};

GETFOL:: SETCOMPSIMP EVALSS AT meta\-axioms;
Attention! EVALSS is already the label of a simpset.

GETFOL:: ctext-get: I changed context to: MTC
ctext-get: I changed context to: META
MATTACH Mf  DAR [FUNSYM] MTC::FUNSYM:f;
Mf attached to 'f
Mf is the preferred name of f

GETFOL:: ctext-get: I changed context to: MTC
ctext-get: I changed context to: META
MATTACH Mvl DAR [FACT] MTC::FACT:1;
Mvl attached to '(1 (forall x (= (f x) (f x))) (1) ASSUME
                  (%WFF% forall x (= (f x) (f x))))
Mvl is the preferred name of (1 (forall x (= (f x) (f x))) (1) ASSUME
                              (%WFF% forall x (= (f x) (f x))))

GETFOL:: 
GETFOL:: SWITCHCONTEXT MTC;
You are now using context: MTC
You are switching to a proof with no name.

GETFOL:: I am switching from the current context to: META
I am switching from the current context to: MTC
REFLECT JMCMIN 1 f g;
I am switching from the current context to: META
ISFUNDEF1(FUNSYM101, FACT100) imp THEOREM(schema1(FUNSYM101, FUNSYM102, bvarof(wffof(FACT100)), rhs(matrix(wffof(FACT100))))): syntactic simplification fails.
ISFUNDEF1 has no interpretation.
Syntactic simplification of ISFUNDEF1(FUNSYM101, FACT100) gives TRUE
Evaluating TRUE gives TRUE
Evaluating ISFUNDEF1(FUNSYM101, FACT100) gives TRUE
THEOREM has no interpretation.
THEOREM(schema1(FUNSYM101, FUNSYM102, bvarof(wffof(FACT100)), rhs(matrix(wffof(FACT100))))): syntactic simplification fails.
schema1 has no interpretation.
Syntactic simplification of schema1(FUNSYM101, FUNSYM102, bvarof(wffof(FACT100)), rhs(matrix(wffof(FACT100)))) gives mkimp(mkquant(Forall, bvarof(wffof(FACT100)), mkimp(mkapplw1(defsort1(FUNSYM101, bvarof(wffof(FACT100))), minsubst(FUNSYM102, FUNSYM101, rhs(matrix(wffof(FACT100))))), pred2apply(Equal, mkapplt1(FUNSYM102, bvarof(wffof(FACT100))), minsubst(FUNSYM102, FUNSYM101, rhs(matrix(wffof(FACT100))))))), mkquant(Forall, bvarof(wffof(FACT100)), mkimp(mkapplw1(defsort1(FUNSYM101, bvarof(wffof(FACT100))), mkapplt1(FUNSYM101, bvarof(wffof(FACT100)))), pred2apply(Equal, mkapplt1(FUNSYM102, bvarof(wffof(FACT100))), mkapplt1(FUNSYM101, bvarof(wffof(FACT100)))))))
Evaluating Forall gives Forall
Evaluating FACT100 gives FACT100
Evaluating wffof(FACT100) gives wffof(FACT100)
Evaluating bvarof(wffof(FACT100)) gives bvarof(wffof(FACT100))
defsort1 has no interpretation.
Syntactic simplification of defsort1(FUNSYM101, bvarof(wffof(FACT100))) gives trmif (sort(mkapplt1(FUNSYM101, bvarof(wffof(FACT100)))) = Esexp) then Sexp else (trmif (sort(mkapplt1(FUNSYM101, bvarof(wffof(FACT100)))) = Enatnum) then Natnum else Universal)
Evaluating FUNSYM101 gives FUNSYM101
Evaluating FACT100 gives FACT100
Evaluating wffof(FACT100) gives wffof(FACT100)
Evaluating bvarof(wffof(FACT100)) gives bvarof(wffof(FACT100))
Evaluating mkapplt1(FUNSYM101, bvarof(wffof(FACT100))) gives mkapplt1(FUNSYM101, bvarof(wffof(FACT100)))
Evaluating sort(mkapplt1(FUNSYM101, bvarof(wffof(FACT100)))) gives sort(mkapplt1(FUNSYM101, bvarof(wffof(FACT100))))
Evaluating Esexp gives Esexp
Evaluating sort(mkapplt1(FUNSYM101, bvarof(wffof(FACT100)))) = Esexp gives FALSE
Evaluating FUNSYM101 gives FUNSYM101
Evaluating FACT100 gives FACT100
Evaluating wffof(FACT100) gives wffof(FACT100)
Evaluating bvarof(wffof(FACT100)) gives bvarof(wffof(FACT100))
Evaluating mkapplt1(FUNSYM101, bvarof(wffof(FACT100))) gives mkapplt1(FUNSYM101, bvarof(wffof(FACT100)))
Evaluating sort(mkapplt1(FUNSYM101, bvarof(wffof(FACT100)))) gives sort(mkapplt1(FUNSYM101, bvarof(wffof(FACT100))))
Evaluating Enatnum gives Enatnum
Evaluating sort(mkapplt1(FUNSYM101, bvarof(wffof(FACT100)))) = Enatnum gives FALSE
Evaluating Universal gives Universal
Evaluating trmif (sort(mkapplt1(FUNSYM101, bvarof(wffof(FACT100)))) = Enatnum) then Natnum else Universal gives Universal
Evaluating trmif (sort(mkapplt1(FUNSYM101, bvarof(wffof(FACT100)))) = Esexp) then Sexp else (trmif (sort(mkapplt1(FUNSYM101, bvarof(wffof(FACT100)))) = Enatnum) then Natnum else Universal) gives Universal
Evaluating defsort1(FUNSYM101, bvarof(wffof(FACT100))) gives Universal
Evaluating FUNSYM102 gives FUNSYM102
Evaluating FUNSYM101 gives FUNSYM101
Evaluating FACT100 gives FACT100
Evaluating wffof(FACT100) gives wffof(FACT100)
Evaluating matrix(wffof(FACT100)) gives matrix(wffof(FACT100))
Evaluating rhs(matrix(wffof(FACT100))) gives rhs(matrix(wffof(FACT100)))
Evaluating minsubst(FUNSYM102, FUNSYM101, rhs(matrix(wffof(FACT100)))) gives minsubst(FUNSYM102, FUNSYM101, rhs(matrix(wffof(FACT100))))
Evaluating mkapplw1(defsort1(FUNSYM101, bvarof(wffof(FACT100))), minsubst(FUNSYM102, FUNSYM101, rhs(matrix(wffof(FACT100))))) gives mkapplw1(Universal, minsubst(FUNSYM102, FUNSYM101, rhs(matrix(wffof(FACT100)))))
Evaluating Equal gives Equal
Evaluating FUNSYM102 gives FUNSYM102
Evaluating FACT100 gives FACT100
Evaluating wffof(FACT100) gives wffof(FACT100)
Evaluating bvarof(wffof(FACT100)) gives bvarof(wffof(FACT100))
Evaluating mkapplt1(FUNSYM102, bvarof(wffof(FACT100))) gives mkapplt1(FUNSYM102, bvarof(wffof(FACT100)))
Evaluating FUNSYM102 gives FUNSYM102
Evaluating FUNSYM101 gives FUNSYM101
Evaluating FACT100 gives FACT100
Evaluating wffof(FACT100) gives wffof(FACT100)
Evaluating matrix(wffof(FACT100)) gives matrix(wffof(FACT100))
Evaluating rhs(matrix(wffof(FACT100))) gives rhs(matrix(wffof(FACT100)))
Evaluating minsubst(FUNSYM102, FUNSYM101, rhs(matrix(wffof(FACT100)))) gives minsubst(FUNSYM102, FUNSYM101, rhs(matrix(wffof(FACT100))))
Evaluating pred2apply(Equal, mkapplt1(FUNSYM102, bvarof(wffof(FACT100))), minsubst(FUNSYM102, FUNSYM101, rhs(matrix(wffof(FACT100))))) gives pred2apply(Equal, mkapplt1(FUNSYM102, bvarof(wffof(FACT100))), minsubst(FUNSYM102, FUNSYM101, rhs(matrix(wffof(FACT100)))))
Evaluating mkimp(mkapplw1(defsort1(FUNSYM101, bvarof(wffof(FACT100))), minsubst(FUNSYM102, FUNSYM101, rhs(matrix(wffof(FACT100))))), pred2apply(Equal, mkapplt1(FUNSYM102, bvarof(wffof(FACT100))), minsubst(FUNSYM102, FUNSYM101, rhs(matrix(wffof(FACT100)))))) gives mkimp(mkapplw1(Universal, minsubst(FUNSYM102, FUNSYM101, rhs(matrix(wffof(FACT100))))), pred2apply(Equal, mkapplt1(FUNSYM102, bvarof(wffof(FACT100))), minsubst(FUNSYM102, FUNSYM101, rhs(matrix(wffof(FACT100))))))
Evaluating mkquant(Forall, bvarof(wffof(FACT100)), mkimp(mkapplw1(defsort1(FUNSYM101, bvarof(wffof(FACT100))), minsubst(FUNSYM102, FUNSYM101, rhs(matrix(wffof(FACT100))))), pred2apply(Equal, mkapplt1(FUNSYM102, bvarof(wffof(FACT100))), minsubst(FUNSYM102, FUNSYM101, rhs(matrix(wffof(FACT100))))))) gives mkquant(Forall, bvarof(wffof(FACT100)), mkimp(mkapplw1(Universal, minsubst(FUNSYM102, FUNSYM101, rhs(matrix(wffof(FACT100))))), pred2apply(Equal, mkapplt1(FUNSYM102, bvarof(wffof(FACT100))), minsubst(FUNSYM102, FUNSYM101, rhs(matrix(wffof(FACT100)))))))
Evaluating Forall gives Forall
Evaluating FACT100 gives FACT100
Evaluating wffof(FACT100) gives wffof(FACT100)
Evaluating bvarof(wffof(FACT100)) gives bvarof(wffof(FACT100))
defsort1 has no interpretation.
Syntactic simplification of defsort1(FUNSYM101, bvarof(wffof(FACT100))) gives trmif (sort(mkapplt1(FUNSYM101, bvarof(wffof(FACT100)))) = Esexp) then Sexp else (trmif (sort(mkapplt1(FUNSYM101, bvarof(wffof(FACT100)))) = Enatnum) then Natnum else Universal)
Evaluating FUNSYM101 gives FUNSYM101
Evaluating FACT100 gives FACT100
Evaluating wffof(FACT100) gives wffof(FACT100)
Evaluating bvarof(wffof(FACT100)) gives bvarof(wffof(FACT100))
Evaluating mkapplt1(FUNSYM101, bvarof(wffof(FACT100))) gives mkapplt1(FUNSYM101, bvarof(wffof(FACT100)))
Evaluating sort(mkapplt1(FUNSYM101, bvarof(wffof(FACT100)))) gives sort(mkapplt1(FUNSYM101, bvarof(wffof(FACT100))))
Evaluating Esexp gives Esexp
Evaluating sort(mkapplt1(FUNSYM101, bvarof(wffof(FACT100)))) = Esexp gives FALSE
Evaluating FUNSYM101 gives FUNSYM101
Evaluating FACT100 gives FACT100
Evaluating wffof(FACT100) gives wffof(FACT100)
Evaluating bvarof(wffof(FACT100)) gives bvarof(wffof(FACT100))
Evaluating mkapplt1(FUNSYM101, bvarof(wffof(FACT100))) gives mkapplt1(FUNSYM101, bvarof(wffof(FACT100)))
Evaluating sort(mkapplt1(FUNSYM101, bvarof(wffof(FACT100)))) gives sort(mkapplt1(FUNSYM101, bvarof(wffof(FACT100))))
Evaluating Enatnum gives Enatnum
Evaluating sort(mkapplt1(FUNSYM101, bvarof(wffof(FACT100)))) = Enatnum gives FALSE
Evaluating Universal gives Universal
Evaluating trmif (sort(mkapplt1(FUNSYM101, bvarof(wffof(FACT100)))) = Enatnum) then Natnum else Universal gives Universal
Evaluating trmif (sort(mkapplt1(FUNSYM101, bvarof(wffof(FACT100)))) = Esexp) then Sexp else (trmif (sort(mkapplt1(FUNSYM101, bvarof(wffof(FACT100)))) = Enatnum) then Natnum else Universal) gives Universal
Evaluating defsort1(FUNSYM101, bvarof(wffof(FACT100))) gives Universal
Evaluating FUNSYM101 gives FUNSYM101
Evaluating FACT100 gives FACT100
Evaluating wffof(FACT100) gives wffof(FACT100)
Evaluating bvarof(wffof(FACT100)) gives bvarof(wffof(FACT100))
Evaluating mkapplt1(FUNSYM101, bvarof(wffof(FACT100))) gives mkapplt1(FUNSYM101, bvarof(wffof(FACT100)))
Evaluating mkapplw1(defsort1(FUNSYM101, bvarof(wffof(FACT100))), mkapplt1(FUNSYM101, bvarof(wffof(FACT100)))) gives mkapplw1(Universal, mkapplt1(FUNSYM101, bvarof(wffof(FACT100))))
Evaluating Equal gives Equal
Evaluating FUNSYM102 gives FUNSYM102
Evaluating FACT100 gives FACT100
Evaluating wffof(FACT100) gives wffof(FACT100)
Evaluating bvarof(wffof(FACT100)) gives bvarof(wffof(FACT100))
Evaluating mkapplt1(FUNSYM102, bvarof(wffof(FACT100))) gives mkapplt1(FUNSYM102, bvarof(wffof(FACT100)))
Evaluating FUNSYM101 gives FUNSYM101
Evaluating FACT100 gives FACT100
Evaluating wffof(FACT100) gives wffof(FACT100)
Evaluating bvarof(wffof(FACT100)) gives bvarof(wffof(FACT100))
Evaluating mkapplt1(FUNSYM101, bvarof(wffof(FACT100))) gives mkapplt1(FUNSYM101, bvarof(wffof(FACT100)))
Evaluating pred2apply(Equal, mkapplt1(FUNSYM102, bvarof(wffof(FACT100))), mkapplt1(FUNSYM101, bvarof(wffof(FACT100)))) gives pred2apply(Equal, mkapplt1(FUNSYM102, bvarof(wffof(FACT100))), mkapplt1(FUNSYM101, bvarof(wffof(FACT100))))
Evaluating mkimp(mkapplw1(defsort1(FUNSYM101, bvarof(wffof(FACT100))), mkapplt1(FUNSYM101, bvarof(wffof(FACT100)))), pred2apply(Equal, mkapplt1(FUNSYM102, bvarof(wffof(FACT100))), mkapplt1(FUNSYM101, bvarof(wffof(FACT100))))) gives mkimp(mkapplw1(Universal, mkapplt1(FUNSYM101, bvarof(wffof(FACT100)))), pred2apply(Equal, mkapplt1(FUNSYM102, bvarof(wffof(FACT100))), mkapplt1(FUNSYM101, bvarof(wffof(FACT100)))))
Evaluating mkquant(Forall, bvarof(wffof(FACT100)), mkimp(mkapplw1(defsort1(FUNSYM101, bvarof(wffof(FACT100))), mkapplt1(FUNSYM101, bvarof(wffof(FACT100)))), pred2apply(Equal, mkapplt1(FUNSYM102, bvarof(wffof(FACT100))), mkapplt1(FUNSYM101, bvarof(wffof(FACT100)))))) gives mkquant(Forall, bvarof(wffof(FACT100)), mkimp(mkapplw1(Universal, mkapplt1(FUNSYM101, bvarof(wffof(FACT100)))), pred2apply(Equal, mkapplt1(FUNSYM102, bvarof(wffof(FACT100))), mkapplt1(FUNSYM101, bvarof(wffof(FACT100))))))
Evaluating mkimp(mkquant(Forall, bvarof(wffof(FACT100)), mkimp(mkapplw1(defsort1(FUNSYM101, bvarof(wffof(FACT100))), minsubst(FUNSYM102, FUNSYM101, rhs(matrix(wffof(FACT100))))), pred2apply(Equal, mkapplt1(FUNSYM102, bvarof(wffof(FACT100))), minsubst(FUNSYM102, FUNSYM101, rhs(matrix(wffof(FACT100))))))), mkquant(Forall, bvarof(wffof(FACT100)), mkimp(mkapplw1(defsort1(FUNSYM101, bvarof(wffof(FACT100))), mkapplt1(FUNSYM101, bvarof(wffof(FACT100)))), pred2apply(Equal, mkapplt1(FUNSYM102, bvarof(wffof(FACT100))), mkapplt1(FUNSYM101, bvarof(wffof(FACT100))))))) gives mkimp(mkquant(Forall, bvarof(wffof(FACT100)), mkimp(mkapplw1(Universal, minsubst(FUNSYM102, FUNSYM101, rhs(matrix(wffof(FACT100))))), pred2apply(Equal, mkapplt1(FUNSYM102, bvarof(wffof(FACT100))), minsubst(FUNSYM102, FUNSYM101, rhs(matrix(wffof(FACT100))))))), mkquant(Forall, bvarof(wffof(FACT100)), mkimp(mkapplw1(Universal, mkapplt1(FUNSYM101, bvarof(wffof(FACT100)))), pred2apply(Equal, mkapplt1(FUNSYM102, bvarof(wffof(FACT100))), mkapplt1(FUNSYM101, bvarof(wffof(FACT100)))))))
Evaluating schema1(FUNSYM101, FUNSYM102, bvarof(wffof(FACT100)), rhs(matrix(wffof(FACT100)))) gives mkimp(mkquant(Forall, bvarof(wffof(FACT100)), mkimp(mkapplw1(Universal, minsubst(FUNSYM102, FUNSYM101, rhs(matrix(wffof(FACT100))))), pred2apply(Equal, mkapplt1(FUNSYM102, bvarof(wffof(FACT100))), minsubst(FUNSYM102, FUNSYM101, rhs(matrix(wffof(FACT100))))))), mkquant(Forall, bvarof(wffof(FACT100)), mkimp(mkapplw1(Universal, mkapplt1(FUNSYM101, bvarof(wffof(FACT100)))), pred2apply(Equal, mkapplt1(FUNSYM102, bvarof(wffof(FACT100))), mkapplt1(FUNSYM101, bvarof(wffof(FACT100)))))))
Evaluating THEOREM(schema1(FUNSYM101, FUNSYM102, bvarof(wffof(FACT100)), rhs(matrix(wffof(FACT100))))) doesn' t work
THEOREM(mkimp(mkquant(Forall, bvarof(wffof(FACT100)), mkimp(mkapplw1(Universal, minsubst(FUNSYM102, FUNSYM101, rhs(matrix(wffof(FACT100))))), pred2apply(Equal, mkapplt1(FUNSYM102, bvarof(wffof(FACT100))), minsubst(FUNSYM102, FUNSYM101, rhs(matrix(wffof(FACT100))))))), mkquant(Forall, bvarof(wffof(FACT100)), mkimp(mkapplw1(Universal, mkapplt1(FUNSYM101, bvarof(wffof(FACT100)))), pred2apply(Equal, mkapplt1(FUNSYM102, bvarof(wffof(FACT100))), mkapplt1(FUNSYM101, bvarof(wffof(FACT100)))))))): syntactic simplification fails.
THEOREM(mkimp(mkquant(Forall, bvarof(wffof(FACT100)), mkimp(mkapplw1(Universal, minsubst(FUNSYM102, FUNSYM101, rhs(matrix(wffof(FACT100))))), pred2apply(Equal, mkapplt1(FUNSYM102, bvarof(wffof(FACT100))), minsubst(FUNSYM102, FUNSYM101, rhs(matrix(wffof(FACT100))))))), mkquant(Forall, bvarof(wffof(FACT100)), mkimp(mkapplw1(Universal, mkapplt1(FUNSYM101, bvarof(wffof(FACT100)))), pred2apply(Equal, mkapplt1(FUNSYM102, bvarof(wffof(FACT100))), mkapplt1(FUNSYM101, bvarof(wffof(FACT100)))))))): syntactic simplification fails.
Evaluating Forall gives Forall
Evaluating FACT100 gives FACT100
Evaluating wffof(FACT100) gives wffof(FACT100)
Evaluating bvarof(wffof(FACT100)) gives bvarof(wffof(FACT100))
Evaluating Universal gives Universal
Evaluating FUNSYM102 gives FUNSYM102
Evaluating FUNSYM101 gives FUNSYM101
Evaluating FACT100 gives FACT100
Evaluating wffof(FACT100) gives wffof(FACT100)
Evaluating matrix(wffof(FACT100)) gives matrix(wffof(FACT100))
Evaluating rhs(matrix(wffof(FACT100))) gives rhs(matrix(wffof(FACT100)))
Evaluating minsubst(FUNSYM102, FUNSYM101, rhs(matrix(wffof(FACT100)))) gives minsubst(FUNSYM102, FUNSYM101, rhs(matrix(wffof(FACT100))))
Evaluating mkapplw1(Universal, minsubst(FUNSYM102, FUNSYM101, rhs(matrix(wffof(FACT100))))) gives mkapplw1(Universal, minsubst(FUNSYM102, FUNSYM101, rhs(matrix(wffof(FACT100)))))
Evaluating Equal gives Equal
Evaluating FUNSYM102 gives FUNSYM102
Evaluating FACT100 gives FACT100
Evaluating wffof(FACT100) gives wffof(FACT100)
Evaluating bvarof(wffof(FACT100)) gives bvarof(wffof(FACT100))
Evaluating mkapplt1(FUNSYM102, bvarof(wffof(FACT100))) gives mkapplt1(FUNSYM102, bvarof(wffof(FACT100)))
Evaluating FUNSYM102 gives FUNSYM102
Evaluating FUNSYM101 gives FUNSYM101
Evaluating FACT100 gives FACT100
Evaluating wffof(FACT100) gives wffof(FACT100)
Evaluating matrix(wffof(FACT100)) gives matrix(wffof(FACT100))
Evaluating rhs(matrix(wffof(FACT100))) gives rhs(matrix(wffof(FACT100)))
Evaluating minsubst(FUNSYM102, FUNSYM101, rhs(matrix(wffof(FACT100)))) gives minsubst(FUNSYM102, FUNSYM101, rhs(matrix(wffof(FACT100))))
Evaluating pred2apply(Equal, mkapplt1(FUNSYM102, bvarof(wffof(FACT100))), minsubst(FUNSYM102, FUNSYM101, rhs(matrix(wffof(FACT100))))) gives pred2apply(Equal, mkapplt1(FUNSYM102, bvarof(wffof(FACT100))), minsubst(FUNSYM102, FUNSYM101, rhs(matrix(wffof(FACT100)))))
Evaluating mkimp(mkapplw1(Universal, minsubst(FUNSYM102, FUNSYM101, rhs(matrix(wffof(FACT100))))), pred2apply(Equal, mkapplt1(FUNSYM102, bvarof(wffof(FACT100))), minsubst(FUNSYM102, FUNSYM101, rhs(matrix(wffof(FACT100)))))) gives mkimp(mkapplw1(Universal, minsubst(FUNSYM102, FUNSYM101, rhs(matrix(wffof(FACT100))))), pred2apply(Equal, mkapplt1(FUNSYM102, bvarof(wffof(FACT100))), minsubst(FUNSYM102, FUNSYM101, rhs(matrix(wffof(FACT100))))))
Evaluating mkquant(Forall, bvarof(wffof(FACT100)), mkimp(mkapplw1(Universal, minsubst(FUNSYM102, FUNSYM101, rhs(matrix(wffof(FACT100))))), pred2apply(Equal, mkapplt1(FUNSYM102, bvarof(wffof(FACT100))), minsubst(FUNSYM102, FUNSYM101, rhs(matrix(wffof(FACT100))))))) gives mkquant(Forall, bvarof(wffof(FACT100)), mkimp(mkapplw1(Universal, minsubst(FUNSYM102, FUNSYM101, rhs(matrix(wffof(FACT100))))), pred2apply(Equal, mkapplt1(FUNSYM102, bvarof(wffof(FACT100))), minsubst(FUNSYM102, FUNSYM101, rhs(matrix(wffof(FACT100)))))))
Evaluating Forall gives Forall
Evaluating FACT100 gives FACT100
Evaluating wffof(FACT100) gives wffof(FACT100)
Evaluating bvarof(wffof(FACT100)) gives bvarof(wffof(FACT100))
Evaluating Universal gives Universal
Evaluating FUNSYM101 gives FUNSYM101
Evaluating FACT100 gives FACT100
Evaluating wffof(FACT100) gives wffof(FACT100)
Evaluating bvarof(wffof(FACT100)) gives bvarof(wffof(FACT100))
Evaluating mkapplt1(FUNSYM101, bvarof(wffof(FACT100))) gives mkapplt1(FUNSYM101, bvarof(wffof(FACT100)))
Evaluating mkapplw1(Universal, mkapplt1(FUNSYM101, bvarof(wffof(FACT100)))) gives mkapplw1(Universal, mkapplt1(FUNSYM101, bvarof(wffof(FACT100))))
Evaluating Equal gives Equal
Evaluating FUNSYM102 gives FUNSYM102
Evaluating FACT100 gives FACT100
Evaluating wffof(FACT100) gives wffof(FACT100)
Evaluating bvarof(wffof(FACT100)) gives bvarof(wffof(FACT100))
Evaluating mkapplt1(FUNSYM102, bvarof(wffof(FACT100))) gives mkapplt1(FUNSYM102, bvarof(wffof(FACT100)))
Evaluating FUNSYM101 gives FUNSYM101
Evaluating FACT100 gives FACT100
Evaluating wffof(FACT100) gives wffof(FACT100)
Evaluating bvarof(wffof(FACT100)) gives bvarof(wffof(FACT100))
Evaluating mkapplt1(FUNSYM101, bvarof(wffof(FACT100))) gives mkapplt1(FUNSYM101, bvarof(wffof(FACT100)))
Evaluating pred2apply(Equal, mkapplt1(FUNSYM102, bvarof(wffof(FACT100))), mkapplt1(FUNSYM101, bvarof(wffof(FACT100)))) gives pred2apply(Equal, mkapplt1(FUNSYM102, bvarof(wffof(FACT100))), mkapplt1(FUNSYM101, bvarof(wffof(FACT100))))
Evaluating mkimp(mkapplw1(Universal, mkapplt1(FUNSYM101, bvarof(wffof(FACT100)))), pred2apply(Equal, mkapplt1(FUNSYM102, bvarof(wffof(FACT100))), mkapplt1(FUNSYM101, bvarof(wffof(FACT100))))) gives mkimp(mkapplw1(Universal, mkapplt1(FUNSYM101, bvarof(wffof(FACT100)))), pred2apply(Equal, mkapplt1(FUNSYM102, bvarof(wffof(FACT100))), mkapplt1(FUNSYM101, bvarof(wffof(FACT100)))))
Evaluating mkquant(Forall, bvarof(wffof(FACT100)), mkimp(mkapplw1(Universal, mkapplt1(FUNSYM101, bvarof(wffof(FACT100)))), pred2apply(Equal, mkapplt1(FUNSYM102, bvarof(wffof(FACT100))), mkapplt1(FUNSYM101, bvarof(wffof(FACT100)))))) gives mkquant(Forall, bvarof(wffof(FACT100)), mkimp(mkapplw1(Universal, mkapplt1(FUNSYM101, bvarof(wffof(FACT100)))), pred2apply(Equal, mkapplt1(FUNSYM102, bvarof(wffof(FACT100))), mkapplt1(FUNSYM101, bvarof(wffof(FACT100))))))
Evaluating mkimp(mkquant(Forall, bvarof(wffof(FACT100)), mkimp(mkapplw1(Universal, minsubst(FUNSYM102, FUNSYM101, rhs(matrix(wffof(FACT100))))), pred2apply(Equal, mkapplt1(FUNSYM102, bvarof(wffof(FACT100))), minsubst(FUNSYM102, FUNSYM101, rhs(matrix(wffof(FACT100))))))), mkquant(Forall, bvarof(wffof(FACT100)), mkimp(mkapplw1(Universal, mkapplt1(FUNSYM101, bvarof(wffof(FACT100)))), pred2apply(Equal, mkapplt1(FUNSYM102, bvarof(wffof(FACT100))), mkapplt1(FUNSYM101, bvarof(wffof(FACT100))))))) gives mkimp(mkquant(Forall, bvarof(wffof(FACT100)), mkimp(mkapplw1(Universal, minsubst(FUNSYM102, FUNSYM101, rhs(matrix(wffof(FACT100))))), pred2apply(Equal, mkapplt1(FUNSYM102, bvarof(wffof(FACT100))), minsubst(FUNSYM102, FUNSYM101, rhs(matrix(wffof(FACT100))))))), mkquant(Forall, bvarof(wffof(FACT100)), mkimp(mkapplw1(Universal, mkapplt1(FUNSYM101, bvarof(wffof(FACT100)))), pred2apply(Equal, mkapplt1(FUNSYM102, bvarof(wffof(FACT100))), mkapplt1(FUNSYM101, bvarof(wffof(FACT100)))))))
I am switching from the current context to: MTC

4   forall x. (UNIVERSAL(g(x)) imp (g(x) = g(x))) imp forall x. (UNIVERSAL(f(x)) imp (g(x) = f(x)))     
Ok!! I am finished doing reflection

GETFOL:: setbasicsimp Bot at facts {2};

GETFOL:: setbasicsimp Equterm at wffs {forall X.(X=X iff TRUE)};

GETFOL:: eval 4 by Bot uni Equterm uni LQUANTREE uni LPROPTREE;
forall x. (UNIVERSAL(g(x)) imp (g(x) = g(x))) imp forall x. (UNIVERSAL(f(x)) imp (g(x) = f(x))): syntactic simplification fails.
forall x. (UNIVERSAL(g(x)) imp (g(x) = g(x))): syntactic simplification fails.
UNIVERSAL(g(x)) imp (g(x) = g(x)): syntactic simplification fails.
Evaluating UNIVERSAL(g(x)) gives TRUE
g has no interpretation.
Syntactic simplification of g(x) gives BOT
Evaluating BOT doesn' t work
BOT: syntactic simplification fails.
Evaluating g(x) doesn' t work
BOT: syntactic simplification fails.
g has no interpretation.
Syntactic simplification of g(x) gives BOT
Evaluating BOT doesn' t work
BOT: syntactic simplification fails.
Evaluating g(x) doesn' t work
BOT: syntactic simplification fails.
Evaluating g(x) = g(x) gives TRUE
TRUE: syntactic simplification fails.
TRUE: syntactic simplification fails.
forall x. (UNIVERSAL(f(x)) imp (g(x) = f(x))): syntactic simplification fails.
UNIVERSAL(f(x)) imp (g(x) = f(x)): syntactic simplification fails.
Evaluating UNIVERSAL(f(x)) gives TRUE
g has no interpretation.
Syntactic simplification of g(x) gives BOT
Evaluating BOT doesn' t work
BOT: syntactic simplification fails.
Evaluating g(x) doesn' t work
BOT: syntactic simplification fails.
f has no interpretation.
f(x): syntactic simplification fails.
Evaluating x doesn' t work
x: syntactic simplification fails.
Evaluating f(x) doesn' t work
f(x): syntactic simplification fails.
Evaluating g(x) = f(x) doesn' t work
BOT = f(x): syntactic simplification fails.
BOT = f(x): syntactic simplification fails.
forall x. (BOT = f(x)): syntactic simplification fails.
forall x. (BOT = f(x)): syntactic simplification fails.

5   (forall x. (UNIVERSAL(g(x)) imp (g(x) = g(x))) imp forall x. (UNIVERSAL(f(x)) imp (g(x) = f(x)))) iff forall x. (BOT = f(x))     (2)

GETFOL:: iffe 5 1;

6   (forall x. (UNIVERSAL(g(x)) imp (g(x) = g(x))) imp forall x. (UNIVERSAL(f(x)) imp (g(x) = f(x)))) imp forall x. (BOT = f(x))     (2)

GETFOL:: impe 4 6;

7   forall x. (BOT = f(x))     (2)

GETFOL:: alle 7,x;

8   BOT = f(x)     (2)

GETFOL:: tauteq  not SEXP(f(x)) BY ^1,3;

9   not SEXP(f(x))     (2 3)

GETFOL:: alli ^1 x;

10   forall x. (not SEXP(f(x)))     (2 3)

GETFOL:: I am finished fetching meta/min.tst

GETFOL:: 	reset;
Resetting the whole GETFOL-system

GETFOL:: 
GETFOL:: 	fetch nd/if.tst;
I am starting to fetch nd/if.tst

GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: declare sentconst A B C;
A has been declared to be a Sentconst
B has been declared to be a Sentconst
C has been declared to be a Sentconst

GETFOL:: declare indpar a b c;
UNIVERSAL is a sort
a has been declared to be an Indpar
b has been declared to be an Indpar
c has been declared to be an Indpar

GETFOL:: declare predconst P 1;
P has been declared to be a Predconst

GETFOL:: declare predconst Q 2;
Q has been declared to be a Predconst

GETFOL:: declare funconst f g 1;
f has been declared to be a Funconst
g has been declared to be a Funconst

GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: label fact Pif;

GETFOL:: assume P(trmif A then a else b);

1   P(trmif A then a else b)     (1)

GETFOL:: label fact fa;

GETFOL:: assume A;

2   A     (2)

GETFOL:: label fact Pa;

GETFOL:: termife Pif fa trmif A then a else b;

3   P(a)     (1 2)

GETFOL:: label fact fna;

GETFOL:: assume not A;

4   not A     (4)

GETFOL:: label fact Pb;

GETFOL:: termifen Pif fna trmif A then a else b;

5   P(b)     (1 4)

GETFOL:: termifi Pa Pb  A a b;

6   P(trmif A then a else b)     (1)

GETFOL:: 
GETFOL:: 
GETFOL::  

termifi Pa Pb not A  a b;

7   P(trmif (not A) then a else b)     (1 2 4)

GETFOL:: 
GETFOL:: 
GETFOL:: termifi Pa Pb B  a b;

8   P(trmif B then a else b)     (1 2 4)

GETFOL:: 
GETFOL:: 
GETFOL:: label fact Piffun;

GETFOL:: assume P(trmif A then f(a) else f(b));

9   P(trmif A then f(a) else f(b))     (9)

GETFOL:: label fact Pfa;

GETFOL:: termife Piffun fa trmif A then f(a) else f(b);

10   P(f(a))     (2 9)

GETFOL:: label fact Pfb;

GETFOL:: termifen Piffun fna trmif A then f(a) else f(b);

11   P(f(b))     (4 9)

GETFOL:: termifi Pfa Pfb  A a b;

12   P(f(trmif A then a else b))     (9)

GETFOL:: termifi Pfa Pfb  A f(a) f(b);

13   P(trmif A then f(a) else f(b))     (9)

GETFOL:: 
GETFOL:: label fact Prec;

GETFOL:: assume P(trmif A then (trmif A then f(a) else f(b)) 
                 else (trmif A then f(a) else f(b)));

14   P(trmif A then (trmif A then f(a) else f(b)) else (trmif A then f(a) else f(b)))     (14)

GETFOL:: label fact Preca;

GETFOL:: termife Prec fa trmif A then f(a) else f(b);

15   P(trmif A then f(a) else f(a))     (2 14)

GETFOL:: label fact Precb;

GETFOL:: termifen Prec fna trmif A then f(a) else f(b);

16   P(trmif A then f(b) else f(b))     (4 14)

GETFOL:: termifi Preca Precb  A a b;

17   P(trmif A then f(trmif A then a else b) else f(trmif A then a else b))     (14)

GETFOL:: termifi Preca Precb  A f(a) f(b);

18   P(trmif A then (trmif A then f(a) else f(b)) else (trmif A then f(a) else f(b)))     (14)

GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: termife Prec fa trmif A then f(a) else f(b) occ 1;

19   P(trmif A then f(a) else (trmif A then f(a) else f(b)))     (2 14)

GETFOL:: termife Prec fa trmif A then f(a) else f(b) occ 2;

20   P(trmif A then (trmif A then f(a) else f(b)) else f(a))     (2 14)

GETFOL:: termife Prec fa trmif A then f(a) else f(b) occ 1 2;

21   P(trmif A then f(a) else f(a))     (2 14)

GETFOL:: termife Prec fa trmif A then f(a) else f(b);

22   P(trmif A then f(a) else f(a))     (2 14)

GETFOL:: label fact PQ;

GETFOL:: assume  P(trmif A then a else b) and 
        Q(trmif not A then a else b,trmif A then b else a);

23   P(trmif A then a else b) and Q(trmif (not A) then a else b, trmif A then b else a)     (23)

GETFOL:: termife PQ fa trmif A then a else b;

24   P(a) and Q(trmif (not A) then a else b, trmif A then b else a)     (2 23)

GETFOL:: termife PQ fna trmif not A then a else b;

25   P(trmif A then a else b) and Q(a, trmif A then b else a)     (4 23)

GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: termifen PQ fna trmif A then a else b;

26   P(b) and Q(trmif (not A) then a else b, trmif A then b else a)     (4 23)

GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: label fact wif;

GETFOL:: assume wffif A then B else C;

27   wffif A then B else C     (27)

GETFOL:: wffife wif fa;

28   B     (2 27)

GETFOL:: wffifen wif fna;

29   C     (4 27)

GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: wffifi A fa fna;

30   wffif A then A else (not A)     

GETFOL:: wffifi A fna fa;

31   wffif A then (not A) else A     (2 4)

GETFOL:: wffifi not A fna fa;

32   wffif (not A) then (not A) else A     (2)

GETFOL:: wffifi not A fa fna;

33   wffif (not A) then A else (not A)     (2 4)

GETFOL:: I am finished fetching nd/if.tst

GETFOL:: 	reset;
Resetting the whole GETFOL-system

GETFOL:: 	fetch nd/str.tst;
I am starting to fetch nd/str.tst

GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: declare sentconst A B C D;
A has been declared to be a Sentconst
B has been declared to be a Sentconst
C has been declared to be a Sentconst
D has been declared to be a Sentconst

GETFOL:: assume A A A A B B C D ;

1   A     (1)

2   A     (2)

3   A     (3)

4   A     (4)

5   B     (5)

6   B     (6)

7   C     (7)

8   D     (8)

GETFOL:: AXIOM aa : A;

aa : A

GETFOL:: AXIOM bb : B;

bb : B

GETFOL:: AXIOM cc : C;

cc : C

GETFOL:: andi 7 8;

9   C and D     (7 8)

GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: weaken 1 by 1;

10   A     (1)

GETFOL:: weaken 9 by 4;

11   C and D     (4 7 8)

GETFOL:: weaken 9 by 7;

12   C and D     (7 8)

GETFOL:: weaken 9 by 1 2 3 4 5 6 6 5 5;

13   C and D     (1 2 3 4 5 6 7 8)

GETFOL:: weaken 1 by 4;

14   A     (1 4)

GETFOL:: weaken 1 by 5;

15   A     (1 5)

GETFOL:: weaken 1 by 2 3 4 5 5 5 1 1 6 7 8;

16   A     (1 2 3 4 5 6 7 8)

GETFOL:: 
GETFOL:: 
GETFOL:: weaken 5 by aa;

17   B     (5)

GETFOL:: weaken bb by 1;

18   B     (1)

GETFOL:: 
GETFOL:: 
GETFOL:: weaken 1 by 9;

19   A     (1 7 8)

GETFOL:: weaken 1 by 9 9;

20   A     (1 7 8)

GETFOL:: weaken 9  by 9;

21   C and D     (7 8)

GETFOL:: weaken aa by 5 5 9 9 bb bb;

22   A     (5 7 8)

GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: ctc 13 by 1 1 1 1;

23   C and D     (1 5 6 7 8)

GETFOL:: ctc 13 by 1 2 3 4 5 6;

24   C and D     (1 2 3 4 5 6 7 8)

GETFOL:: ctc 13 by 1 2 3 4 5 6 7 8;

25   C and D     (1 2 3 4 5 6 7 8)

GETFOL:: ctc 13 by 8 7 6;

26   C and D     (1 2 3 4 6 7 8)

GETFOL:: ctc 1 by 1;

27   A     (1)

GETFOL:: ctc 13 by 1 5;

28   C and D     (1 5 7 8)

GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: cut aa 13;

29   C and D     (5 6 7 8)

GETFOL:: cut bb 13;

30   C and D     (1 2 3 4 7 8)

GETFOL:: cut 1 13;

31   C and D     (1 5 6 7 8)

GETFOL:: cut 5 13;

32   C and D     (1 2 3 4 5 7 8)

GETFOL:: cut 8 13;

33   C and D     (1 2 3 4 5 6 7 8)

GETFOL:: cut 9 13;

34   C and D     (1 2 3 4 5 6 7 8)

GETFOL:: cut 13 13;

35   C and D     (1 2 3 4 5 6 7 8)

GETFOL:: cut 16 13;

36   C and D     (1 2 3 4 5 6 7 8)

GETFOL:: cut aa 16;

37   A     (5 6 7 8)

GETFOL:: cut bb 16;

38   A     (1 2 3 4 7 8)

GETFOL:: cut 1 16;

39   A     (1 5 6 7 8)

GETFOL:: cut 5 16;

40   A     (1 2 3 4 5 7 8)

GETFOL:: cut 8 16;

41   A     (1 2 3 4 5 6 7 8)

GETFOL:: cut 9 16;

42   A     (1 2 3 4 5 6 7 8)

GETFOL:: cut 13 16;

43   A     (1 2 3 4 5 6 7 8)

GETFOL:: cut 16 16;

44   A     (1 2 3 4 5 6 7 8)

GETFOL:: cut aa aa;

45   A     

GETFOL:: cut aa bb;

46   B     

GETFOL:: cut 1 aa ;

47   A     (1)

GETFOL:: cut 16 aa;

48   A     (1 2 3 4 5 6 7 8)

GETFOL:: cut aa 1;

49   A     

GETFOL:: cut bb 1;

50   A     (1)

GETFOL:: cut 1 1;

51   A     (1)

GETFOL:: cut 5 1;

52   A     (1 5)

GETFOL:: cut 8 1;

53   A     (1 8)

GETFOL:: cut 9 1;

54   A     (1 7 8)

GETFOL:: cut 13 1;

55   A     (1 2 3 4 5 6 7 8)

GETFOL:: cut 16 1;

56   A     (1 2 3 4 5 6 7 8)

GETFOL:: cut 15 11;

57   C and D     (1 5 7 8)

GETFOL:: cut 11 15;

58   A     (1 4 5 7 8)

GETFOL:: cut 1 11;

59   C and D     (1 7 8)

GETFOL:: cut aa 11;

60   C and D     (7 8)

GETFOL:: cut 2 15;

61   A     (2 5)

GETFOL:: cut 2 23;

62   C and D     (2 5 6 7 8)

GETFOL:: cut bb 23;

63   C and D     (1 7 8)

GETFOL:: 
GETFOL:: 
GETFOL:: cut aa 16 keep 1;

64   A     (1 5 6 7 8)

GETFOL:: cut aa 16 keep 1 1;

65   A     (1 5 6 7 8)

GETFOL:: cut aa 16 keep 4 3 2 1;

66   A     (1 2 3 4 5 6 7 8)

GETFOL:: cut aa 16 keep 4  2 1 1 2 4 1;

67   A     (1 2 4 5 6 7 8)

GETFOL:: cut aa 16 keep 1 2 3 4;

68   A     (1 2 3 4 5 6 7 8)

GETFOL:: cut 1 16 keep 1;

69   A     (1 5 6 7 8)

GETFOL:: cut 1 16 keep 1 2;

70   A     (1 2 5 6 7 8)

GETFOL:: cut 1 16 keep 1 1 ;

71   A     (1 5 6 7 8)

GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: I am finished fetching nd/str.tst

GETFOL:: 	reset;
Resetting the whole GETFOL-system

GETFOL:: 
GETFOL:: 	fetch proof/axiom.tst;
I am starting to fetch proof/axiom.tst

GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: declare indvar x y z x1 x2 x3 y1 y2 y3 z1 z2 z3;
UNIVERSAL is a sort
x has been declared to be an Indvar
y has been declared to be an Indvar
z has been declared to be an Indvar
x1 has been declared to be an Indvar
x2 has been declared to be an Indvar
x3 has been declared to be an Indvar
y1 has been declared to be an Indvar
y2 has been declared to be an Indvar
y3 has been declared to be an Indvar
z1 has been declared to be an Indvar
z2 has been declared to be an Indvar
z3 has been declared to be an Indvar

GETFOL:: declare funconst f 1;
f has been declared to be a Funconst

GETFOL:: declare funconst g 2;
g has been declared to be a Funconst

GETFOL:: declare funconst h 3;
h has been declared to be a Funconst

GETFOL:: declare predconst p q 1;
p has been declared to be a Predconst
q has been declared to be a Predconst

GETFOL:: declare predconst r s 2;
r has been declared to be a Predconst
s has been declared to be a Predconst

GETFOL:: declare funpar PHI PHI1 PHI2 1;
PHI has been declared to be a Funpar
PHI1 has been declared to be a Funpar
PHI2 has been declared to be a Funpar

GETFOL:: declare funpar PSI PSI1 PSI2 2;
PSI has been declared to be a Funpar
PSI1 has been declared to be a Funpar
PSI2 has been declared to be a Funpar

GETFOL:: declare funpar CHI CHI1 CHI2 3;
CHI has been declared to be a Funpar
CHI1 has been declared to be a Funpar
CHI2 has been declared to be a Funpar

GETFOL:: declare predpar PI 1;
PI has been declared to be a Predpar

GETFOL:: declare predpar RHO 2;
RHO has been declared to be a Predpar

GETFOL:: declare Predpar SIGMA 3;
SIGMA has been declared to be a Predpar

GETFOL:: axiom lin11: PHI1(PHI2(x)) = PHI2(PHI1(x));

lin11 : PHI1(PHI2(x)) = PHI2(PHI1(x))

GETFOL:: axiom lin12: PHI(PSI(x y)) = PSI(PHI(x) PHI(y));

lin12 : PHI(PSI(x, y)) = PSI(PHI(x), PHI(y))

GETFOL:: axiom lin13: PHI(CHI(x y z)) = CHI(PHI(x) PHI(y) PHI(z));

lin13 : PHI(CHI(x, y, z)) = CHI(PHI(x), PHI(y), PHI(z))

GETFOL:: axiom lin21: PSI(PHI(x) PHI(y)) = PHI(PSI(x y));

lin21 : PSI(PHI(x), PHI(y)) = PHI(PSI(x, y))

GETFOL:: axiom lin22: PSI1(PSI2(x1 y1) PSI2(x2 y2)) = PSI2(PSI1(x1 x2) PSI1(y1 y2));

lin22 : PSI1(PSI2(x1, y1), PSI2(x2, y2)) = PSI2(PSI1(x1, x2), PSI1(y1, y2))

GETFOL:: axiom lin23: PSI(CHI(x1 y1 z1) CHI(x2 y2 z2)) = 
                          CHI(PSI(x1 x2) PSI(y1 y2) PSI(z1 z2));

lin23 : PSI(CHI(x1, y1, z1), CHI(x2, y2, z2)) = CHI(PSI(x1, x2), PSI(y1, y2), PSI(z1, z2))

GETFOL:: axiom lin31: CHI(PHI(x) PHI(y) PHI(x)) = PHI(CHI(x y z));

lin31 : CHI(PHI(x), PHI(y), PHI(x)) = PHI(CHI(x, y, z))

GETFOL:: axiom lin32: CHI(PSI(x1 y1) PSI(x2 y2) PSI(x3 y3)) = 
                          PSI(CHI(x1 y1 z1) CHI(x2 y2 z2));

lin32 : CHI(PSI(x1, y1), PSI(x2, y2), PSI(x3, y3)) = PSI(CHI(x1, y1, z1), CHI(x2, y2, z2))

GETFOL:: axiom lin33: CHI1(CHI2(x1 y1 z1) CHI2(x2 y2 z2) CHI2(x3 y3 z3)) = 
                          CHI2(CHI1(x1 x2 x3) CHI1(y1 y2 y3) CHI1(z1 z2 z3));

lin33 : CHI1(CHI2(x1, y1, z1), CHI2(x2, y2, z2), CHI2(x3, y3, z3)) = CHI2(CHI1(x1, x2, x3), CHI1(y1, y2, y3), CHI1(z1, z2, z3))

GETFOL:: axiom unary: PI(x) imp PI(f(x));

unary : PI(x) imp PI(f(x))

GETFOL:: axiom binary: PI(x) and PI(y) imp PI(g(x y));

binary : (PI(x) and PI(y)) imp PI(g(x, y))

GETFOL:: axiom ternary: PI(x) and PI(y) and PI(z) imp PI(h(x y z));

ternary : ((PI(x) and PI(y)) and PI(z)) imp PI(h(x, y, z))

GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: eval x = x;
Evaluating x doesn' t work
x: syntactic simplification fails.
Evaluating x doesn' t work
x: syntactic simplification fails.
Evaluating x = x gives TRUE

1   x = x     

GETFOL:: impe 1  unary PI:lambda y. x=y;

2   x = f(x)     

GETFOL:: alli 2 x;

3   forall x. (x = f(x))     

GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: andi 1 1;

4   (x = x) and (x = x)     

GETFOL:: alli binary PI:lambda y. x=y y:y1;

5   forall y1. (((x = x) and (x = y1)) imp (x = g(x, y1)))     

GETFOL:: alle ^1 x;

6   ((x = x) and (x = x)) imp (x = g(x, x))     

GETFOL:: impe ^1 ^3;

7   x = g(x, x)     

GETFOL:: alli ^1 x;

8   forall x. (x = g(x, x))     

GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: andi 1 1;

9   (x = x) and (x = x)     

GETFOL:: andi ^1 1;

10   ((x = x) and (x = x)) and (x = x)     

GETFOL:: alli ternary PI:lambda y. x=y y:y1 z:z1;

11   forall y1 z1. ((((x = x) and (x = y1)) and (x = z1)) imp (x = h(x, y1, z1)))     

GETFOL:: alle ^1 x x;

12   (((x = x) and (x = x)) and (x = x)) imp (x = h(x, x, x))     

GETFOL:: impe ^1 ^3;

13   x = h(x, x, x)     

GETFOL:: alli ^1 x;

14   forall x. (x = h(x, x, x))     

GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: eval f(g(h(x1 y1 z1) h(x2 y2 z2))) = f(g(h(x1 y1 z1) h(x2 y2 z2)));
f has no interpretation.
f(g(h(x1, y1, z1), h(x2, y2, z2))): syntactic simplification fails.
g has no interpretation.
g(h(x1, y1, z1), h(x2, y2, z2)): syntactic simplification fails.
h has no interpretation.
h(x1, y1, z1): syntactic simplification fails.
Evaluating x1 doesn' t work
x1: syntactic simplification fails.
Evaluating y1 doesn' t work
y1: syntactic simplification fails.
Evaluating z1 doesn' t work
z1: syntactic simplification fails.
Evaluating h(x1, y1, z1) doesn' t work
h(x1, y1, z1): syntactic simplification fails.
h has no interpretation.
h(x2, y2, z2): syntactic simplification fails.
Evaluating x2 doesn' t work
x2: syntactic simplification fails.
Evaluating y2 doesn' t work
y2: syntactic simplification fails.
Evaluating z2 doesn' t work
z2: syntactic simplification fails.
Evaluating h(x2, y2, z2) doesn' t work
h(x2, y2, z2): syntactic simplification fails.
Evaluating g(h(x1, y1, z1), h(x2, y2, z2)) doesn' t work
g(h(x1, y1, z1), h(x2, y2, z2)): syntactic simplification fails.
Evaluating f(g(h(x1, y1, z1), h(x2, y2, z2))) doesn' t work
f(g(h(x1, y1, z1), h(x2, y2, z2))): syntactic simplification fails.
f has no interpretation.
f(g(h(x1, y1, z1), h(x2, y2, z2))): syntactic simplification fails.
g has no interpretation.
g(h(x1, y1, z1), h(x2, y2, z2)): syntactic simplification fails.
h has no interpretation.
h(x1, y1, z1): syntactic simplification fails.
Evaluating x1 doesn' t work
x1: syntactic simplification fails.
Evaluating y1 doesn' t work
y1: syntactic simplification fails.
Evaluating z1 doesn' t work
z1: syntactic simplification fails.
Evaluating h(x1, y1, z1) doesn' t work
h(x1, y1, z1): syntactic simplification fails.
h has no interpretation.
h(x2, y2, z2): syntactic simplification fails.
Evaluating x2 doesn' t work
x2: syntactic simplification fails.
Evaluating y2 doesn' t work
y2: syntactic simplification fails.
Evaluating z2 doesn' t work
z2: syntactic simplification fails.
Evaluating h(x2, y2, z2) doesn' t work
h(x2, y2, z2): syntactic simplification fails.
Evaluating g(h(x1, y1, z1), h(x2, y2, z2)) doesn' t work
g(h(x1, y1, z1), h(x2, y2, z2)): syntactic simplification fails.
Evaluating f(g(h(x1, y1, z1), h(x2, y2, z2))) doesn' t work
f(g(h(x1, y1, z1), h(x2, y2, z2))): syntactic simplification fails.
Evaluating f(g(h(x1, y1, z1), h(x2, y2, z2))) = f(g(h(x1, y1, z1), h(x2, y2, z2))) gives TRUE

15   f(g(h(x1, y1, z1), h(x2, y2, z2))) = f(g(h(x1, y1, z1), h(x2, y2, z2)))     

GETFOL:: alli lin12 PHI: lambda x. f(x) PSI: lambda x y. g(x y) x y;

16   forall x y. (f(g(x, y)) = g(f(x), f(y)))     

GETFOL:: alle ^1 h(x1 y1 z1) h(x2 y2 z2);

17   f(g(h(x1, y1, z1), h(x2, y2, z2))) = g(f(h(x1, y1, z1)), f(h(x2, y2, z2)))     

GETFOL:: subst ^3 ^1 occ 2;

18   f(g(h(x1, y1, z1), h(x2, y2, z2))) = g(f(h(x1, y1, z1)), f(h(x2, y2, z2)))     

GETFOL:: alli lin13 PHI: lambda x. f(x) CHI: lambda x y z. h(x y z) x y z;

19   forall x y z. (f(h(x, y, z)) = h(f(x), f(y), f(z)))     

GETFOL:: alle ^1 x1 y1 z1;

20   f(h(x1, y1, z1)) = h(f(x1), f(y1), f(z1))     

GETFOL:: subst ^3 ^1;

21   f(g(h(x1, y1, z1), h(x2, y2, z2))) = g(h(f(x1), f(y1), f(z1)), f(h(x2, y2, z2)))     

GETFOL:: alle ^3 x2 y2 z2;

22   f(h(x2, y2, z2)) = h(f(x2), f(y2), f(z2))     

GETFOL:: subst ^2 ^1;

23   f(g(h(x1, y1, z1), h(x2, y2, z2))) = g(h(f(x1), f(y1), f(z1)), h(f(x2), f(y2), f(z2)))     

GETFOL:: alli lin23 PSI: lambda x y. g(x y) CHI: lambda x y z. h(x y z) x1 x2 y1 y2 z1 z2;

24   forall x1 x2 y1 y2 z1 z2. (g(h(x1, y1, z1), h(x2, y2, z2)) = h(g(x1, x2), g(y1, y2), g(z1, z2)))     

GETFOL:: alle ^1 f(x1) f(x2) f(y1) f(y2) f(z1) f(z2);

25   g(h(f(x1), f(y1), f(z1)), h(f(x2), f(y2), f(z2))) = h(g(f(x1), f(x2)), g(f(y1), f(y2)), g(f(z1), f(z2)))     

GETFOL:: subst ^3 ^1;

26   f(g(h(x1, y1, z1), h(x2, y2, z2))) = h(g(f(x1), f(x2)), g(f(y1), f(y2)), g(f(z1), f(z2)))     

GETFOL:: I am finished fetching proof/axiom.tst

GETFOL:: 	reset;
Resetting the whole GETFOL-system

GETFOL:: 	fetch proof/reason.tst;
I am starting to fetch proof/reason.tst

GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: probe all;

GETFOL:: 
GETFOL:: reset;
Resetting the whole GETFOL-system

GETFOL:: declare sentconst A;
A has been declared to be a Sentconst

GETFOL:: assume A;

1   A     (1)

GETFOL:: show premises 1;
1  A  (1)

GETFOL:: reset;
Resetting the whole GETFOL-system

GETFOL:: declare sentconst A B C D E;
A has been declared to be a Sentconst
B has been declared to be a Sentconst
C has been declared to be a Sentconst
D has been declared to be a Sentconst
E has been declared to be a Sentconst

GETFOL:: assume A B;

1   A     (1)

2   B     (2)

GETFOL:: andi 1 2;

3   A and B     (1 2)

GETFOL:: assume C D E;

4   C     (4)

5   D     (5)

6   E     (6)

GETFOL:: andi 1 conj 2 3;

7   (A and B) and (A and B)     (1 2)

GETFOL:: show premises 7;
7  (A and B) and (A and B)  (1 2)
   1  A  (1)
   2  B  (2)
   3  A and B  (1 2)

GETFOL:: andi 1 conj 2 3 conj 4;

8   (A and B) and ((A and B) and C)     (1 2 4)

GETFOL:: show premises 8;
8  (A and B) and ((A and B) and C)  (1 2 4)
   1  A  (1)
   2  B  (2)
   3  A and B  (1 2)
   4  C  (4)

GETFOL:: andi 1 conj 2 conj 3 4;

9   (A and (B and (A and B))) and C     (1 2 4)

GETFOL:: show premises 9;
9  (A and (B and (A and B))) and C  (1 2 4)
   1  A  (1)
   2  B  (2)
   3  A and B  (1 2)
   4  C  (4)

GETFOL:: andi 9 conj 4 8;

10   (((A and (B and (A and B))) and C) and C) and ((A and B) and ((A and B) and C))     (1 2 4)

GETFOL:: show premises 10;
10  (((A and (B and (A and B))) and C) and C) and ((A and B) and ((A and B) and C))  (1 2 4)
   9  (A and (B and (A and B))) and C  (1 2 4)
   4  C  (4)
   8  (A and B) and ((A and B) and C)  (1 2 4)

GETFOL:: show premises 10 2;
10  (((A and (B and (A and B))) and C) and C) and ((A and B) and ((A and B) and C))  (1 2 4)
   9  (A and (B and (A and B))) and C  (1 2 4)
      1  A  (1)
      2  B  (2)
      3  A and B  (1 2)
      4  C  (4)
   4  C  (4)
   8  (A and B) and ((A and B) and C)  (1 2 4)
      1  A  (1)
      2  B  (2)
      3  A and B  (1 2)
      4  C  (4)

GETFOL:: show premises 10 all;
10  (((A and (B and (A and B))) and C) and C) and ((A and B) and ((A and B) and C))  (1 2 4)
   9  (A and (B and (A and B))) and C  (1 2 4)
      1  A  (1)
      2  B  (2)
      3  A and B  (1 2)
         1  A  (1)
         2  B  (2)
      4  C  (4)
   4  C  (4)
   8  (A and B) and ((A and B) and C)  (1 2 4)
      1  A  (1)
      2  B  (2)
      3  A and B  (1 2)
         1  A  (1)
         2  B  (2)
      4  C  (4)

GETFOL:: reset;
Resetting the whole GETFOL-system

GETFOL:: declare sentconst A B C D;
A has been declared to be a Sentconst
B has been declared to be a Sentconst
C has been declared to be a Sentconst
D has been declared to be a Sentconst

GETFOL:: assume A and ((B and C) and D);

1   A and ((B and C) and D)     (1)

GETFOL:: ande 1 1;

2   A     (1)

GETFOL:: show premises 2;
2  A  (1)
   1  A and ((B and C) and D)  (1)

GETFOL:: reset;
Resetting the whole GETFOL-system

GETFOL:: declare sentconst A;
A has been declared to be a Sentconst

GETFOL:: assume A;

1   A     (1)

GETFOL:: impi 1 1;

2   A imp A     

GETFOL:: show premises 2;
2  A imp A  
   1  A  (1)

GETFOL:: reset;
Resetting the whole GETFOL-system

GETFOL:: declare sentconst A B;
A has been declared to be a Sentconst
B has been declared to be a Sentconst

GETFOL:: assume A;

1   A     (1)

GETFOL:: assume A imp B;

2   A imp B     (2)

GETFOL:: impe 1 2;

3   B     (1 2)

GETFOL:: show premises 3;
3  B  (1 2)
   2  A imp B  (2)
   1  A  (1)

GETFOL:: reset;
Resetting the whole GETFOL-system

GETFOL:: declare sentconst A B;
A has been declared to be a Sentconst
B has been declared to be a Sentconst

GETFOL:: assume A;

1   A     (1)

GETFOL:: ori 1 B;

2   A or B     (1)

GETFOL:: show premises 2;
2  A or B  (1)
   1  A  (1)

GETFOL:: reset;
Resetting the whole GETFOL-system

GETFOL:: declare sentconst A B C;
A has been declared to be a Sentconst
B has been declared to be a Sentconst
C has been declared to be a Sentconst

GETFOL:: assume B imp A;

1   B imp A     (1)

GETFOL:: assume C imp A;

2   C imp A     (2)

GETFOL:: assume B;

3   B     (3)

GETFOL:: assume C;

4   C     (4)

GETFOL:: impe 3 1;

5   A     (1 3)

GETFOL:: impe 4 2;

6   A     (2 4)

GETFOL:: assume B or C;

7   B or C     (7)

GETFOL:: ore 7 5 6;

8   A     (1 2 7)

GETFOL:: show premises 8 all;
8  A  (1 2 7)
   7  B or C  (7)
   5  A  (1 3)
      1  B imp A  (1)
      3  B  (3)
   6  A  (2 4)
      2  C imp A  (2)
      4  C  (4)

GETFOL:: reset;
Resetting the whole GETFOL-system

GETFOL:: declare sentconst A;
A has been declared to be a Sentconst

GETFOL:: assume not A not not A;

1   not A     (1)

2   not (not A)     (2)

GETFOL:: falsei 1 2;

3   FALSE     (1 2)

GETFOL:: note 3 not A;

4   A     (2)

GETFOL:: impi 2 4;

5   (not (not A)) imp A     

GETFOL:: show premises 5 all;
5  (not (not A)) imp A  
   4  A  (2)
      3  FALSE  (1 2)
         2  not (not A)  (2)
         1  not A  (1)

GETFOL:: reset;
Resetting the whole GETFOL-system

GETFOL:: declare sentconst A;
A has been declared to be a Sentconst

GETFOL:: assume FALSE;

1   FALSE     (1)

GETFOL:: falsee 1 A and not A;

2   A and (not A)     (1)

GETFOL:: show premises 2;
2  A and (not A)  (1)
   1  FALSE  (1)

GETFOL:: reset;
Resetting the whole GETFOL-system

GETFOL:: declare sentconst A;
A has been declared to be a Sentconst

GETFOL:: assume A not A;

1   A     (1)

2   not A     (2)

GETFOL:: falsei 1 2;

3   FALSE     (1 2)

GETFOL:: noti 3 not A;

4   not (not A)     (1)

GETFOL:: impi 1 4;

5   A imp (not (not A))     

GETFOL:: show premises 5 all;
5  A imp (not (not A))  
   4  not (not A)  (1)
      3  FALSE  (1 2)
         2  not A  (2)
         1  A  (1)

GETFOL:: reset;
Resetting the whole GETFOL-system

GETFOL:: declare sentconst A B;
A has been declared to be a Sentconst
B has been declared to be a Sentconst

GETFOL:: assume A imp B B imp A;

1   A imp B     (1)

2   B imp A     (2)

GETFOL:: iffi 1 2;

3   A iff B     (1 2)

GETFOL:: iffi 2 1;

4   B iff A     (1 2)

GETFOL:: show premises 3;
3  A iff B  (1 2)
   1  A imp B  (1)
   2  B imp A  (2)

GETFOL:: show premises 4;
4  B iff A  (1 2)
   2  B imp A  (2)
   1  A imp B  (1)

GETFOL:: reset;
Resetting the whole GETFOL-system

GETFOL:: declare sentconst A;
A has been declared to be a Sentconst

GETFOL:: assume A iff not not A;

1   A iff (not (not A))     (1)

GETFOL:: iffe 1 1;

2   A imp (not (not A))     (1)

GETFOL:: iffe 1 2;

3   (not (not A)) imp A     (1)

GETFOL:: show premises 3;
3  (not (not A)) imp A  (1)
   1  A iff (not (not A))  (1)

GETFOL:: reset;
Resetting the whole GETFOL-system

GETFOL:: declare predconst P 1;
P has been declared to be a Predconst

GETFOL:: declare indvar x;
UNIVERSAL is a sort
x has been declared to be an Indvar

GETFOL:: declare indpar a;
UNIVERSAL is a sort
a has been declared to be an Indpar

GETFOL:: assume P(a);

1   P(a)     (1)

GETFOL:: impi 1 1;

2   P(a) imp P(a)     

GETFOL:: alli 2 a:x;

3   forall x. (P(x) imp P(x))     

GETFOL:: alli 2 x;

4   forall x. (P(a) imp P(a))     

GETFOL:: show premises 3 all;
3  forall x. (P(x) imp P(x))  
   2  P(a) imp P(a)  
      1  P(a)  (1)

GETFOL:: show premises 4 all;
4  forall x. (P(a) imp P(a))  
   2  P(a) imp P(a)  
      1  P(a)  (1)

GETFOL:: reset;
Resetting the whole GETFOL-system

GETFOL:: declare predconst P 2;
P has been declared to be a Predconst

GETFOL:: declare indvar x y;
UNIVERSAL is a sort
x has been declared to be an Indvar
y has been declared to be an Indvar

GETFOL:: declare indconst c1 c2;
UNIVERSAL is a sort
c1 has been declared to be an Indconst
c2 has been declared to be an Indconst

GETFOL:: assume forall x y. P(x,y);

1   forall x y. P(x, y)     (1)

GETFOL:: alle 1 c1;

2   forall y. P(c1, y)     (1)

GETFOL:: alle 1 x c1;

3   P(x, c1)     (1)

GETFOL:: alle 1 c1 c2;

4   P(c1, c2)     (1)

GETFOL:: show premises 2;
2  forall y. P(c1, y)  (1)
   1  forall x y. P(x, y)  (1)

GETFOL:: show premises 3;
3  P(x, c1)  (1)
   1  forall x y. P(x, y)  (1)

GETFOL:: show premises 4;
4  P(c1, c2)  (1)
   1  forall x y. P(x, y)  (1)

GETFOL:: reset;
Resetting the whole GETFOL-system

GETFOL:: declare predconst P 2;
P has been declared to be a Predconst

GETFOL:: declare indvar x y;
UNIVERSAL is a sort
x has been declared to be an Indvar
y has been declared to be an Indvar

GETFOL:: declare indconst c1 c2;
UNIVERSAL is a sort
c1 has been declared to be an Indconst
c2 has been declared to be an Indconst

GETFOL:: assume P(c1,c2);

1   P(c1, c2)     (1)

GETFOL:: existi 1 c1:x c2:y;

2   exists y x. P(x, y)     (1)

GETFOL:: show premises 2;
2  exists y x. P(x, y)  (1)
   1  P(c1, c2)  (1)

GETFOL:: reset;
Resetting the whole GETFOL-system

GETFOL:: declare indvar x y;
UNIVERSAL is a sort
x has been declared to be an Indvar
y has been declared to be an Indvar

GETFOL:: declare indpar a b;
UNIVERSAL is a sort
a has been declared to be an Indpar
b has been declared to be an Indpar

GETFOL:: declare predconst P 2;
P has been declared to be a Predconst

GETFOL:: assume exists y. P(a,y);

1   exists y. P(a, y)     (1)

GETFOL:: existe 1 b;

2   P(a, b)     (2)

GETFOL:: show premises 2;
2  P(a, b)  (2)
   1  exists y. P(a, y)  (1)

GETFOL:: reset;
Resetting the whole GETFOL-system

GETFOL:: declare sentconst A B;
A has been declared to be a Sentconst
B has been declared to be a Sentconst

GETFOL:: declare sentpar alpha beta;
alpha has been declared to be a Sentpar
beta has been declared to be a Sentpar

GETFOL:: axiom axA: A;

axA : A

GETFOL:: impi axA axA;

1   A imp A     

GETFOL:: axiom Hil1: alpha imp (beta imp alpha);

Hil1 : alpha imp (beta imp alpha)

GETFOL:: impe 1 Hil1 alpha: A imp A, beta: B;

2   B imp (A imp A)     

GETFOL:: show premises 2;
2  B imp (A imp A)  
   Hil1  (A imp A) imp (B imp (A imp A))  
   1  A imp A  

GETFOL:: reset;
Resetting the whole GETFOL-system

GETFOL:: declare sentconst A B C;
A has been declared to be a Sentconst
B has been declared to be a Sentconst
C has been declared to be a Sentconst

GETFOL:: 
hilbert

hilbert1 : A imp (B imp C)

hilbert2 : (A imp (B imp C)) imp ((A imp B) imp (A imp C))

GETFOL:: mp hilbert1 hilbert2;

1   (A imp B) imp (A imp C)     

GETFOL:: andi hilbert hilbert;

2   ((A imp (B imp C)) and ((A imp (B imp C)) imp ((A imp B) imp (A imp C)))) and ((A imp (B imp C)) and ((A imp (B imp C)) imp ((A imp B) imp (A imp C))))     

GETFOL:: 
tautologies

IMP : A imp A

OR : A or (not A)

GETFOL:: show premises 2;
2  ((A imp (B imp C)) and ((A imp (B imp C)) imp ((A imp B) imp (A imp C)))) and ((A imp (B imp C)) and ((A imp (B imp C)) imp ((A imp B) imp (A imp C))))  
   hilbert  (A imp (B imp C)) and ((A imp (B imp C)) imp ((A imp B) imp (A imp C)))  
   hilbert  (A imp (B imp C)) and ((A imp (B imp C)) imp ((A imp B) imp (A imp C)))  

GETFOL:: 
GETFOL:: reset;
Resetting the whole GETFOL-system

GETFOL:: declare predconst P Q 2;
P has been declared to be a Predconst
Q has been declared to be a Predconst

GETFOL:: declare funconst f 1;
f has been declared to be a Funconst

GETFOL:: declare indvar x y;
UNIVERSAL is a sort
x has been declared to be an Indvar
y has been declared to be an Indvar

GETFOL:: assume P(x,y) imp Q(y,x);

1   P(x, y) imp Q(y, x)     (1)

GETFOL:: assume x = f(x);

2   x = f(x)     (2)

GETFOL:: subst 1 2;

3   P(f(x), y) imp Q(y, f(x))     (1 2)

GETFOL:: subst 3 2 right;

4   P(x, y) imp Q(y, x)     (1 2)

GETFOL:: subst 1 2 occ 1;

5   P(f(x), y) imp Q(y, x)     (1 2)

GETFOL:: show premises 4 all;
4  P(x, y) imp Q(y, x)  (1 2)
   3  P(f(x), y) imp Q(y, f(x))  (1 2)
      1  P(x, y) imp Q(y, x)  (1)
      2  x = f(x)  (2)
   2  x = f(x)  (2)

GETFOL:: show premises 5;
5  P(f(x), y) imp Q(y, x)  (1 2)
   1  P(x, y) imp Q(y, x)  (1)
   2  x = f(x)  (2)

GETFOL:: 
GETFOL:: reset;
Resetting the whole GETFOL-system

GETFOL:: declare sentconst A;
A has been declared to be a Sentconst

GETFOL:: assume A;

1   A     (1)

GETFOL:: assume not A;

2   not A     (2)

GETFOL:: wffifi A 1 2;

3   wffif A then A else (not A)     

GETFOL:: show premises 3 all;
3  wffif A then A else (not A)  
   1  A  (1)
   2  not A  (2)

GETFOL:: reset;
Resetting the whole GETFOL-system

GETFOL:: declare sentconst A B C;
A has been declared to be a Sentconst
B has been declared to be a Sentconst
C has been declared to be a Sentconst

GETFOL:: assume A;

1   A     (1)

GETFOL:: assume wffif A then B else C;

2   wffif A then B else C     (2)

GETFOL:: wffife 2 1;

3   B     (1 2)

GETFOL:: show premises 3;
3  B  (1 2)
   2  wffif A then B else C  (2)
   1  A  (1)

GETFOL:: 
GETFOL:: reset;
Resetting the whole GETFOL-system

GETFOL:: declare sentconst A B C;
A has been declared to be a Sentconst
B has been declared to be a Sentconst
C has been declared to be a Sentconst

GETFOL:: assume A A A B C;

1   A     (1)

2   A     (2)

3   A     (3)

4   B     (4)

5   C     (5)

GETFOL:: axiom AAA: A;

AAA : A

GETFOL:: ori 3 4;

6   A or B     (3)

GETFOL:: ori 5 6;

7   C or (A or B)     (5)

GETFOL:: wk 7 by 6 2 1 3;

8   C or (A or B)     (1 2 3 5)

GETFOL:: show premises 8 all;
8  C or (A or B)  (1 2 3 5)
   7  C or (A or B)  (5)
      5  C  (5)
   6  A or B  (3)
      3  A  (3)
   2  A  (2)
   1  A  (1)
   3  A  (3)

GETFOL:: reset;
Resetting the whole GETFOL-system

GETFOL:: declare sentconst A B C D E F;
A has been declared to be a Sentconst
B has been declared to be a Sentconst
C has been declared to be a Sentconst
D has been declared to be a Sentconst
E has been declared to be a Sentconst
F has been declared to be a Sentconst

GETFOL:: assume A A A A B B C D;

1   A     (1)

2   A     (2)

3   A     (3)

4   A     (4)

5   B     (5)

6   B     (6)

7   C     (7)

8   D     (8)

GETFOL:: wk 8 by 1 2 3 4 5 6 7;

9   D     (1 2 3 4 5 6 7 8)

GETFOL:: ctc 9 by 1 5;

10   D     (1 5 7 8)

GETFOL:: show premises 10 all;
10  D  (1 5 7 8)
   9  D  (1 2 3 4 5 6 7 8)
      8  D  (8)
      1  A  (1)
      2  A  (2)
      3  A  (3)
      4  A  (4)
      5  B  (5)
      6  B  (6)
      7  C  (7)
   1  A  (1)
   5  B  (5)

GETFOL:: reset;
Resetting the whole GETFOL-system

GETFOL:: declare sentconst A B C;
A has been declared to be a Sentconst
B has been declared to be a Sentconst
C has been declared to be a Sentconst

GETFOL:: axiom AAA: A;

AAA : A

GETFOL:: assume A A A A B C;

1   A     (1)

2   A     (2)

3   A     (3)

4   A     (4)

5   B     (5)

6   C     (6)

GETFOL:: wk 5 by 1 2 3 4;

7   B     (1 2 3 4 5)

GETFOL:: wk AAA by 6;

8   A     (6)

GETFOL:: cut 8 7;

9   B     (5 6)

GETFOL:: show premises 9 all;
9  B  (5 6)
   8  A  (6)
      AAA  A  
      6  C  (6)
   7  B  (1 2 3 4 5)
      5  B  (5)
      1  A  (1)
      2  A  (2)
      3  A  (3)
      4  A  (4)

GETFOL:: 
GETFOL:: reset;
Resetting the whole GETFOL-system

GETFOL:: declare sentconst A B;
A has been declared to be a Sentconst
B has been declared to be a Sentconst

GETFOL:: ptaut (A imp (B imp A));

1   A imp (B imp A)     

GETFOL:: show premises 1;
1  A imp (B imp A)  

GETFOL:: reset;
Resetting the whole GETFOL-system

GETFOL:: declare sentconst A B;
A has been declared to be a Sentconst
B has been declared to be a Sentconst

GETFOL:: assume A B;

1   A     (1)

2   B     (2)

GETFOL:: ptaut (A and B) by 1 2;

3   A and B     (1 2)

GETFOL:: show premises 3;
3  A and B  (1 2)
   1  A  (1)
   2  B  (2)

GETFOL:: reset;
Resetting the whole GETFOL-system

GETFOL:: declare sentconst A;
A has been declared to be a Sentconst

GETFOL:: declare predconst P 1;
P has been declared to be a Predconst

GETFOL:: declare indconst c;
UNIVERSAL is a sort
c has been declared to be an Indconst

GETFOL:: taut (A imp (P(c) imp A));

1   A imp (P(c) imp A)     

GETFOL:: show premises 1;
1  A imp (P(c) imp A)  

GETFOL:: reset;
Resetting the whole GETFOL-system

GETFOL:: declare indvar x y;
UNIVERSAL is a sort
x has been declared to be an Indvar
y has been declared to be an Indvar

GETFOL:: declare indvar z;
UNIVERSAL is a sort
z has been declared to be an Indvar

GETFOL:: tauteq x=x;

1   x = x     

GETFOL:: tauteq x=y imp y=x;

2   (x = y) imp (y = x)     

GETFOL:: show premises 2;
2  (x = y) imp (y = x)  

GETFOL:: reset;
Resetting the whole GETFOL-system

GETFOL:: declare predconst P 1;
P has been declared to be a Predconst

GETFOL:: declare indvar x y;
UNIVERSAL is a sort
x has been declared to be an Indvar
y has been declared to be an Indvar

GETFOL:: monad forall x. exists y. (P(x) imp P(y));

1   forall x. exists y. (P(x) imp P(y))     

GETFOL:: monad exists y. forall x. (P(x) imp P(y));

2   exists y. forall x. (P(x) imp P(y))     

GETFOL:: andi 1 2;

3   forall x. exists y. (P(x) imp P(y)) and exists y. forall x. (P(x) imp P(y))     

GETFOL:: show premises 3 all;
3  forall x. exists y. (P(x) imp P(y)) and exists y. forall x. (P(x) imp P(y))  
   1  forall x. exists y. (P(x) imp P(y))  
   2  exists y. forall x. (P(x) imp P(y))  

GETFOL:: 
GETFOL:: reset;
Resetting the whole GETFOL-system

GETFOL:: declare indconst a b c;
UNIVERSAL is a sort
a has been declared to be an Indconst
b has been declared to be an Indconst
c has been declared to be an Indconst

GETFOL:: declare funconst F 1;
F has been declared to be a Funconst

GETFOL:: decrep REP;

GETFOL:: attach a dar [REP] a;
a attached to 'a
a is the preferred name of a

GETFOL:: attach b dar [REP] b;
b attached to 'b
b is the preferred name of b

GETFOL:: attach c dar [REP] c;
c attached to 'c
c is the preferred name of c

GETFOL:: DEFLAM F(x) (IF (EQ x (QUOTE a)) (QUOTE b)
		(IF (EQ x (QUOTE b)) (QUOTE c)
		    (QUOTE UNDEF&)));

GETFOL:: attach F to [REP=REP]F;
F attached to F

GETFOL:: simplify F(a);

1   F(a) = b     

GETFOL:: show premises 1;
1  F(a) = b  

GETFOL:: 
GETFOL:: reset;
Resetting the whole GETFOL-system

GETFOL:: declare indconst a b;
UNIVERSAL is a sort
a has been declared to be an Indconst
b has been declared to be an Indconst

GETFOL:: declare predconst q r 1;
q has been declared to be a Predconst
r has been declared to be a Predconst

GETFOL:: declare indvar x;
UNIVERSAL is a sort
x has been declared to be an Indvar

GETFOL:: setbasicsimp s1 at wffs {q(a), forall x. (q(x) iff r(x))};

GETFOL:: assertsimp s1;

1   q(a)     

2   forall x. (q(x) iff r(x))     

GETFOL:: show premises 2 all;
2  forall x. (q(x) iff r(x))  

GETFOL:: reset;
Resetting the whole GETFOL-system

GETFOL:: declare indconst A;
UNIVERSAL is a sort
A has been declared to be an Indconst

GETFOL:: declare indvar X Y;
UNIVERSAL is a sort
X has been declared to be an Indvar
Y has been declared to be an Indvar

GETFOL:: declare funconst F 2;
F has been declared to be a Funconst

GETFOL:: axiom F3: forall X Y. F(X,Y) = Y;

F3 : forall X Y. (F(X, Y) = Y)

GETFOL:: setbasicsimp S6 at facts {F3};

GETFOL:: rewrite F(A,A) by S6;

1   F(A, A) = A     

GETFOL:: show premises 1;
1  F(A, A) = A  
   F3  forall X Y. (F(X, Y) = Y)  

GETFOL:: 
GETFOL:: reset;
Resetting the whole GETFOL-system

GETFOL:: declare indconst a b c;
UNIVERSAL is a sort
a has been declared to be an Indconst
b has been declared to be an Indconst
c has been declared to be an Indconst

GETFOL:: decrep REP;

GETFOL:: attach a dar [REP]a;
a attached to 'a
a is the preferred name of a

GETFOL:: attach b dar [REP]b;
b attached to 'b
b is the preferred name of b

GETFOL:: attach c dar [REP]c;
c attached to 'c
c is the preferred name of c

GETFOL:: declare funconst G 2;
G has been declared to be a Funconst

GETFOL:: declare indvar x y;
UNIVERSAL is a sort
x has been declared to be an Indvar
y has been declared to be an Indvar

GETFOL:: setbasicsimp S at wffs {forall x y.G(x,y)=x};

GETFOL:: declare predconst P 1;
P has been declared to be a Predconst

GETFOL:: DEFLAM P(x) (IF(EQ x (QUOTE a))
	       TRUE
               (IF (EQ x (QUOTE b))
		   FALSE
		   (QUOTE UNDEF&)));

GETFOL:: attach P to [REP]P;
P attached to P

GETFOL:: eval P(G(a,G(b,c))) by S;
G has no interpretation.
Syntactic simplification of G(a, G(b, c)) gives a
Evaluating a gives a
Evaluating G(a, G(b, c)) gives a
Evaluating P(G(a, G(b, c))) gives TRUE

1   P(G(a, G(b, c)))     

GETFOL:: show premises 1;
1  P(G(a, G(b, c)))  

GETFOL:: reset;
Resetting the whole GETFOL-system

GETFOL:: declare indconst a b c;
UNIVERSAL is a sort
a has been declared to be an Indconst
b has been declared to be an Indconst
c has been declared to be an Indconst

GETFOL:: attach b to b;
b attached to 'b

GETFOL:: attach c to c;
c attached to 'c

GETFOL:: declare funconst h 2;
h has been declared to be a Funconst

GETFOL:: DEFLAM h(x y) (QUOTE d);

GETFOL:: attach h to h;
h attached to h

GETFOL:: let a dar h(b c);
Evaluating b gives b
Evaluating c gives c
Evaluating h(b, c) gives h(b, c)
a attached to 'd
a is the preferred name of d

1   a = h(b, c)     

GETFOL:: show premises 1;
1  a = h(b, c)  

GETFOL:: 
GETFOL:: reset;
Resetting the whole GETFOL-system

GETFOL:: namecontext META;
You have named the current context: META

GETFOL:: declare sort TERM WFF;
TERM has been declared to be a sort
WFF has been declared to be a sort

GETFOL:: declare predconst THEOREM 1;
THEOREM has been declared to be a Predconst

GETFOL:: declare funconst mkequal (indvar, indvar) = wff;
wff has been declared to be a sort
indvar has been declared to be a sort
mkequal has been declared to be a Funconst

GETFOL:: declare indvar x [TERM];
TERM is a sort
x has been declared to be an Indvar

GETFOL:: axiom m1: forall x. THEOREM(mkequal(x,x));

m1 : forall x. THEOREM(mkequal(x, x))

GETFOL:: decrep TERM;

GETFOL:: decrep WFF;

GETFOL:: represent {TERM} as TERM;

GETFOL:: represent {WFF} as WFF;

GETFOL:: attach mkequal to [TERM,TERM = WFF] mkequ;
mkequal attached to mkequ

GETFOL:: makecontext obj;
You have created the empty context: obj

GETFOL:: switchcontext obj;
You are now using context: obj
You are switching to a proof with no name.

GETFOL:: declare indconst c;
UNIVERSAL is a sort
c has been declared to be an Indconst

GETFOL:: declare indvar x;
UNIVERSAL is a sort
x has been declared to be an Indvar

GETFOL:: declare funconst f 2;
f has been declared to be a Funconst

GETFOL:: I am switching from the current context to: META
I am switching from the current context to: obj
reflect m1 c;
I am switching from the current context to: META
THEOREM has no interpretation.
THEOREM(mkequal(TERM7, TERM7)): syntactic simplification fails.
Evaluating TERM7 gives TERM7
Evaluating TERM7 gives TERM7
Evaluating mkequal(TERM7, TERM7) gives mkequal(TERM7, TERM7)
Evaluating THEOREM(mkequal(TERM7, TERM7)) doesn' t work
THEOREM(mkequal(TERM7, TERM7)): syntactic simplification fails.
Evaluating TERM7 gives TERM7
Evaluating TERM7 gives TERM7
Evaluating mkequal(TERM7, TERM7) gives mkequal(TERM7, TERM7)
I am switching from the current context to: obj

1   c = c     
Ok!! I am finished doing reflection

GETFOL:: I am switching from the current context to: META
I am switching from the current context to: obj
reflect m1 f(x,f(c,c));
I am switching from the current context to: META
THEOREM has no interpretation.
THEOREM(mkequal(TERM8, TERM8)): syntactic simplification fails.
Evaluating TERM8 gives TERM8
Evaluating TERM8 gives TERM8
Evaluating mkequal(TERM8, TERM8) gives mkequal(TERM8, TERM8)
Evaluating THEOREM(mkequal(TERM8, TERM8)) doesn' t work
THEOREM(mkequal(TERM8, TERM8)): syntactic simplification fails.
Evaluating TERM8 gives TERM8
Evaluating TERM8 gives TERM8
Evaluating mkequal(TERM8, TERM8) gives mkequal(TERM8, TERM8)
I am switching from the current context to: obj

2   f(x, f(c, c)) = f(x, f(c, c))     
Ok!! I am finished doing reflection

GETFOL:: show premises 2;
2  f(x, f(c, c)) = f(x, f(c, c))  

GETFOL:: I am finished fetching proof/reason.tst

GETFOL:: 	reset;
Resetting the whole GETFOL-system

GETFOL:: 	fetch proof/thm.tst;
I am starting to fetch proof/thm.tst

GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: declare sentconst A;
A has been declared to be a Sentconst

GETFOL:: assume A;

1   A     (1)

GETFOL:: impi 1 1;

2   A imp A     

GETFOL:: theorem th1 2;

th1 : A imp A

GETFOL:: show axiom;

th1 : A imp A

GETFOL:: axiom ax1 : A or not A;

ax1 : A or (not A)

GETFOL:: theorem ExcludedMiddle ax1;

ExcludedMiddle : A or (not A)

GETFOL:: show axiom;

th1 : A imp A

ax1 : A or (not A)

ExcludedMiddle : A or (not A)

GETFOL:: declare predpar P 1;
P has been declared to be a Predpar

GETFOL:: declare predconst p 1;
p has been declared to be a Predconst

GETFOL:: declare indvar x;
UNIVERSAL is a sort
x has been declared to be an Indvar

GETFOL:: axiom PI: P(x);

PI : P(x)

GETFOL:: andi PI P:lambda x.p(x) PI P:lambda x.p(x);

3   p(x) and p(x)     

GETFOL:: theorem thPI PI;

thPI : P(x)

GETFOL:: andi thPI P:lambda x.p(x) thPI P:lambda x.p(x);

4   p(x) and p(x)     

GETFOL:: I am finished fetching proof/thm.tst

GETFOL:: 	reset;
Resetting the whole GETFOL-system

GETFOL:: I am finished fetching TEST

GETFOL:: 
GETFOL:: 	fetch sort/partord.tst;
I am starting to fetch sort/partord.tst

GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: Namecontext ini;
You have named the current context: ini

GETFOL:: MAKECONTEXT DECL3;
You have created the empty context: DECL3

GETFOL:: SWITCHCONTEXT DECL3;
You are now using context: DECL3
You are switching to a proof with no name.

GETFOL:: declare sort a b c d e f g h;
a has been declared to be a sort
b has been declared to be a sort
c has been declared to be a sort
d has been declared to be a sort
e has been declared to be a sort
f has been declared to be a sort
g has been declared to be a sort
h has been declared to be a sort

GETFOL:: moregeneral a < b c d e f g h >;

GETFOL:: moregeneral b < c d e f g h >;

GETFOL:: moregeneral c < d e f g h >;

GETFOL:: moregeneral d < e f g h >;

GETFOL:: moregeneral e < f g h >;

GETFOL:: moregeneral f < g h >;

GETFOL:: moregeneral g < h >;

GETFOL:: moregeneral h < a >;
You realise that this makes equivalent h and a

GETFOL:: I am finished fetching sort/partord.tst

GETFOL:: 	reset;
Resetting the whole GETFOL-system

GETFOL:: 	fetch sort/supsort.tst;
I am starting to fetch sort/supsort.tst

GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: 
GETFOL:: declare sort a b c d e f g h;
a has been declared to be a sort
b has been declared to be a sort
c has been declared to be a sort
d has been declared to be a sort
e has been declared to be a sort
f has been declared to be a sort
g has been declared to be a sort
h has been declared to be a sort

GETFOL:: moregeneral a < b c d e f g h >;

GETFOL:: moregeneral b < c d e f g h >;

GETFOL:: moregeneral c < d e f g h >;

GETFOL:: moregeneral d < e f g h >;

GETFOL:: moregeneral e < f g h >;

GETFOL:: moregeneral f < g h >;

GETFOL:: moregeneral g < h >;

GETFOL:: declare indconst a1 a2 a3 [a];
a is a sort
a1 has been declared to be an Indconst
a2 has been declared to be an Indconst
a3 has been declared to be an Indconst

GETFOL:: declare indconst b1 b2 b3 [b];
b is a sort
b1 has been declared to be an Indconst
b2 has been declared to be an Indconst
b3 has been declared to be an Indconst

GETFOL:: declare indconst c1 c2 c3 [c];
c is a sort
c1 has been declared to be an Indconst
c2 has been declared to be an Indconst
c3 has been declared to be an Indconst

GETFOL:: declare indconst d1 d2 d3 [d];
d is a sort
d1 has been declared to be an Indconst
d2 has been declared to be an Indconst
d3 has been declared to be an Indconst

GETFOL:: declare indconst e1 e2 e3 [e];
e is a sort
e1 has been declared to be an Indconst
e2 has been declared to be an Indconst
e3 has been declared to be an Indconst

GETFOL:: declare indconst f1 f2 f3 [f];
f is a sort
f1 has been declared to be an Indconst
f2 has been declared to be an Indconst
f3 has been declared to be an Indconst

GETFOL:: declare indconst g1 g2 g3 [g];
g is a sort
g1 has been declared to be an Indconst
g2 has been declared to be an Indconst
g3 has been declared to be an Indconst

GETFOL:: declare indconst h1 h2 h3 [h];
h is a sort
h1 has been declared to be an Indconst
h2 has been declared to be an Indconst
h3 has been declared to be an Indconst

GETFOL:: declare funconst F ( a)=a;
a is a sort
a is a sort
F has been declared to be a Funconst

GETFOL:: b is a sort
b is a sort

GETFOL:: c is a sort
c is a sort

GETFOL:: d is a sort
d is a sort

GETFOL:: e is a sort
e is a sort

GETFOL:: f is a sort
f is a sort

GETFOL:: g is a sort
g is a sort

GETFOL:: h is a sort
h is a sort

GETFOL:: declare funconst G (a a)=a;
a is a sort
a is a sort
a is a sort
G has been declared to be a Funconst

GETFOL:: b is a sort
a is a sort
b is a sort

GETFOL:: a is a sort
b is a sort
a is a sort

GETFOL:: b is a sort
b is a sort
b is a sort

GETFOL:: a is a sort
c is a sort
a is a sort

GETFOL:: c is a sort
a is a sort
c is a sort

GETFOL:: c is a sort
c is a sort
c is a sort

GETFOL:: c is a sort
b is a sort
c is a sort

GETFOL:: b is a sort
c is a sort
b is a sort

GETFOL:: d is a sort
UNIVERSAL is a sort
d is a sort

GETFOL:: e is a sort
UNIVERSAL is a sort
e is a sort

GETFOL:: f is a sort
UNIVERSAL is a sort
f is a sort

GETFOL:: g is a sort
UNIVERSAL is a sort
g is a sort

GETFOL:: h is a sort
UNIVERSAL is a sort
h is a sort

GETFOL:: Axiom Uno: F(F(c1))=F(c2);

Uno : F(F(c1)) = F(c2)

GETFOL:: Axiom Due: F(F(c1))=G(F(F(c3)),G(F(a1),F(a2)));

Due : F(F(c1)) = G(F(F(c3)), G(F(a1), F(a2)))

GETFOL:: I am finished fetching sort/supsort.tst

GETFOL:: 	load sort/supsort.hgk;
I am computing ...done! 

SUPERSORT worked properly!!!


GETFOL:: 	reset;
Resetting the whole GETFOL-system

GETFOL:: I am finished fetching LONGTEST

GETFOL:: 