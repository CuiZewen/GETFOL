Hi!  I am GETFOL - a Fantastically Overrated Logician.
This is version 2.001, September 1994

GETFOL:: fetch ../tst/prolegomena/RUN;
I am starting to fetch ../tst/prolegomena/RUN

GETFOL:: 
GETFOL:: reset;
Resetting the whole GETFOL-system

GETFOL::  fetch ../tst/prolegomena/sec2.tst;
I am starting to fetch ../tst/prolegomena/sec2.tst

GETFOL:: declare indconst Socrates;
UNIVERSAL is a sort
Socrates has been declared to be an Indconst

GETFOL:: declare predconst Mortal Man 1;
Mortal has been declared to be a Predconst
Man has been declared to be a Predconst

GETFOL:: declare indvar x;
UNIVERSAL is a sort
x has been declared to be an Indvar

GETFOL:: assume (Man(Socrates) and (forall x. (Man(x) imp Mortal(x))));

1   Man(Socrates) and forall x. (Man(x) imp Mortal(x))     (1)

GETFOL:: taut forall x. (Man(x) imp Mortal(x)) by 1;

2   forall x. (Man(x) imp Mortal(x))     (1)

GETFOL:: alle 2 Socrates;

3   Man(Socrates) imp Mortal(Socrates)     (1)

GETFOL:: taut Mortal(Socrates) by 1 3;

4   Mortal(Socrates)     (1)

GETFOL:: impi 1 imp 4;

5   (Man(Socrates) and forall x. (Man(x) imp Mortal(x))) imp Mortal(Socrates)     

GETFOL:: I am finished fetching ../tst/prolegomena/sec2.tst

GETFOL:: reset;
Resetting the whole GETFOL-system

GETFOL::  fetch ../tst/prolegomena/sec6.tst;
I am starting to fetch ../tst/prolegomena/sec6.tst

GETFOL:: fetch ../tst/prolegomena/appa.tst;
I am starting to fetch ../tst/prolegomena/appa.tst

GETFOL:: declare sort NATNUM;
NATNUM has been declared to be a sort

GETFOL:: declare indvar n m p q [NATNUM];
NATNUM is a sort
n has been declared to be an Indvar
m has been declared to be an Indvar
p has been declared to be an Indvar
q has been declared to be an Indvar

GETFOL:: declare indconst zro [NATNUM];
NATNUM is a sort
zro has been declared to be an Indconst

GETFOL:: declare funconst suc prd (NATNUM) = NATNUM;
NATNUM is a sort
NATNUM is a sort
suc has been declared to be a Funconst
prd has been declared to be a Funconst

GETFOL:: declare funconst +(NATNUM,NATNUM) = NATNUM [inf = 450 455];
NATNUM is a sort
NATNUM is a sort
NATNUM is a sort
+ has been declared to be a Funconst

GETFOL:: declare funconst *(NATNUM,NATNUM) = NATNUM [inf = 550 555];
NATNUM is a sort
NATNUM is a sort
NATNUM is a sort
* has been declared to be a Funconst

GETFOL:: declare predconst < 2 [inf];
< has been declared to be a Predconst

GETFOL:: declare predpar P 1;
P has been declared to be a Predpar

GETFOL:: axiom ONEONE: forall n m.(suc(n)=suc(m) imp n=m);

ONEONE : forall n m. ((suc(n) = suc(m)) imp (n = m))

GETFOL:: axiom SUCC1: forall n.not(zro=suc(n));

SUCC1 : forall n. (not (zro = suc(n)))

GETFOL:: axiom SUCC2: forall n.not(zro=n) imp exists m.n=suc(m);

SUCC2 : forall n. (not (zro = n)) imp exists m. (n = suc(m))

GETFOL:: axiom PLUS0: forall n. n + zro = n;

PLUS0 : forall n. ((n + zro) = n)

GETFOL:: axiom PLUS: forall n m. n+suc(m)=suc(n+m);

PLUS : forall n m. ((n + suc(m)) = suc(n + m))

GETFOL:: axiom TIMES0: forall n. n * zro = zro;

TIMES0 : forall n. ((n * zro) = zro)

GETFOL:: axiom TIMES: forall n m. n*suc(m)=(n*m)+n;

TIMES : forall n m. ((n * suc(m)) = ((n * m) + n))

GETFOL:: setbasicsimp PEANO at facts {ONEONE,SUCC1,SUCC2,PLUS0,PLUS,TIMES0,TIMES};

GETFOL:: axiom INDUCT: P(zro) and forall n.(P(n) imp P(suc(n))) imp forall n.P(n);

INDUCT : (P(zro) and forall n. (P(n) imp P(suc(n)))) imp forall n. P(n)

GETFOL:: decrep NATNUMREP;

GETFOL:: represent {NATNUM} as NATNUMREP;

GETFOL:: attach zro to 0;
zro attached to '0

GETFOL:: attach suc to ADD1;
suc attached to ADD1

GETFOL:: deflam prd(x) (COND ((> x 0) (SUB1 x)) (T 0));

GETFOL:: attach prd to prd;
prd attached to prd

GETFOL:: attach + to +;
+ attached to +

GETFOL:: attach * to *;
* attached to *

GETFOL:: attach < to <;
< attached to <

GETFOL:: I am finished fetching ../tst/prolegomena/appa.tst

GETFOL:: declare funconst fact(NATNUM)=NATNUM;
NATNUM is a sort
NATNUM is a sort
fact has been declared to be a Funconst

GETFOL:: axiom FACT: forall n.fact(n)=trmif n=zro then suc(zro) else n*fact(prd(n));

FACT : forall n. (fact(n) = (trmif (n = zro) then suc(zro) else (n * fact(prd(n)))))

GETFOL:: simplify (zro=zro iff TRUE);

1   (zro = zro) iff TRUE     

GETFOL:: setbasicsimp N0 at facts {1};

GETFOL:: setbasicsimp FACT_UNFOLD at facts {FACT};

GETFOL:: rewrite (fact(zro)) by N0 uni FACT_UNFOLD uni LOGICTREE;

2   fact(zro) = suc(zro)     

GETFOL:: setbasicsimp F0 at facts {2};

GETFOL:: simplify (suc(zro)=zro iff FALSE);

3   (suc(zro) = zro) iff FALSE     

GETFOL:: setbasicsimp N1 at facts {3};

GETFOL:: axiom PRDSUC: forall n. prd(suc(n))=n;

PRDSUC : forall n. (prd(suc(n)) = n)

GETFOL:: setbasicsimp PRDSUC at facts {PRDSUC};

GETFOL:: rewrite (fact(suc(zro))) by N0 uni N1 uni FACT_UNFOLD uni PRDSUC uni LOGICTREE;

4   fact(suc(zro)) = (suc(zro) * suc(zro))     

GETFOL:: simplify (suc(suc(zro))=zro iff FALSE);

5   (suc(suc(zro)) = zro) iff FALSE     

GETFOL:: setbasicsimp N2 at facts {5};

GETFOL:: simplify (suc(suc(suc(zro)))=zro iff FALSE);

6   (suc(suc(suc(zro))) = zro) iff FALSE     

GETFOL:: setbasicsimp N3 at facts {6};

GETFOL:: rewrite (fact(suc(suc(suc(zro))))) by N0 uni N1 uni N2 uni N3 uni FACT_UNFOLD uni PRDSUC uni LOGICTREE;

7   fact(suc(suc(suc(zro)))) = (suc(suc(suc(zro))) * (suc(suc(zro)) * (suc(zro) * suc(zro))))     

GETFOL:: rewrite (fact(suc(suc(suc(zro))))) by N0 uni N1 uni N2 uni N3 uni FACT_UNFOLD uni PRDSUC uni PEANO uni LOGICTREE;

8   fact(suc(suc(suc(zro)))) = suc(suc(suc(suc(suc(suc(zro))))))     

GETFOL:: axiom EQSYM: forall n m.(n = m iff m = n);

EQSYM : forall n m. ((n = m) iff (m = n))

GETFOL:: setbasicsimp EQSYM at facts {EQSYM};

GETFOL:: rewrite forall n.(suc(n)=zro iff FALSE) by PEANO uni EQSYM uni LOGICTREE;

9   forall n. ((suc(n) = zro) iff FALSE)     

GETFOL:: setbasicsimp NS at facts {9};

GETFOL:: rewrite (fact(suc(suc(suc(zro))))) by N0 uni NS uni FACT_UNFOLD uni PRDSUC uni PEANO uni LOGICTREE;

10   fact(suc(suc(suc(zro)))) = suc(suc(suc(suc(suc(suc(zro))))))     

GETFOL:: rewrite (fact(suc(suc(suc(suc(zro)))))) by N0 uni NS uni FACT_UNFOLD uni PRDSUC uni PEANO uni LOGICTREE;

11   fact(suc(suc(suc(suc(zro))))) = suc(suc(suc(suc(suc(suc(suc(suc(suc(suc(suc(suc(suc(suc(suc(suc(suc(suc(suc(suc(suc(suc(suc(suc(zro))))))))))))))))))))))))     

GETFOL:: I am finished fetching ../tst/prolegomena/sec6.tst

GETFOL:: reset;
Resetting the whole GETFOL-system

GETFOL::  fetch ../tst/prolegomena/sec9.tst;
I am starting to fetch ../tst/prolegomena/sec9.tst

GETFOL:: NAMECONTEXT META;
You have named the current context: META

GETFOL:: DECLARE sort WFF FACT;
WFF has been declared to be a sort
FACT has been declared to be a sort

GETFOL:: DECREP WFF FACT;

GETFOL:: REPRESENT {WFF} as WFF;

GETFOL:: REPRESENT {FACT} as FACT;

GETFOL:: DECLARE predconst THEOREM 1;
THEOREM has been declared to be a Predconst

GETFOL:: DECLARE funconst mkand (WFF,WFF)=WFF;
WFF is a sort
WFF is a sort
WFF is a sort
mkand has been declared to be a Funconst

GETFOL:: DECLARE funconst wffof (FACT)=WFF;
WFF is a sort
FACT is a sort
wffof has been declared to be a Funconst

GETFOL:: DECLARE indvar A B [WFF];
WFF is a sort
A has been declared to be an Indvar
B has been declared to be an Indvar

GETFOL:: DECLARE indvar T1 T2 [FACT];
FACT is a sort
T1 has been declared to be an Indvar
T2 has been declared to be an Indvar

GETFOL:: AXIOM ANDI: forall A B.THEOREM(mkand(A,B));

ANDI : forall A B. THEOREM(mkand(A, B))

GETFOL:: AXIOM ANDI_SOUND: forall T1 T2.THEOREM(mkand(wffof(T1),wffof(T2)));

ANDI_SOUND : forall T1 T2. THEOREM(mkand(wffof(T1), wffof(T2)))

GETFOL:: ATTACH mkand TO [WFF,WFF=WFF] mkand;
mkand attached to mkand

GETFOL:: deflam wffof(x) (CADR x);

GETFOL:: ATTACH wffof TO [FACT=WFF] wffof;
wffof attached to wffof

GETFOL:: MAKECONTEXT OBJ;
You have created the empty context: OBJ

GETFOL:: SWITCHCONTEXT OBJ;
You are now using context: OBJ
You are switching to a proof with no name.

GETFOL:: declare sentconst A B;
A has been declared to be a Sentconst
B has been declared to be a Sentconst

GETFOL:: I am switching from the current context to: META
I am switching from the current context to: OBJ
reflect ANDI A B;
I am switching from the current context to: META
THEOREM has no interpretation.
THEOREM(mkand(WFF289, WFF290)): syntactic simplification fails.
Evaluating WFF289 gives WFF289
Evaluating WFF290 gives WFF290
Evaluating mkand(WFF289, WFF290) gives mkand(WFF289, WFF290)
Evaluating THEOREM(mkand(WFF289, WFF290)) doesn' t work
THEOREM(mkand(WFF289, WFF290)): syntactic simplification fails.
Evaluating WFF289 gives WFF289
Evaluating WFF290 gives WFF290
Evaluating mkand(WFF289, WFF290) gives mkand(WFF289, WFF290)
I am switching from the current context to: OBJ

1   A and B     
Ok!! I am finished doing reflection

GETFOL:: nameproof P_AND_UNSOUND;
You have named the current proof: P_AND_UNSOUND

GETFOL:: makeproof P1;
You have created the empty proof: P1

GETFOL:: switchproof P1;
You are now using the proof: P1

GETFOL:: assume A;

1   A     (1)

GETFOL:: impi 1 1;

2   A imp A     

GETFOL:: theorem T1 2;

T1 : A imp A

GETFOL:: makeproof P2;
You have created the empty proof: P2

GETFOL:: switchproof P2;
You are now using the proof: P2

GETFOL:: assume B;

1   B     (1)

GETFOL:: impi 1 1;

2   B imp B     

GETFOL:: theorem T2 2;

T2 : B imp B

GETFOL:: makeproof P_ANDS;
You have created the empty proof: P_ANDS

GETFOL:: switchproof P_ANDS;
You are now using the proof: P_ANDS

GETFOL:: andi T1 T2;

1   (A imp A) and (B imp B)     

GETFOL:: I am switching from the current context to: META
I am switching from the current context to: OBJ
reflect ANDI A B;
I am switching from the current context to: META
THEOREM has no interpretation.
THEOREM(mkand(WFF291, WFF292)): syntactic simplification fails.
Evaluating WFF291 gives WFF291
Evaluating WFF292 gives WFF292
Evaluating mkand(WFF291, WFF292) gives mkand(WFF291, WFF292)
Evaluating THEOREM(mkand(WFF291, WFF292)) doesn' t work
THEOREM(mkand(WFF291, WFF292)): syntactic simplification fails.
Evaluating WFF291 gives WFF291
Evaluating WFF292 gives WFF292
Evaluating mkand(WFF291, WFF292) gives mkand(WFF291, WFF292)
I am switching from the current context to: OBJ

2   A and B     
Ok!! I am finished doing reflection

GETFOL:: I am switching from the current context to: META
I am switching from the current context to: OBJ
reflect ANDI_SOUND T1 T2;
I am switching from the current context to: META
THEOREM has no interpretation.
THEOREM(mkand(wffof(FACT293), wffof(FACT294))): syntactic simplification fails.
Evaluating FACT293 gives FACT293
Evaluating wffof(FACT293) gives wffof(FACT293)
Evaluating FACT294 gives FACT294
Evaluating wffof(FACT294) gives wffof(FACT294)
Evaluating mkand(wffof(FACT293), wffof(FACT294)) gives mkand(wffof(FACT293), wffof(FACT294))
Evaluating THEOREM(mkand(wffof(FACT293), wffof(FACT294))) doesn' t work
THEOREM(mkand(wffof(FACT293), wffof(FACT294))): syntactic simplification fails.
Evaluating FACT293 gives FACT293
Evaluating wffof(FACT293) gives wffof(FACT293)
Evaluating FACT294 gives FACT294
Evaluating wffof(FACT294) gives wffof(FACT294)
Evaluating mkand(wffof(FACT293), wffof(FACT294)) gives mkand(wffof(FACT293), wffof(FACT294))
I am switching from the current context to: OBJ

3   (A imp A) and (B imp B)     
Ok!! I am finished doing reflection

GETFOL:: I am switching from the current context to: META
I am switching from the current context to: OBJ
reflect ANDI FALSE FALSE;
I am switching from the current context to: META
THEOREM has no interpretation.
THEOREM(mkand(WFF295, WFF296)): syntactic simplification fails.
Evaluating WFF295 gives WFF296
Evaluating WFF296 gives WFF296
Evaluating mkand(WFF295, WFF296) gives mkand(WFF296, WFF296)
Evaluating THEOREM(mkand(WFF295, WFF296)) doesn' t work
THEOREM(mkand(WFF296, WFF296)): syntactic simplification fails.
Evaluating WFF296 gives WFF296
Evaluating WFF296 gives WFF296
Evaluating mkand(WFF296, WFF296) gives mkand(WFF296, WFF296)
I am switching from the current context to: OBJ

4   FALSE and FALSE     
Ok!! I am finished doing reflection

GETFOL:: I am finished fetching ../tst/prolegomena/sec9.tst

GETFOL:: reset;
Resetting the whole GETFOL-system

GETFOL::  fetch ../tst/prolegomena/appa.tst;
I am starting to fetch ../tst/prolegomena/appa.tst

GETFOL:: declare sort NATNUM;
NATNUM has been declared to be a sort

GETFOL:: declare indvar n m p q [NATNUM];
NATNUM is a sort
n has been declared to be an Indvar
m has been declared to be an Indvar
p has been declared to be an Indvar
q has been declared to be an Indvar

GETFOL:: declare indconst zro [NATNUM];
NATNUM is a sort
zro has been declared to be an Indconst

GETFOL:: declare funconst suc prd (NATNUM) = NATNUM;
NATNUM is a sort
NATNUM is a sort
suc has been declared to be a Funconst
prd has been declared to be a Funconst

GETFOL:: declare funconst +(NATNUM,NATNUM) = NATNUM [inf = 450 455];
NATNUM is a sort
NATNUM is a sort
NATNUM is a sort
+ has been declared to be a Funconst

GETFOL:: declare funconst *(NATNUM,NATNUM) = NATNUM [inf = 550 555];
NATNUM is a sort
NATNUM is a sort
NATNUM is a sort
* has been declared to be a Funconst

GETFOL:: declare predconst < 2 [inf];
< has been declared to be a Predconst

GETFOL:: declare predpar P 1;
P has been declared to be a Predpar

GETFOL:: axiom ONEONE: forall n m.(suc(n)=suc(m) imp n=m);

ONEONE : forall n m. ((suc(n) = suc(m)) imp (n = m))

GETFOL:: axiom SUCC1: forall n.not(zro=suc(n));

SUCC1 : forall n. (not (zro = suc(n)))

GETFOL:: axiom SUCC2: forall n.not(zro=n) imp exists m.n=suc(m);

SUCC2 : forall n. (not (zro = n)) imp exists m. (n = suc(m))

GETFOL:: axiom PLUS0: forall n. n + zro = n;

PLUS0 : forall n. ((n + zro) = n)

GETFOL:: axiom PLUS: forall n m. n+suc(m)=suc(n+m);

PLUS : forall n m. ((n + suc(m)) = suc(n + m))

GETFOL:: axiom TIMES0: forall n. n * zro = zro;

TIMES0 : forall n. ((n * zro) = zro)

GETFOL:: axiom TIMES: forall n m. n*suc(m)=(n*m)+n;

TIMES : forall n m. ((n * suc(m)) = ((n * m) + n))

GETFOL:: setbasicsimp PEANO at facts {ONEONE,SUCC1,SUCC2,PLUS0,PLUS,TIMES0,TIMES};

GETFOL:: axiom INDUCT: P(zro) and forall n.(P(n) imp P(suc(n))) imp forall n.P(n);

INDUCT : (P(zro) and forall n. (P(n) imp P(suc(n)))) imp forall n. P(n)

GETFOL:: decrep NATNUMREP;

GETFOL:: represent {NATNUM} as NATNUMREP;

GETFOL:: attach zro to 0;
zro attached to '0

GETFOL:: attach suc to ADD1;
suc attached to ADD1

GETFOL:: deflam prd(x) (COND ((> x 0) (SUB1 x)) (T 0));

GETFOL:: attach prd to prd;
prd attached to prd

GETFOL:: attach + to +;
+ attached to +

GETFOL:: attach * to *;
* attached to *

GETFOL:: attach < to <;
< attached to <

GETFOL:: I am finished fetching ../tst/prolegomena/appa.tst

GETFOL:: reset;
Resetting the whole GETFOL-system

GETFOL::  fetch ../tst/prolegomena/appb.tst;
I am starting to fetch ../tst/prolegomena/appb.tst

GETFOL:: declare sort Sexp Lisp Null Atom;
Sexp has been declared to be a sort
Lisp has been declared to be a sort
Null has been declared to be a sort
Atom has been declared to be a sort

GETFOL:: declare indvar x y z [Sexp];
Sexp is a sort
x has been declared to be an Indvar
y has been declared to be an Indvar
z has been declared to be an Indvar

GETFOL:: declare indvar u v w [List];
List has been declared to be a sort
u has been declared to be an Indvar
v has been declared to be an Indvar
w has been declared to be an Indvar

GETFOL:: declare indconst nil [Null];
Null is a sort
nil has been declared to be an Indconst

GETFOL:: declare funconst car cdr 1;
car has been declared to be a Funconst
cdr has been declared to be a Funconst

GETFOL:: declare funconst cons(Sexp,List)=List;
List is a sort
Sexp is a sort
List is a sort
cons has been declared to be a Funconst

GETFOL:: declare funconst rev 1;
rev has been declared to be a Funconst

GETFOL:: declare funconst @ 2 [inf];
@ has been declared to be a Funconst

GETFOL:: moregeneral Sexp < List, Atom, Null >;

GETFOL:: moregeneral List < Null >;

GETFOL:: DECREP SEXPREP;

GETFOL:: represent {Sexp} as SEXPREP;

GETFOL:: axiom CAR: forall x y. car(cons(x,y))=x;

CAR : forall x y. (car(cons(x, y)) = x)

GETFOL:: axiom CDR: forall x y. cdr(cons(x,y))=y;

CDR : forall x y. (cdr(cons(x, y)) = y)

GETFOL:: axiom CONS: forall x y. not(Null(cons(x,y)));

CONS : forall x y. (not Null(cons(x, y)))

GETFOL:: setbasicsimp Basic at facts {CAR,CDR,CONS};

GETFOL:: axiom REV: forall u.(rev(u) = trmif Null(u) then u else rev(cdr(u)) @ cons(car(u),nil));

REV : forall u. (rev(u) = (trmif Null(u) then u else (rev(cdr(u)) @ cons(car(u), nil))))

GETFOL:: axiom APPEND: forall u v.(u@v = trmif Null(u) then v else cons(car(u),cdr(u)@v));

APPEND : forall u v. ((u @ v) = (trmif Null(u) then v else cons(car(u), cdr(u) @ v)))

GETFOL:: setbasicsimp Funs at facts {REV,APPEND};

GETFOL:: I am finished fetching ../tst/prolegomena/appb.tst

GETFOL:: reset;
Resetting the whole GETFOL-system

GETFOL::  fetch ../tst/prolegomena/appd.tst;
I am starting to fetch ../tst/prolegomena/appd.tst

GETFOL:: fetch ../tst/prolegomena/appa.tst;
I am starting to fetch ../tst/prolegomena/appa.tst

GETFOL:: declare sort NATNUM;
NATNUM has been declared to be a sort

GETFOL:: declare indvar n m p q [NATNUM];
NATNUM is a sort
n has been declared to be an Indvar
m has been declared to be an Indvar
p has been declared to be an Indvar
q has been declared to be an Indvar

GETFOL:: declare indconst zro [NATNUM];
NATNUM is a sort
zro has been declared to be an Indconst

GETFOL:: declare funconst suc prd (NATNUM) = NATNUM;
NATNUM is a sort
NATNUM is a sort
suc has been declared to be a Funconst
prd has been declared to be a Funconst

GETFOL:: declare funconst +(NATNUM,NATNUM) = NATNUM [inf = 450 455];
NATNUM is a sort
NATNUM is a sort
NATNUM is a sort
+ has been declared to be a Funconst

GETFOL:: declare funconst *(NATNUM,NATNUM) = NATNUM [inf = 550 555];
NATNUM is a sort
NATNUM is a sort
NATNUM is a sort
* has been declared to be a Funconst

GETFOL:: declare predconst < 2 [inf];
< has been declared to be a Predconst

GETFOL:: declare predpar P 1;
P has been declared to be a Predpar

GETFOL:: axiom ONEONE: forall n m.(suc(n)=suc(m) imp n=m);

ONEONE : forall n m. ((suc(n) = suc(m)) imp (n = m))

GETFOL:: axiom SUCC1: forall n.not(zro=suc(n));

SUCC1 : forall n. (not (zro = suc(n)))

GETFOL:: axiom SUCC2: forall n.not(zro=n) imp exists m.n=suc(m);

SUCC2 : forall n. (not (zro = n)) imp exists m. (n = suc(m))

GETFOL:: axiom PLUS0: forall n. n + zro = n;

PLUS0 : forall n. ((n + zro) = n)

GETFOL:: axiom PLUS: forall n m. n+suc(m)=suc(n+m);

PLUS : forall n m. ((n + suc(m)) = suc(n + m))

GETFOL:: axiom TIMES0: forall n. n * zro = zro;

TIMES0 : forall n. ((n * zro) = zro)

GETFOL:: axiom TIMES: forall n m. n*suc(m)=(n*m)+n;

TIMES : forall n m. ((n * suc(m)) = ((n * m) + n))

GETFOL:: setbasicsimp PEANO at facts {ONEONE,SUCC1,SUCC2,PLUS0,PLUS,TIMES0,TIMES};

GETFOL:: axiom INDUCT: P(zro) and forall n.(P(n) imp P(suc(n))) imp forall n.P(n);

INDUCT : (P(zro) and forall n. (P(n) imp P(suc(n)))) imp forall n. P(n)

GETFOL:: decrep NATNUMREP;

GETFOL:: represent {NATNUM} as NATNUMREP;

GETFOL:: attach zro to 0;
zro attached to '0

GETFOL:: attach suc to ADD1;
suc attached to ADD1

GETFOL:: deflam prd(x) (COND ((> x 0) (SUB1 x)) (T 0));

GETFOL:: attach prd to prd;
prd attached to prd

GETFOL:: attach + to +;
+ attached to +

GETFOL:: attach * to *;
* attached to *

GETFOL:: attach < to <;
< attached to <

GETFOL:: I am finished fetching ../tst/prolegomena/appa.tst

GETFOL:: fetch ../tst/prolegomena/appb.tst;
I am starting to fetch ../tst/prolegomena/appb.tst

GETFOL:: declare sort Sexp Lisp Null Atom;
Sexp has been declared to be a sort
Lisp has been declared to be a sort
Null has been declared to be a sort
Atom has been declared to be a sort

GETFOL:: declare indvar x y z [Sexp];
Sexp is a sort
x has been declared to be an Indvar
y has been declared to be an Indvar
z has been declared to be an Indvar

GETFOL:: declare indvar u v w [List];
List has been declared to be a sort
u has been declared to be an Indvar
v has been declared to be an Indvar
w has been declared to be an Indvar

GETFOL:: declare indconst nil [Null];
Null is a sort
nil has been declared to be an Indconst

GETFOL:: declare funconst car cdr 1;
car has been declared to be a Funconst
cdr has been declared to be a Funconst

GETFOL:: declare funconst cons(Sexp,List)=List;
List is a sort
Sexp is a sort
List is a sort
cons has been declared to be a Funconst

GETFOL:: declare funconst rev 1;
rev has been declared to be a Funconst

GETFOL:: declare funconst @ 2 [inf];
@ has been declared to be a Funconst

GETFOL:: moregeneral Sexp < List, Atom, Null >;

GETFOL:: moregeneral List < Null >;

GETFOL:: DECREP SEXPREP;

GETFOL:: represent {Sexp} as SEXPREP;

GETFOL:: axiom CAR: forall x y. car(cons(x,y))=x;

CAR : forall x y. (car(cons(x, y)) = x)

GETFOL:: axiom CDR: forall x y. cdr(cons(x,y))=y;

CDR : forall x y. (cdr(cons(x, y)) = y)

GETFOL:: axiom CONS: forall x y. not(Null(cons(x,y)));

CONS : forall x y. (not Null(cons(x, y)))

GETFOL:: setbasicsimp Basic at facts {CAR,CDR,CONS};

GETFOL:: axiom REV: forall u.(rev(u) = trmif Null(u) then u else rev(cdr(u)) @ cons(car(u),nil));

REV : forall u. (rev(u) = (trmif Null(u) then u else (rev(cdr(u)) @ cons(car(u), nil))))

GETFOL:: axiom APPEND: forall u v.(u@v = trmif Null(u) then v else cons(car(u),cdr(u)@v));

APPEND : forall u v. ((u @ v) = (trmif Null(u) then v else cons(car(u), cdr(u) @ v)))

GETFOL:: setbasicsimp Funs at facts {REV,APPEND};

GETFOL:: I am finished fetching ../tst/prolegomena/appb.tst

GETFOL:: declare funconst length 1;
length has been declared to be a Funconst

GETFOL:: attach cons to CONS;
cons attached to CONS

GETFOL:: attach car to CAR;
car attached to CAR

GETFOL:: attach cdr to CDR;
cdr attached to CDR

GETFOL:: attach nil to NIL;
nil attached to 'NIL

GETFOL:: attach length to LENGTH;
length attached to LENGTH

GETFOL:: simplify length(cons(zro, cons(suc(zro), nil)))=suc(suc(zro));

1   length(cons(zro, cons(suc(zro), nil))) = suc(suc(zro))     

GETFOL:: simplify zro < prd(suc(suc(zro)));

2   zro < prd(suc(suc(zro)))     

GETFOL:: I am finished fetching ../tst/prolegomena/appd.tst

GETFOL:: reset;
Resetting the whole GETFOL-system

GETFOL::  fetch ../tst/prolegomena/appe.tst;
I am starting to fetch ../tst/prolegomena/appe.tst

GETFOL:: fetch ../tst/prolegomena/appa.tst;
I am starting to fetch ../tst/prolegomena/appa.tst

GETFOL:: declare sort NATNUM;
NATNUM has been declared to be a sort

GETFOL:: declare indvar n m p q [NATNUM];
NATNUM is a sort
n has been declared to be an Indvar
m has been declared to be an Indvar
p has been declared to be an Indvar
q has been declared to be an Indvar

GETFOL:: declare indconst zro [NATNUM];
NATNUM is a sort
zro has been declared to be an Indconst

GETFOL:: declare funconst suc prd (NATNUM) = NATNUM;
NATNUM is a sort
NATNUM is a sort
suc has been declared to be a Funconst
prd has been declared to be a Funconst

GETFOL:: declare funconst +(NATNUM,NATNUM) = NATNUM [inf = 450 455];
NATNUM is a sort
NATNUM is a sort
NATNUM is a sort
+ has been declared to be a Funconst

GETFOL:: declare funconst *(NATNUM,NATNUM) = NATNUM [inf = 550 555];
NATNUM is a sort
NATNUM is a sort
NATNUM is a sort
* has been declared to be a Funconst

GETFOL:: declare predconst < 2 [inf];
< has been declared to be a Predconst

GETFOL:: declare predpar P 1;
P has been declared to be a Predpar

GETFOL:: axiom ONEONE: forall n m.(suc(n)=suc(m) imp n=m);

ONEONE : forall n m. ((suc(n) = suc(m)) imp (n = m))

GETFOL:: axiom SUCC1: forall n.not(zro=suc(n));

SUCC1 : forall n. (not (zro = suc(n)))

GETFOL:: axiom SUCC2: forall n.not(zro=n) imp exists m.n=suc(m);

SUCC2 : forall n. (not (zro = n)) imp exists m. (n = suc(m))

GETFOL:: axiom PLUS0: forall n. n + zro = n;

PLUS0 : forall n. ((n + zro) = n)

GETFOL:: axiom PLUS: forall n m. n+suc(m)=suc(n+m);

PLUS : forall n m. ((n + suc(m)) = suc(n + m))

GETFOL:: axiom TIMES0: forall n. n * zro = zro;

TIMES0 : forall n. ((n * zro) = zro)

GETFOL:: axiom TIMES: forall n m. n*suc(m)=(n*m)+n;

TIMES : forall n m. ((n * suc(m)) = ((n * m) + n))

GETFOL:: setbasicsimp PEANO at facts {ONEONE,SUCC1,SUCC2,PLUS0,PLUS,TIMES0,TIMES};

GETFOL:: axiom INDUCT: P(zro) and forall n.(P(n) imp P(suc(n))) imp forall n.P(n);

INDUCT : (P(zro) and forall n. (P(n) imp P(suc(n)))) imp forall n. P(n)

GETFOL:: decrep NATNUMREP;

GETFOL:: represent {NATNUM} as NATNUMREP;

GETFOL:: attach zro to 0;
zro attached to '0

GETFOL:: attach suc to ADD1;
suc attached to ADD1

GETFOL:: deflam prd(x) (COND ((> x 0) (SUB1 x)) (T 0));

GETFOL:: attach prd to prd;
prd attached to prd

GETFOL:: attach + to +;
+ attached to +

GETFOL:: attach * to *;
* attached to *

GETFOL:: attach < to <;
< attached to <

GETFOL:: I am finished fetching ../tst/prolegomena/appa.tst

GETFOL:: fetch ../tst/prolegomena/appb.tst;
I am starting to fetch ../tst/prolegomena/appb.tst

GETFOL:: declare sort Sexp Lisp Null Atom;
Sexp has been declared to be a sort
Lisp has been declared to be a sort
Null has been declared to be a sort
Atom has been declared to be a sort

GETFOL:: declare indvar x y z [Sexp];
Sexp is a sort
x has been declared to be an Indvar
y has been declared to be an Indvar
z has been declared to be an Indvar

GETFOL:: declare indvar u v w [List];
List has been declared to be a sort
u has been declared to be an Indvar
v has been declared to be an Indvar
w has been declared to be an Indvar

GETFOL:: declare indconst nil [Null];
Null is a sort
nil has been declared to be an Indconst

GETFOL:: declare funconst car cdr 1;
car has been declared to be a Funconst
cdr has been declared to be a Funconst

GETFOL:: declare funconst cons(Sexp,List)=List;
List is a sort
Sexp is a sort
List is a sort
cons has been declared to be a Funconst

GETFOL:: declare funconst rev 1;
rev has been declared to be a Funconst

GETFOL:: declare funconst @ 2 [inf];
@ has been declared to be a Funconst

GETFOL:: moregeneral Sexp < List, Atom, Null >;

GETFOL:: moregeneral List < Null >;

GETFOL:: DECREP SEXPREP;

GETFOL:: represent {Sexp} as SEXPREP;

GETFOL:: axiom CAR: forall x y. car(cons(x,y))=x;

CAR : forall x y. (car(cons(x, y)) = x)

GETFOL:: axiom CDR: forall x y. cdr(cons(x,y))=y;

CDR : forall x y. (cdr(cons(x, y)) = y)

GETFOL:: axiom CONS: forall x y. not(Null(cons(x,y)));

CONS : forall x y. (not Null(cons(x, y)))

GETFOL:: setbasicsimp Basic at facts {CAR,CDR,CONS};

GETFOL:: axiom REV: forall u.(rev(u) = trmif Null(u) then u else rev(cdr(u)) @ cons(car(u),nil));

REV : forall u. (rev(u) = (trmif Null(u) then u else (rev(cdr(u)) @ cons(car(u), nil))))

GETFOL:: axiom APPEND: forall u v.(u@v = trmif Null(u) then v else cons(car(u),cdr(u)@v));

APPEND : forall u v. ((u @ v) = (trmif Null(u) then v else cons(car(u), cdr(u) @ v)))

GETFOL:: setbasicsimp Funs at facts {REV,APPEND};

GETFOL:: I am finished fetching ../tst/prolegomena/appb.tst

GETFOL:: simplify Null(nil);

1   Null(nil)     

GETFOL:: setbasicsimp S1 at facts {1};

GETFOL:: rewrite rev(cons(x,nil)) by Basic uni Funs uni S1 uni LOGICTREE;

2   rev(cons(x, nil)) = cons(x, nil)     

GETFOL:: I am finished fetching ../tst/prolegomena/appe.tst

GETFOL:: reset;
Resetting the whole GETFOL-system

GETFOL:: I am finished fetching ../tst/prolegomena/RUN
