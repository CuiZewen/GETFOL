{% extends "base_livecode.html" %}

{% block title %}FOL{% endblock %}

{% block content %}
<script>
function livecode_process_data(id, data) {
  var i = data.indexOf("Hi!");
  if (i == -1) return data;
  return data.substring(i);
}
</script>

<div class="live norun hidden" id="header">
probe all;
</div>

<h1>Prolegomena</h1>

<h2>Section 2: Syllogism</h2>
<div class="live" id="sec2" data-lib="header">
declare indconst Socrates;
declare predconst Mortal Man 1;
declare indvar x;

assume (Man(Socrates) and (forall x. (Man(x) imp Mortal(x))));

taut forall x. (Man(x) imp Mortal(x)) by 1;
alle 2 Socrates;
taut Mortal(Socrates) by 1 3;

impi 1 imp 4;
</div>

<h2>Section 6: Factorial</h2>

<div class="live" id="sec6" data-lib="appa header">
declare funconst fact(NATNUM)=NATNUM;
axiom FACT: forall n.fact(n)=trmif n=zro then suc(zro) else n*fact(prd(n));

simplify (zro=zro iff TRUE);
setbasicsimp N0 at facts {1};
setbasicsimp FACT_UNFOLD at facts {FACT};
rewrite (fact(zro)) by N0 uni FACT_UNFOLD uni LOGICTREE;
setbasicsimp F0 at facts {2};

simplify (suc(zro)=zro iff FALSE);
setbasicsimp N1 at facts {3};

axiom PRDSUC: forall n. prd(suc(n))=n;
setbasicsimp PRDSUC at facts {PRDSUC};

rewrite (fact(suc(zro))) by N0 uni N1 uni FACT_UNFOLD uni PRDSUC uni LOGICTREE;

simplify (suc(suc(zro))=zro iff FALSE);
setbasicsimp N2 at facts {5};

simplify (suc(suc(suc(zro)))=zro iff FALSE);
setbasicsimp N3 at facts {6};

rewrite (fact(suc(suc(suc(zro))))) by N0 uni N1 uni N2 uni N3 uni FACT_UNFOLD uni PRDSUC uni LOGICTREE;

rewrite (fact(suc(suc(suc(zro))))) by N0 uni N1 uni N2 uni N3 uni FACT_UNFOLD uni PRDSUC uni PEANO uni LOGICTREE;

axiom EQSYM: forall n m.(n = m iff m = n);
setbasicsimp EQSYM at facts {EQSYM};

rewrite forall n.(suc(n)=zro iff FALSE) by PEANO uni EQSYM uni LOGICTREE;
setbasicsimp NS at facts {9};

rewrite (fact(suc(suc(suc(zro))))) by N0 uni NS uni FACT_UNFOLD uni PRDSUC uni PEANO uni LOGICTREE;

rewrite (fact(suc(suc(suc(suc(zro)))))) by N0 uni NS uni FACT_UNFOLD uni PRDSUC uni PEANO uni LOGICTREE;
</div>

<h2>Section 9: Reflection Principle</h2>

<p><em>"Change theorem proving in the theory into evaluation in the metatheory."</em></p>
<div class="live" id="sec9" data-lib="header">
NAMECONTEXT META;
DECLARE sort WFF FACT;
DECREP WFF FACT;
REPRESENT {WFF} as WFF;
REPRESENT {FACT} as FACT;
DECLARE predconst THEOREM 1;
DECLARE funconst mkand (WFF,WFF)=WFF;
DECLARE funconst wffof (FACT)=WFF;
DECLARE indvar A B [WFF];
DECLARE indvar T1 T2 [FACT];
AXIOM ANDI: forall A B.THEOREM(mkand(A,B));
AXIOM ANDI_SOUND: forall T1 T2.THEOREM(mkand(wffof(T1),wffof(T2)));
ATTACH mkand TO [WFF,WFF=WFF] mkand;
deflam wffof(x) (CADR x);
ATTACH wffof TO [FACT=WFF] wffof;
MAKECONTEXT OBJ;
SWITCHCONTEXT OBJ;
declare sentconst A B;
reflect ANDI A B;
nameproof P_AND_UNSOUND;
makeproof P1;
switchproof P1;
assume A;
impi 1 1;
theorem T1 2;
makeproof P2;
switchproof P2;
assume B;
impi 1 1;
theorem T2 2;
makeproof P_ANDS;
switchproof P_ANDS;
andi T1 T2;
reflect ANDI A B;
reflect ANDI_SOUND T1 T2;
reflect ANDI FALSE FALSE;
</div>

<h3>Section 9.1: Linear Equations</h3>

<p>We add a theory of minus \(-\).</p>
<div class="live" id="sec91_1" data-lib="appa header">
declare funconst -(NATNUM,NATNUM) = NATNUM [inf = 450 455];
deflam minus (N M) (LET ((R (- N M))) (COND ((&gt; R 0) R) (T 0)));
attach - to [NATNUM,NATNUM=NATNUM] minus;
axiom MINUS0R: forall n. n - zro = n;
axiom MINUS0L: forall n. zro - n = zro;
axiom MINUS: forall n m. suc(n) - suc(m) = n - m;
setbasicsimp TMINUS at facts {MINUS0R,MINUS0L,MINUS};
</div>

<p>We have some linear equations.</p>
<div class="live" id="sec91_2" data-lib="appa sec91_1 header">
declare indconst x y z [NATNUM];
axiom Ex: x + suc(suc(zro)) = suc(suc(suc(suc(suc(zro)))));
axiom Ey: y - suc(suc(zro)) = zro;
axiom Ez: z - suc(suc(zro)) = suc(suc(suc(zro)));
</div>

<p>Assuming the following theorems, we can solve by hand.</p>
<div class="live" id="sec91_3" data-lib="appa sec91_1 sec91_2 header">
axiom THM1: forall p q m.(p=q imp p-m=q-m);
axiom THM2: forall p q m.(m&lt;suc(q) imp (p+q)-m=p+(q-m));
theorem THM3 PLUS0;

setbasicsimp THM1 at facts {THM1};
setbasicsimp THM3 at facts {THM3};

alle THM2 x,suc(suc(zro)),suc(suc(zro));
simplify suc(suc(zro))&lt;suc(suc(suc(zro)));
impe 2 1;
theorem THM2instance 3;
setbasicsimp THM2instance at facts {THM2instance};

alle THM1 x+suc(suc(zro)),suc(suc(suc(suc(suc(zro))))),suc(suc(zro));
rewrite 4 by TMINUS uni THM2instance uni THM3 uni LOGICTREE;
iffe 5 1;
impe 6 4;
impe 7 Ex;
theorem THMx 8;
</div>

<p>Let us switch to the meta level, and do some algebra.
  <ul>
    <li>We will say (not prove) that:<ul>
        <li>\(x + n = m\) is \(x=m-n\) (if still non-negative)</li>
        <li>and \(x - n = m\) is \(x=m+n\) (always valid).</li>
    </ul></li>
    <li>We will require that:<ol>
        <li>the equation has one of the shapes above,</li>
        <li>including \(n\) and \(m\) are literal numbers</li>
        <li>for \(x=m-n\) we ensure that \(n<=m\).</li>
    </ol></li>
    <li>We will give a solved answer of the form \(x=n\).
      That is, we do all the checking and computation at the meta level.</li>
  </ul>
</p>
<div class="live" id="sec91_4" data-lib="appa sec91_1 sec91_2 header">
namecontext OBJ;
MAKECONTEXT META;
SWITCHCONTEXT META;

DECLARE PREDCONST THEOREM 1;

DECLARE SORT TERM WFF FACT PREDSYM FUNSYM;

DECREP TERM WFF FACT PREDSYM FUNSYM;
REPRESENT {TERM} AS TERM;
REPRESENT {WFF} AS WFF;
REPRESENT {FACT} AS FACT;
REPRESENT {PREDSYM} AS PREDSYM;
REPRESENT {FUNSYM} AS FUNSYM;

DECLARE FUNCONST wffof (FACT)=WFF;
ATTACH wffof TO [FACT=WFF] fact\-get\-wff;

DECLARE FUNCONST lhs rhs (WFF)=TERM;
DECLARE FUNCONST larg rarg (TERM)=TERM;
ATTACH lhs TO [WFF=TERM] lhs;
ATTACH rhs TO [WFF=TERM] rhs;
DEFLAM larg (t) (CAR (appl\-get\-args t));
ATTACH larg TO [TERM=TERM] larg;
DEFLAM rarg (t) (CADR (appl\-get\-args t));
ATTACH rarg TO [TERM=TERM] rarg;

DECLARE FUNCONST mainpred (WFF)=PREDSYM;
DECLARE FUNCONST pred2apply (PREDSYM TERM TERM)=WFF;
DECLARE INDCONST Equal [PREDSYM];
MATTACH Equal dar [PREDSYM] OBJ::PREDCONST:=;
DEFLAM mainpred (X) (AND (PREDAPPL X) (predappl\-get\-pred X));
ATTACH mainpred to [WFF=PREDSYM] mainpred;
ATTACH pred2apply TO [PREDSYM,TERM,TERM=WFF] predappl2\-mak;

DECLARE FUNCONST mainfun (TERM)=FUNSYM;
DECLARE FUNCONST fun1apply (FUNSYM TERM)=TERM;
DECLARE FUNCONST fun2apply (FUNSYM TERM TERM)=TERM;
DECLARE INDCONST zro [TERM];
DECLARE INDCONST suc + - [FUNSYM];
MATTACH zro dar [TERM] OBJ::INDCONST:zro;
MATTACH suc dar [FUNSYM] OBJ::FUNCONST:suc;
MATTACH + dar [FUNSYM] OBJ::FUNCONST:+;
MATTACH - dar [FUNSYM] OBJ::FUNCONST:-;
DEFLAM mainfun (X) (AND (FUNAPPL X) (funappl\-get\-fun X));
ATTACH mainfun to [TERM=FUNSYM] mainfun;
ATTACH fun1apply TO [FUNSYM,TERM=TERM] funappl1\-mak;
ATTACH fun2apply TO [FUNSYM,TERM,TERM=TERM] funappl2\-mak;

DECLARE indvar x y z [TERM];
DECLARE indvar w [WFF];
DECLARE indvar vl [FACT];

DECLARE PREDCONST NUMERAL 1;
DECLARE PREDCONST numeral 3;
DEFLAM numeral (X zro suc) (OR (EQ X zro) (AND (FUNAPPL X) (EQ (funappl\-get\-fun X) suc) (numeral (funappl1\-get\-arg X) zro suc)));
ATTACH numeral TO [TERM,TERM,FUNSYM] numeral;
AXIOM AX_NUMERAL: forall x.(NUMERAL(x) iff numeral(x,zro,suc));

KNOW natnums;
declare indvar n [NATNUMSORT];
DECLARE FUNCONST mknum (TERM)=NATNUMSORT;
DEFLAM mknum (X) (IF (FUNAPPL X) (ADD1 (mknum (funappl1\-get\-arg X))) 0);
ATTACH mknum TO [TERM=NATNUMREP] mknum;
DECLARE FUNCONST mknumerali (NATNUMSORT,TERM,FUNSYM)=TERM;
DECLARE FUNCONST mknumeral (NATNUMSORT)=TERM;
DEFLAM mknumerali (X zro suc) (IF (= X 0) zro (funappl1\-mak suc (mknumerali (SUB1 X) zro suc)));
ATTACH mknumerali TO [NATNUMREP,TERM,FUNSYM=TERM] mknumerali;
AXIOM AX_MKNUMERAL: forall n.(mknumeral(n)=mknumerali(n,zro,suc));

DECLARE PREDCONST LEQ 2;
DEFLAM leq (X Y) (OR (&lt; X Y) (= X Y));
ATTACH LEQ TO [NATNUMREP,NATNUMREP] leq;

DECLARE FUNCONST plus minus (NATNUMSORT NATNUMSORT)=NATNUMSORT;
ATTACH plus TO [NATNUMREP,NATNUMREP=NATNUMREP] +;
ATTACH minus TO [NATNUMREP,NATNUMREP=NATNUMREP] -;

DECLARE FUNCONST mkequal (TERM TERM)=WFF;
AXIOM AX_MKEQUAL: forall x y.mkequal(x,y)=pred2apply(Equal,x,y);

DECLARE PREDCONST LINEAREQ 2;
DECLARE FUNCONST solve (WFF TERM)=TERM;
</div>

<p>The 3 next axioms are close to the formulation in the paper.</p>
<div class="live" id="sec91_5" data-lib="appa sec91_1 sec91_2 sec91_4 header">
AXIOM AX_LINEAREQ: forall w x.(LINEAREQ(w,x) iff (
  mainpred(w)=Equal and
  (mainfun(lhs(w))=+ or mainfun(lhs(w))=-) and
  larg(lhs(w))=x and
  (NUMERAL(rarg(lhs(w))) and NUMERAL(rhs(w))) and
  (mainfun(lhs(w))=+ imp LEQ(mknum(larg(lhs(w))),mknum(rhs(w))))));

AXIOM AX_SOLVE: forall w x.(solve(w, x)=
  trmif mainfun(lhs(w))=+
  then mknumeral(minus(mknum(rhs(w)),mknum(rarg(lhs(w)))))
  else mknumeral(plus(mknum(rhs(w)),mknum(rarg(lhs(w))))));

AXIOM SOLVE: forall vl x.(LINEAREQ(wffof(vl),x) imp THEOREM(mkequal(x,solve(wffof(vl),x))));

SETBASICSIMP meta\-axioms at facts {AX_LINEAREQ,AX_SOLVE,AX_NUMERAL,AX_MKNUMERAL,AX_MKEQUAL};
SETCOMPSIMP EVALSS AT LOGICTREE uni meta\-axioms;

SWITCHCONTEXT OBJ;
</div>

<p>Back at the object level, we can solve the linear equations with a
single reflective call.</p>
<div class="live" id="sec91_6" data-lib="appa sec91_1 sec91_2 sec91_4 sec91_5 header">
reflect SOLVE Ey y;
theorem THMy 9;

reflect SOLVE Ex x;
theorem THx2 10;

reflect SOLVE Ez z;
theorem THMz 11;

show axiom;
</div>

<h2>Appendix A: An Axiomatization of Natural Numbers</h2>
<div class="live" id="appa">
declare sort NATNUM;
declare indvar n m p q [NATNUM];
declare indconst zro [NATNUM];
declare funconst suc prd (NATNUM) = NATNUM;
declare funconst +(NATNUM,NATNUM) = NATNUM [inf = 450 455];
declare funconst *(NATNUM,NATNUM) = NATNUM [inf = 550 555];
declare predconst &lt; 2 [inf];
declare predpar P 1;

axiom ONEONE: forall n m.(suc(n)=suc(m) imp n=m);
axiom SUCC1: forall n.not(zro=suc(n));
axiom SUCC2: forall n.not(zro=n) imp exists m.n=suc(m);
axiom PLUS0: forall n. n + zro = n;
axiom PLUS: forall n m. n+suc(m)=suc(n+m);
axiom TIMES0: forall n. n * zro = zro;
axiom TIMES: forall n m. n*suc(m)=(n*m)+n;

axiom INDUCT: P(zro) and forall n.(P(n) imp P(suc(n))) imp forall n.P(n);

setbasicsimp PEANO at facts {ONEONE,SUCC1,SUCC2,PLUS0,PLUS,TIMES0,TIMES};

decrep NATNUM;
represent {NATNUM} as NATNUM;
attach zro to [NATNUM] 0;
attach suc to [NATNUM=NATNUM] ADD1;
deflam prd(x) (COND ((&gt; x 0) (SUB1 x)) (T 0));
attach prd to [NATNUM=NATNUM] prd;
attach + to [NATNUM,NATNUM=NATNUM] +;
attach * to [NATNUM,NATNUM=NATNUM] *;
attach &lt; to [NATNUM,NATNUM] &lt;;
</div>

<h2>Appendix B: An Axiomatization of S-Expressions</h2>
<div class="live" id="appb">
declare sort Sexp Lisp Null Atom;
declare indvar x y z [Sexp];
declare indvar u v w [List];
declare indconst nil [Null];

declare funconst car cdr 1;
declare funconst cons(Sexp,List)=List;
declare funconst rev 1;
declare funconst @ 2 [inf];

moregeneral Sexp &lt; List, Atom, Null &gt;;
moregeneral List &lt; Null &gt;;

decrep Sexp;
represent {Sexp} as Sexp;
represent {List} as Sexp;
represent {Atom} as Sexp;
represent {Null} as Sexp;

axiom CAR: forall x y. car(cons(x,y))=x;
axiom CDR: forall x y. cdr(cons(x,y))=y;
axiom CONS: forall x y. not(Null(cons(x,y)));

setbasicsimp Basic at facts {CAR,CDR,CONS};

axiom REV: forall u.(rev(u) = trmif Null(u) then u else rev(cdr(u)) @ cons(car(u),nil));
axiom APPEND: forall u v.(u@v = trmif Null(u) then v else cons(car(u),cdr(u)@v));

setbasicsimp Funs at facts {REV,APPEND};
</div>

<h2>Appendix D: Semantic Evaluations</h2>

<div class="live" id="appd" data-lib="appa appb">
declare funconst length (List)=NATNUM;
attach cons to [Sexp,Sexp=Sexp] CONS;
attach car to [Sexp=Sexp] CAR;
attach cdr to [Sexp=Sexp] CDR;
attach nil to [Sexp] NIL;
attach length to [Sexp=NATNUM] LENGTH;

simplify length(cons(nil, cons(nil, nil)))=suc(suc(zro));

simplify suc(zro)+zro=zro;

simplify zro &lt; prd(suc(suc(zro)));
</div>

<h2>Appendix E: Syntactic Simplification</h2>

<div class="live" id="appe" data-lib="appa appb">
simplify Null(nil);

setbasicsimp S1 at facts {1};

rewrite rev(cons(x,nil)) by Basic uni Funs uni S1 uni LOGICTREE;
</div>

<h2>Playground</h2>

<div class="live" id="playground">
</div>

{% endblock %}
